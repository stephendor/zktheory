64f0df45154dc6037c335ffb2adcefc2
/**
 * Comprehensive Jest Unit Tests for StandardLayouts
 * Tests mathematical accuracy, geometric properties, and layout generation algorithms
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _StandardLayouts = require("../../lib/StandardLayouts");
const _GroupDatabase = require("../../lib/GroupDatabase");
const _mathematicalValidation = require("../utils/mathematicalValidation");
// Extend Jest matchers
expect.extend(_mathematicalValidation.mathematicalMatchers);
describe('StandardLayoutGenerator', ()=>{
    describe('Klein Four Group Layout (V4)', ()=>{
        let layout;
        beforeEach(()=>{
            layout = _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout();
        });
        test('generates correct V4 group structure', ()=>{
            expect(layout).toHaveProperty('positions');
            expect(layout).toHaveProperty('description');
            expect(layout).toHaveProperty('generators');
            expect(layout.description).toBe("Klein Four Group - Square arrangement");
            expect(layout.generators).toEqual([
                'a',
                'b'
            ]);
        });
        test('validates V4 element positioning', ()=>{
            const { positions } = layout;
            // Check all required elements present
            expect(positions).toHaveProperty('e'); // Identity
            expect(positions).toHaveProperty('a'); // First generator
            expect(positions).toHaveProperty('b'); // Second generator
            expect(positions).toHaveProperty('c'); // Product ab
            // Validate coordinate ranges [0, 1]
            Object.values(positions).forEach((pos)=>{
                expect(pos.x).toBeGreaterThanOrEqual(0);
                expect(pos.x).toBeLessThanOrEqual(1);
                expect(pos.y).toBeGreaterThanOrEqual(0);
                expect(pos.y).toBeLessThanOrEqual(1);
                expect(Number.isFinite(pos.x)).toBe(true);
                expect(Number.isFinite(pos.y)).toBe(true);
            });
        });
        test('verifies V4 geometric properties', ()=>{
            const { positions } = layout;
            // Identity should be at center
            expect(positions.e.x).toBeCloseTo(0.5, 5);
            expect(positions.e.y).toBeCloseTo(0.5, 5);
            // Verify rectangular arrangement constraints
            expect(positions.a.x).toBeLessThan(positions.e.x); // Left of center
            expect(positions.b.x).toBeGreaterThan(positions.e.x); // Right of center
            expect(positions.c.y).toBeLessThan(positions.e.y); // Above center
        });
        test('validates symmetry properties', ()=>{
            const { positions } = layout;
            // Calculate distances from center
            const distances = {
                a: Math.sqrt((positions.a.x - 0.5) ** 2 + (positions.a.y - 0.5) ** 2),
                b: Math.sqrt((positions.b.x - 0.5) ** 2 + (positions.b.y - 0.5) ** 2),
                c: Math.sqrt((positions.c.x - 0.5) ** 2 + (positions.c.y - 0.5) ** 2)
            };
            // Non-identity elements should be equidistant from center
            expect(distances.a).toBeCloseTo(distances.b, 5);
            expect(distances.a).toBeCloseTo(distances.c, 5);
        });
        test('ensures unique positioning', ()=>{
            const { positions } = layout;
            const coords = Object.values(positions).map((p)=>`${p.x},${p.y}`);
            const uniqueCoords = new Set(coords);
            expect(uniqueCoords.size).toBe(coords.length);
        });
    });
    describe('Quaternion Group Layout (Q8)', ()=>{
        let layout;
        beforeEach(()=>{
            layout = _StandardLayouts.StandardLayoutGenerator.getQuaternionLayout();
        });
        test('generates correct Q8 group structure', ()=>{
            expect(layout.description).toBe("Quaternion Group Q8 - Cube projection");
            expect(layout.generators).toEqual([
                'i',
                'j'
            ]);
            // Should have 8 elements
            expect(Object.keys(layout.positions)).toHaveLength(8);
        });
        test('validates Q8 element positioning', ()=>{
            const { positions } = layout;
            const expectedElements = [
                '1',
                '-1',
                'i',
                '-i',
                'j',
                '-j',
                'k',
                '-k'
            ];
            expectedElements.forEach((element)=>{
                expect(positions).toHaveProperty(element);
                expect(Number.isFinite(positions[element].x)).toBe(true);
                expect(Number.isFinite(positions[element].y)).toBe(true);
            });
        });
        test('verifies Q8 quaternion pairing properties', ()=>{
            const { positions } = layout;
            // Quaternion opposites should have specific geometric relationships
            const pairs = [
                [
                    '1',
                    '-1'
                ],
                [
                    'i',
                    '-i'
                ],
                [
                    'j',
                    '-j'
                ],
                [
                    'k',
                    '-k'
                ]
            ];
            pairs.forEach(([pos, neg])=>{
                const distance = Math.sqrt((positions[pos].x - positions[neg].x) ** 2 + (positions[pos].y - positions[neg].y) ** 2);
                expect(distance).toBeGreaterThan(0.1); // Should be separated
            });
        });
        test('validates cube projection geometry', ()=>{
            const { positions } = layout;
            // Identity at center
            expect(positions['1'].x).toBeCloseTo(0.5, 5);
            expect(positions['1'].y).toBeCloseTo(0.5, 5);
            // All positions should be in [0,1] × [0,1]
            Object.values(positions).forEach((pos)=>{
                expect(pos.x).toBeGreaterThanOrEqual(0);
                expect(pos.x).toBeLessThanOrEqual(1);
                expect(pos.y).toBeGreaterThanOrEqual(0);
                expect(pos.y).toBeLessThanOrEqual(1);
            });
        });
        test('ensures mathematical consistency with quaternion relations', ()=>{
            const { positions } = layout;
            // Verify generators are present and positioned
            expect(positions).toHaveProperty('i');
            expect(positions).toHaveProperty('j');
            expect(positions).toHaveProperty('k');
            // Check that i, j, k are distributed around the layout
            const iPos = positions['i'];
            const jPos = positions['j'];
            const kPos = positions['k'];
            // They should form a non-degenerate triangle
            const area = Math.abs((iPos.x * (jPos.y - kPos.y) + jPos.x * (kPos.y - iPos.y) + kPos.x * (iPos.y - jPos.y)) / 2);
            expect(area).toBeGreaterThan(0.01); // Non-zero area
        });
    });
    describe('Dihedral Group Layouts', ()=>{
        describe('Dihedral D3 (S3) Layout', ()=>{
            let layout;
            beforeEach(()=>{
                layout = _StandardLayouts.StandardLayoutGenerator.getDihedral3Layout();
            });
            test('generates correct D3 group structure', ()=>{
                expect(layout.description).toBe("Dihedral D3 (S3) - Triangular symmetry");
                expect(layout.generators).toEqual([
                    'r',
                    's'
                ]);
                expect(Object.keys(layout.positions)).toHaveLength(6);
            });
            test('validates D3 element positioning', ()=>{
                const { positions } = layout;
                const expectedElements = [
                    'e',
                    'r',
                    'r²',
                    's',
                    'sr',
                    'sr²'
                ];
                expectedElements.forEach((element)=>{
                    expect(positions).toHaveProperty(element);
                });
            });
            test('verifies triangular symmetry properties', ()=>{
                const { positions } = layout;
                // Identity at center
                expect(positions.e.x).toBeCloseTo(0.5, 5);
                expect(positions.e.y).toBeCloseTo(0.5, 5);
                // Rotation elements should form a pattern
                const rotations = [
                    positions.r,
                    positions['r²']
                ];
                rotations.forEach((pos)=>{
                    const distance = Math.sqrt((pos.x - 0.5) ** 2 + (pos.y - 0.5) ** 2);
                    expect(distance).toBeGreaterThan(0.1); // Away from center
                });
            });
            test('validates reflection arrangement', ()=>{
                const { positions } = layout;
                const reflections = [
                    's',
                    'sr',
                    'sr²'
                ];
                // Reflections should be positioned to show triangular symmetry
                reflections.forEach((refl)=>{
                    expect(positions[refl].x).toBeGreaterThanOrEqual(0);
                    expect(positions[refl].x).toBeLessThanOrEqual(1);
                    expect(positions[refl].y).toBeGreaterThanOrEqual(0);
                    expect(positions[refl].y).toBeLessThanOrEqual(1);
                });
            });
        });
        describe('Dihedral D4 Layout', ()=>{
            let layout;
            beforeEach(()=>{
                layout = _StandardLayouts.StandardLayoutGenerator.getDihedral4Layout();
            });
            test('generates correct D4 group structure', ()=>{
                expect(layout.description).toBe("Dihedral D4 - Square symmetry");
                expect(layout.generators).toEqual([
                    'r',
                    's'
                ]);
                expect(Object.keys(layout.positions)).toHaveLength(8);
            });
            test('validates D4 square symmetry properties', ()=>{
                const { positions } = layout;
                // Check rotation elements form a square pattern
                const rotations = [
                    positions.r,
                    positions['r²'],
                    positions['r³']
                ];
                const center = positions.e;
                // Calculate distances from center for rotations
                const distances = rotations.map((pos)=>Math.sqrt((pos.x - center.x) ** 2 + (pos.y - center.y) ** 2));
                // All rotations should be equidistant from center
                expect(distances[0]).toBeCloseTo(distances[1], 5);
                expect(distances[0]).toBeCloseTo(distances[2], 5);
            });
            test('verifies square geometric constraints', ()=>{
                const { positions } = layout;
                // Check that rotations approximate a square arrangement
                const r = positions.r;
                const r2 = positions['r²'];
                const r3 = positions['r³'];
                // Adjacent rotations should be roughly equidistant
                const d1 = Math.sqrt((r.x - r2.x) ** 2 + (r.y - r2.y) ** 2);
                const d2 = Math.sqrt((r2.x - r3.x) ** 2 + (r2.y - r3.y) ** 2);
                expect(Math.abs(d1 - d2)).toBeLessThan(0.1); // Similar distances
            });
        });
    });
    describe('Cyclic Group Circular Layouts', ()=>{
        test.each([
            3,
            4,
            5,
            6,
            8,
            12
        ])('generates valid C%d circular layout', (n)=>{
            const layout = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(n);
            expect(layout.description).toBe(`Cyclic C${n} - Circular arrangement`);
            expect(layout.generators).toEqual([
                '1'
            ]);
            expect(Object.keys(layout.positions)).toHaveLength(n);
        });
        test('validates circular positioning mathematics for C6', ()=>{
            const layout = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(6);
            const { positions } = layout;
            // Check all positions are on a circle
            const radius = 0.35; // From implementation
            const center = {
                x: 0.5,
                y: 0.5
            };
            Object.values(positions).forEach((pos)=>{
                const distance = Math.sqrt((pos.x - center.x) ** 2 + (pos.y - center.y) ** 2);
                expect(distance).toBeCloseTo(radius, 4);
            });
        });
        test('verifies angular distribution for cyclic groups', ()=>{
            const n = 8;
            const layout = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(n);
            const { positions } = layout;
            // Calculate angles for each position
            const center = {
                x: 0.5,
                y: 0.5
            };
            const angles = Object.keys(positions).sort((a, b)=>parseInt(a) - parseInt(b)).map((key)=>{
                const pos = positions[key];
                let angle = Math.atan2(pos.y - center.y, pos.x - center.x);
                // Normalize to [0, 2π] and account for starting from top (-π/2)
                angle = (angle + Math.PI / 2 + 2 * Math.PI) % (2 * Math.PI);
                return angle;
            });
            // Check distribution - consecutive angles should be evenly spaced
            const expectedAngleStep = 2 * Math.PI / n;
            for(let i = 0; i < angles.length; i++){
                const expectedAngle = expectedAngleStep * i % (2 * Math.PI);
                expect(angles[i]).toBeCloseTo(expectedAngle, 1);
            }
        });
        test('handles edge cases for small cyclic groups', ()=>{
            // C1 - single element
            const c1 = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(1);
            expect(Object.keys(c1.positions)).toHaveLength(1);
            // Check position is roughly at top (allowing for floating point precision)
            const pos = c1.positions['0'];
            expect(pos.x).toBeCloseTo(0.5, 5);
            expect(pos.y).toBeCloseTo(0.15, 5);
            // C2 - two elements
            const c2 = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(2);
            expect(Object.keys(c2.positions)).toHaveLength(2);
        });
    });
    describe('Direct Product Layouts', ()=>{
        test.each([
            [
                2,
                2
            ],
            [
                2,
                3
            ],
            [
                3,
                3
            ],
            [
                2,
                4
            ],
            [
                3,
                4
            ]
        ])('generates valid C%d × C%d grid layout', (m, n)=>{
            const layout = _StandardLayouts.StandardLayoutGenerator.getDirectProductLayout(m, n);
            expect(layout.description).toBe(`Direct Product C${m} × C${n} - Grid arrangement`);
            expect(layout.generators).toEqual([
                '(1,0)',
                '(0,1)'
            ]);
            expect(Object.keys(layout.positions)).toHaveLength(m * n);
        });
        test('validates grid positioning mathematics for C3 × C2', ()=>{
            const layout = _StandardLayouts.StandardLayoutGenerator.getDirectProductLayout(3, 2);
            const { positions } = layout;
            // Check grid structure
            const expectedPositions = [
                '(0,0)',
                '(0,1)',
                '(1,0)',
                '(1,1)',
                '(2,0)',
                '(2,1)'
            ];
            expectedPositions.forEach((pos)=>{
                expect(positions).toHaveProperty(pos);
            });
            // Verify positions form a proper grid
            const margin = 0.1;
            const availableWidth = 1 - 2 * margin;
            const availableHeight = 1 - 2 * margin;
            // Check some specific positions
            expect(positions['(0,0)'].x).toBeCloseTo(margin, 5);
            expect(positions['(0,0)'].y).toBeCloseTo(margin, 5);
            expect(positions['(2,1)'].x).toBeCloseTo(margin + availableWidth, 5);
            expect(positions['(2,1)'].y).toBeCloseTo(margin + availableHeight, 5);
        });
        test('handles edge case for 1×n and n×1 products', ()=>{
            const layout1xn = _StandardLayouts.StandardLayoutGenerator.getDirectProductLayout(1, 3);
            expect(Object.keys(layout1xn.positions)).toHaveLength(3);
            const layoutnx1 = _StandardLayouts.StandardLayoutGenerator.getDirectProductLayout(3, 1);
            expect(Object.keys(layoutnx1.positions)).toHaveLength(3);
        });
    });
    describe('Alternating A4 Layout', ()=>{
        let layout;
        beforeEach(()=>{
            layout = _StandardLayouts.StandardLayoutGenerator.getAlternating4Layout();
        });
        test('generates correct A4 group structure', ()=>{
            expect(layout.description).toBe("Alternating A4 - Tetrahedral arrangement");
            expect(layout.generators).toEqual([
                '(123)',
                '(12)(34)'
            ]);
            expect(Object.keys(layout.positions)).toHaveLength(12);
        });
        test('validates A4 element positioning', ()=>{
            const { positions } = layout;
            const expectedElements = [
                'e',
                '(123)',
                '(132)',
                '(124)',
                '(142)',
                '(134)',
                '(143)',
                '(234)',
                '(243)',
                '(12)(34)',
                '(13)(24)',
                '(14)(23)'
            ];
            expectedElements.forEach((element)=>{
                expect(positions).toHaveProperty(element);
            });
        });
        test('verifies tetrahedral symmetry properties', ()=>{
            const { positions } = layout;
            // Identity at center
            expect(positions.e.x).toBeCloseTo(0.5, 5);
            expect(positions.e.y).toBeCloseTo(0.5, 5);
            // Check that 3-cycles and double transpositions are positioned appropriately
            const threeCycles = [
                '(123)',
                '(132)',
                '(124)',
                '(142)',
                '(134)',
                '(143)',
                '(234)',
                '(243)'
            ];
            const doubleTranspositions = [
                '(12)(34)',
                '(13)(24)',
                '(14)(23)'
            ];
            // All positions should be within bounds
            [
                ...threeCycles,
                ...doubleTranspositions
            ].forEach((element)=>{
                const pos = positions[element];
                expect(pos.x).toBeGreaterThanOrEqual(0);
                expect(pos.x).toBeLessThanOrEqual(1);
                expect(pos.y).toBeGreaterThanOrEqual(0);
                expect(pos.y).toBeLessThanOrEqual(1);
            });
        });
    });
    describe('Group Type Detection and Layout Selection', ()=>{
        test('recognizes and generates correct layouts for standard groups', ()=>{
            const testCases = [
                {
                    name: 'C1',
                    expectedType: 'trivial'
                },
                {
                    name: 'V4',
                    expectedType: 'klein'
                },
                {
                    name: 'Klein4',
                    expectedType: 'klein'
                },
                {
                    name: 'Q8',
                    expectedType: 'quaternion'
                },
                {
                    name: 'Q4',
                    expectedType: 'quaternion'
                },
                {
                    name: 'D3',
                    expectedType: 'dihedral3'
                },
                {
                    name: 'S3',
                    expectedType: 'dihedral3'
                },
                {
                    name: 'D4',
                    expectedType: 'dihedral4'
                },
                {
                    name: 'A4',
                    expectedType: 'alternating4'
                }
            ];
            testCases.forEach(({ name, expectedType })=>{
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(name, 0);
                expect(layout).not.toBeNull();
                expect(layout?.positions).toBeDefined();
            });
        });
        test('handles cyclic group pattern matching', ()=>{
            for(let n = 2; n <= 20; n++){
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(`C${n}`, n);
                expect(layout).not.toBeNull();
                expect(layout?.description).toContain(`Cyclic C${n}`);
                expect(Object.keys(layout?.positions || {})).toHaveLength(n);
            }
        });
        test('handles dihedral group pattern matching', ()=>{
            const d3 = _StandardLayouts.StandardLayoutGenerator.getStandardLayout('D3', 6);
            expect(d3).not.toBeNull();
            expect(d3?.description).toContain('D3');
            const d4 = _StandardLayouts.StandardLayoutGenerator.getStandardLayout('D4', 8);
            expect(d4).not.toBeNull();
            expect(d4?.description).toContain('D4');
        });
        test('handles direct product pattern matching', ()=>{
            const testCases = [
                'C2xC2',
                'C2xC3',
                'C3xC2',
                'C2xC4'
            ];
            testCases.forEach((groupName)=>{
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(groupName, 0);
                expect(layout).not.toBeNull();
                expect(layout?.description).toContain('Direct Product');
            });
        });
        test('returns null for unknown group patterns', ()=>{
            const unknownGroups = [
                'InvalidGroup',
                'X7',
                'Z99',
                'ComplexGroup'
            ];
            unknownGroups.forEach((name)=>{
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(name, 0);
                expect(layout).toBeNull();
            });
        });
        test('handles edge cases in pattern matching', ()=>{
            // Very large cyclic groups
            const c50 = _StandardLayouts.StandardLayoutGenerator.getStandardLayout('C50', 50);
            expect(c50).toBeNull(); // Should reject groups > 20
            // Malformed names
            const malformed = _StandardLayouts.StandardLayoutGenerator.getStandardLayout('C', 0);
            expect(malformed).toBeNull();
            const malformed2 = _StandardLayouts.StandardLayoutGenerator.getStandardLayout('CxC', 0);
            expect(malformed2).toBeNull();
        });
    });
    describe('Layout Position Calculations', ()=>{
        test('validates mathematical accuracy of coordinate generation', ()=>{
            const tolerance = _mathematicalValidation.MATHEMATICAL_PRECISION.FLOAT_TOLERANCE;
            // Test cyclic group positions using trigonometry
            const n = 6;
            const layout = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(n);
            const radius = 0.35;
            const center = {
                x: 0.5,
                y: 0.5
            };
            Object.keys(layout.positions).forEach((key, index)=>{
                const expectedAngle = 2 * Math.PI * index / n - Math.PI / 2;
                const expectedX = center.x + radius * Math.cos(expectedAngle);
                const expectedY = center.y + radius * Math.sin(expectedAngle);
                const actual = layout.positions[key];
                expect(Math.abs(actual.x - expectedX)).toBeLessThan(tolerance);
                expect(Math.abs(actual.y - expectedY)).toBeLessThan(tolerance);
            });
        });
        test('verifies coordinate precision and stability', ()=>{
            // Test multiple generations produce identical results
            const layouts = Array.from({
                length: 5
            }, ()=>_StandardLayouts.StandardLayoutGenerator.getKleinFourLayout());
            const firstLayout = layouts[0];
            layouts.slice(1).forEach((layout)=>{
                Object.keys(firstLayout.positions).forEach((key)=>{
                    expect(layout.positions[key].x).toBe(firstLayout.positions[key].x);
                    expect(layout.positions[key].y).toBe(firstLayout.positions[key].y);
                });
            });
        });
        test('validates floating point stability in calculations', ()=>{
            // Test with edge cases that might cause precision issues
            const testSizes = [
                7,
                11,
                13,
                17
            ]; // Prime numbers
            testSizes.forEach((n)=>{
                const layout = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(n);
                Object.values(layout.positions).forEach((pos)=>{
                    expect(Number.isFinite(pos.x)).toBe(true);
                    expect(Number.isFinite(pos.y)).toBe(true);
                    expect(Number.isNaN(pos.x)).toBe(false);
                    expect(Number.isNaN(pos.y)).toBe(false);
                });
            });
        });
    });
    describe('Geometric Properties and Visual Quality', ()=>{
        test('validates symmetry preservation in layouts', ()=>{
            // Test Klein Four Group symmetry
            const v4 = _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout();
            const center = v4.positions.e;
            // Calculate symmetry measures
            const nonIdentityElements = [
                'a',
                'b',
                'c'
            ];
            const distances = nonIdentityElements.map((elem)=>{
                const pos = v4.positions[elem];
                return Math.sqrt((pos.x - center.x) ** 2 + (pos.y - center.y) ** 2);
            });
            // Check symmetry: all distances should be equal (within tolerance)
            const avgDistance = distances.reduce((a, b)=>a + b) / distances.length;
            distances.forEach((d)=>{
                expect(Math.abs(d - avgDistance)).toBeLessThan(0.01);
            });
        });
        test('validates visual balance and spacing', ()=>{
            const layouts = [
                _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout(),
                _StandardLayouts.StandardLayoutGenerator.getQuaternionLayout(),
                _StandardLayouts.StandardLayoutGenerator.getDihedral3Layout(),
                _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(8)
            ];
            layouts.forEach((layout)=>{
                const positions = Object.values(layout.positions);
                // Check minimum spacing between elements
                const minDistance = positions.reduce((min, pos1)=>{
                    return positions.reduce((minInner, pos2)=>{
                        if (pos1 === pos2) return minInner;
                        const dist = Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2);
                        return Math.min(minInner, dist);
                    }, min);
                }, Infinity);
                expect(minDistance).toBeGreaterThan(0.05); // Minimum spacing
            });
        });
        test('validates bounding box utilization', ()=>{
            const layouts = [
                _StandardLayouts.StandardLayoutGenerator.getQuaternionLayout(),
                _StandardLayouts.StandardLayoutGenerator.getDihedral4Layout(),
                _StandardLayouts.StandardLayoutGenerator.getAlternating4Layout()
            ];
            layouts.forEach((layout)=>{
                const positions = Object.values(layout.positions);
                // Calculate bounding box
                const minX = Math.min(...positions.map((p)=>p.x));
                const maxX = Math.max(...positions.map((p)=>p.x));
                const minY = Math.min(...positions.map((p)=>p.y));
                const maxY = Math.max(...positions.map((p)=>p.y));
                // Should use reasonable portion of [0,1] × [0,1] space
                const xRange = maxX - minX;
                const yRange = maxY - minY;
                expect(xRange).toBeGreaterThan(0.1); // Not too compressed
                expect(yRange).toBeGreaterThan(0.1);
                expect(xRange).toBeLessThan(1.0); // Within bounds
                expect(yRange).toBeLessThan(1.0);
            });
        });
    });
    describe('Edge Cases and Error Handling', ()=>{
        test('handles malformed group names gracefully', ()=>{
            const malformedNames = [
                '',
                '   ',
                'C',
                'D',
                'CxC',
                'C2x',
                'xC3',
                'C-1',
                'D0'
            ];
            malformedNames.forEach((name)=>{
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(name, 0);
                expect(layout).toBeNull();
            });
        });
        test('handles boundary conditions for cyclic groups', ()=>{
            // Very small groups
            const c1 = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(1);
            expect(Object.keys(c1.positions)).toHaveLength(1);
            // Groups at the boundary
            const c20 = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(20);
            expect(Object.keys(c20.positions)).toHaveLength(20);
            // Verify positions are still valid
            Object.values(c20.positions).forEach((pos)=>{
                expect(pos.x).toBeGreaterThanOrEqual(0);
                expect(pos.x).toBeLessThanOrEqual(1);
                expect(pos.y).toBeGreaterThanOrEqual(0);
                expect(pos.y).toBeLessThanOrEqual(1);
            });
        });
        test('handles edge cases in direct product layouts', ()=>{
            // Single factor groups
            const c1x1 = _StandardLayouts.StandardLayoutGenerator.getDirectProductLayout(1, 1);
            expect(Object.keys(c1x1.positions)).toHaveLength(1);
            // Ensure no division by zero or invalid coordinates
            Object.values(c1x1.positions).forEach((pos)=>{
                expect(Number.isFinite(pos.x)).toBe(true);
                expect(Number.isFinite(pos.y)).toBe(true);
            });
        });
        test('validates unknown group types return null', ()=>{
            const unknownTypes = [
                'PSL(2,7)',
                'GL(2,3)',
                'Quaternion16',
                'DicyclicD8',
                'AlternatingA5'
            ];
            unknownTypes.forEach((name)=>{
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(name, 0);
                expect(layout).toBeNull();
            });
        });
    });
    describe('Integration with Group Theory', ()=>{
        test('validates layouts match actual group structures from GroupDatabase', ()=>{
            const testGroups = [
                'C3',
                'C4',
                'V4',
                'S3'
            ];
            testGroups.forEach((groupName)=>{
                const group = _GroupDatabase.GroupDatabase.getGroup(groupName);
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(groupName, group?.order || 0);
                if (group && layout) {
                    // Layout should have position for each group element
                    expect(Object.keys(layout.positions).length).toBeLessThanOrEqual(group.order);
                    // Generators should exist in group
                    layout.generators?.forEach((gen)=>{
                        if (gen !== '1') {
                            const hasElement = group.elements.some((elem)=>elem.id === gen || elem.label === gen);
                        // This is informational - layouts may use different notation
                        }
                    });
                }
            });
        });
        test('verifies generator consistency between layouts and group theory', ()=>{
            // Test that layout generators make mathematical sense
            const v4Layout = _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout();
            expect(v4Layout.generators).toHaveLength(2); // V4 needs 2 generators
            const c5Layout = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(5);
            expect(c5Layout.generators).toHaveLength(1); // Cyclic groups need 1 generator
            const d3Layout = _StandardLayouts.StandardLayoutGenerator.getDihedral3Layout();
            expect(d3Layout.generators).toHaveLength(2); // Dihedral groups need 2 generators
        });
    });
    describe('Performance and Scalability', ()=>{
        test('generates layouts efficiently for various group sizes', ()=>{
            const testCases = [
                {
                    name: 'C8',
                    order: 8
                },
                {
                    name: 'C12',
                    order: 12
                },
                {
                    name: 'D4',
                    order: 8
                },
                {
                    name: 'Q8',
                    order: 8
                }
            ];
            testCases.forEach(({ name, order })=>{
                const startTime = performance.now();
                const layout = _StandardLayouts.StandardLayoutGenerator.getStandardLayout(name, order);
                const endTime = performance.now();
                expect(endTime - startTime).toBeLessThan(10); // Should be fast
                expect(layout).not.toBeNull();
            });
        });
        test('handles memory efficiently for multiple layout generations', ()=>{
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            // Generate many layouts
            for(let i = 0; i < 100; i++){
                _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(8);
                _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout();
                _StandardLayouts.StandardLayoutGenerator.getQuaternionLayout();
            }
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable (less than 5MB)
            expect(memoryIncrease).toBeLessThan(5 * 1024 * 1024);
        });
        test('validates deterministic layout generation', ()=>{
            // Same input should always produce same output
            const layouts1 = Array.from({
                length: 5
            }, ()=>_StandardLayouts.StandardLayoutGenerator.getCyclicLayout(6));
            const layouts2 = Array.from({
                length: 5
            }, ()=>_StandardLayouts.StandardLayoutGenerator.getCyclicLayout(6));
            layouts1.forEach((layout1, index)=>{
                const layout2 = layouts2[index];
                Object.keys(layout1.positions).forEach((key)=>{
                    expect(layout1.positions[key]).toEqual(layout2.positions[key]);
                });
            });
        });
    });
    describe('Mathematical Rigor and Validation', ()=>{
        test('validates coordinate bounds and finite values', ()=>{
            const allLayouts = [
                _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout(),
                _StandardLayouts.StandardLayoutGenerator.getQuaternionLayout(),
                _StandardLayouts.StandardLayoutGenerator.getDihedral3Layout(),
                _StandardLayouts.StandardLayoutGenerator.getDihedral4Layout(),
                _StandardLayouts.StandardLayoutGenerator.getAlternating4Layout(),
                _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(7),
                _StandardLayouts.StandardLayoutGenerator.getDirectProductLayout(2, 3)
            ];
            allLayouts.forEach((layout)=>{
                Object.values(layout.positions).forEach((pos)=>{
                    // Coordinates should be in [0, 1]
                    expect(pos.x).toBeGreaterThanOrEqual(0);
                    expect(pos.x).toBeLessThanOrEqual(1);
                    expect(pos.y).toBeGreaterThanOrEqual(0);
                    expect(pos.y).toBeLessThanOrEqual(1);
                    // Coordinates should be finite numbers
                    expect(Number.isFinite(pos.x)).toBe(true);
                    expect(Number.isFinite(pos.y)).toBe(true);
                    expect(Number.isNaN(pos.x)).toBe(false);
                    expect(Number.isNaN(pos.y)).toBe(false);
                });
            });
        });
        test('validates mathematical consistency across layout types', ()=>{
            // Identity elements should be consistently positioned
            const layoutsWithIdentity = [
                _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout(),
                _StandardLayouts.StandardLayoutGenerator.getDihedral3Layout(),
                _StandardLayouts.StandardLayoutGenerator.getDihedral4Layout(),
                _StandardLayouts.StandardLayoutGenerator.getAlternating4Layout()
            ];
            layoutsWithIdentity.forEach((layout)=>{
                const identityPos = layout.positions.e;
                expect(identityPos).toBeDefined();
                // Identity should be roughly centered
                expect(identityPos.x).toBeCloseTo(0.5, 1);
                expect(identityPos.y).toBeCloseTo(0.5, 1);
            });
        });
        test('validates layout properties satisfy group theory constraints', ()=>{
            // V4 should have 4 elements in square-like arrangement
            const v4 = _StandardLayouts.StandardLayoutGenerator.getKleinFourLayout();
            expect(Object.keys(v4.positions)).toHaveLength(4);
            // Q8 should have 8 elements with quaternion structure
            const q8 = _StandardLayouts.StandardLayoutGenerator.getQuaternionLayout();
            expect(Object.keys(q8.positions)).toHaveLength(8);
            // Cyclic groups should have n elements in circular arrangement
            for(let n = 3; n <= 8; n++){
                const cn = _StandardLayouts.StandardLayoutGenerator.getCyclicLayout(n);
                expect(Object.keys(cn.positions)).toHaveLength(n);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3N0ZXBoZW4tZG9ybWFuL2Rldi96a3RoZW9yeS9zcmMvX190ZXN0c19fL2xpYi9TdGFuZGFyZExheW91dHMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbXByZWhlbnNpdmUgSmVzdCBVbml0IFRlc3RzIGZvciBTdGFuZGFyZExheW91dHNcbiAqIFRlc3RzIG1hdGhlbWF0aWNhbCBhY2N1cmFjeSwgZ2VvbWV0cmljIHByb3BlcnRpZXMsIGFuZCBsYXlvdXQgZ2VuZXJhdGlvbiBhbGdvcml0aG1zXG4gKi9cblxuaW1wb3J0IHsgXG4gIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLFxuICBTdGFuZGFyZExheW91dCxcbiAgTGF5b3V0UG9zaXRpb24gXG59IGZyb20gJ0AvbGliL1N0YW5kYXJkTGF5b3V0cyc7XG5pbXBvcnQgeyBHcm91cERhdGFiYXNlIH0gZnJvbSAnQC9saWIvR3JvdXBEYXRhYmFzZSc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0AvbGliL0dyb3VwVGhlb3J5JztcbmltcG9ydCB7IFxuICBtYXRoZW1hdGljYWxNYXRjaGVycyxcbiAgTUFUSEVNQVRJQ0FMX1BSRUNJU0lPTixcbiAgUHJlY2lzaW9uVmFsaWRhdG9yLFxuICBhZ2dyZWdhdGVWYWxpZGF0aW9uUmVzdWx0c1xufSBmcm9tICcuLi91dGlscy9tYXRoZW1hdGljYWxWYWxpZGF0aW9uJztcblxuLy8gRXh0ZW5kIEplc3QgbWF0Y2hlcnNcbmV4cGVjdC5leHRlbmQobWF0aGVtYXRpY2FsTWF0Y2hlcnMpO1xuXG5kZXNjcmliZSgnU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3InLCAoKSA9PiB7XG4gIFxuICBkZXNjcmliZSgnS2xlaW4gRm91ciBHcm91cCBMYXlvdXQgKFY0KScsICgpID0+IHtcbiAgICBsZXQgbGF5b3V0OiBTdGFuZGFyZExheW91dDtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbGF5b3V0ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0S2xlaW5Gb3VyTGF5b3V0KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdnZW5lcmF0ZXMgY29ycmVjdCBWNCBncm91cCBzdHJ1Y3R1cmUnLCAoKSA9PiB7XG4gICAgICBleHBlY3QobGF5b3V0KS50b0hhdmVQcm9wZXJ0eSgncG9zaXRpb25zJyk7XG4gICAgICBleHBlY3QobGF5b3V0KS50b0hhdmVQcm9wZXJ0eSgnZGVzY3JpcHRpb24nKTtcbiAgICAgIGV4cGVjdChsYXlvdXQpLnRvSGF2ZVByb3BlcnR5KCdnZW5lcmF0b3JzJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChsYXlvdXQuZGVzY3JpcHRpb24pLnRvQmUoXCJLbGVpbiBGb3VyIEdyb3VwIC0gU3F1YXJlIGFycmFuZ2VtZW50XCIpO1xuICAgICAgZXhwZWN0KGxheW91dC5nZW5lcmF0b3JzKS50b0VxdWFsKFsnYScsICdiJ10pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmFsaWRhdGVzIFY0IGVsZW1lbnQgcG9zaXRpb25pbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9ucyB9ID0gbGF5b3V0O1xuICAgICAgXG4gICAgICAvLyBDaGVjayBhbGwgcmVxdWlyZWQgZWxlbWVudHMgcHJlc2VudFxuICAgICAgZXhwZWN0KHBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoJ2UnKTsgLy8gSWRlbnRpdHlcbiAgICAgIGV4cGVjdChwb3NpdGlvbnMpLnRvSGF2ZVByb3BlcnR5KCdhJyk7IC8vIEZpcnN0IGdlbmVyYXRvclxuICAgICAgZXhwZWN0KHBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoJ2InKTsgLy8gU2Vjb25kIGdlbmVyYXRvclxuICAgICAgZXhwZWN0KHBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoJ2MnKTsgLy8gUHJvZHVjdCBhYlxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBjb29yZGluYXRlIHJhbmdlcyBbMCwgMV1cbiAgICAgIE9iamVjdC52YWx1ZXMocG9zaXRpb25zKS5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICAgIGV4cGVjdChwb3MueCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgZXhwZWN0KHBvcy54KS50b0JlTGVzc1RoYW5PckVxdWFsKDEpO1xuICAgICAgICBleHBlY3QocG9zLnkpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgIGV4cGVjdChwb3MueSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShwb3MueCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUocG9zLnkpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2ZXJpZmllcyBWNCBnZW9tZXRyaWMgcHJvcGVydGllcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICBcbiAgICAgIC8vIElkZW50aXR5IHNob3VsZCBiZSBhdCBjZW50ZXJcbiAgICAgIGV4cGVjdChwb3NpdGlvbnMuZS54KS50b0JlQ2xvc2VUbygwLjUsIDUpO1xuICAgICAgZXhwZWN0KHBvc2l0aW9ucy5lLnkpLnRvQmVDbG9zZVRvKDAuNSwgNSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSByZWN0YW5ndWxhciBhcnJhbmdlbWVudCBjb25zdHJhaW50c1xuICAgICAgZXhwZWN0KHBvc2l0aW9ucy5hLngpLnRvQmVMZXNzVGhhbihwb3NpdGlvbnMuZS54KTsgLy8gTGVmdCBvZiBjZW50ZXJcbiAgICAgIGV4cGVjdChwb3NpdGlvbnMuYi54KS50b0JlR3JlYXRlclRoYW4ocG9zaXRpb25zLmUueCk7IC8vIFJpZ2h0IG9mIGNlbnRlclxuICAgICAgZXhwZWN0KHBvc2l0aW9ucy5jLnkpLnRvQmVMZXNzVGhhbihwb3NpdGlvbnMuZS55KTsgLy8gQWJvdmUgY2VudGVyXG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2YWxpZGF0ZXMgc3ltbWV0cnkgcHJvcGVydGllcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZXMgZnJvbSBjZW50ZXJcbiAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IHtcbiAgICAgICAgYTogTWF0aC5zcXJ0KChwb3NpdGlvbnMuYS54IC0gMC41KSAqKiAyICsgKHBvc2l0aW9ucy5hLnkgLSAwLjUpICoqIDIpLFxuICAgICAgICBiOiBNYXRoLnNxcnQoKHBvc2l0aW9ucy5iLnggLSAwLjUpICoqIDIgKyAocG9zaXRpb25zLmIueSAtIDAuNSkgKiogMiksXG4gICAgICAgIGM6IE1hdGguc3FydCgocG9zaXRpb25zLmMueCAtIDAuNSkgKiogMiArIChwb3NpdGlvbnMuYy55IC0gMC41KSAqKiAyKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTm9uLWlkZW50aXR5IGVsZW1lbnRzIHNob3VsZCBiZSBlcXVpZGlzdGFudCBmcm9tIGNlbnRlclxuICAgICAgZXhwZWN0KGRpc3RhbmNlcy5hKS50b0JlQ2xvc2VUbyhkaXN0YW5jZXMuYiwgNSk7XG4gICAgICBleHBlY3QoZGlzdGFuY2VzLmEpLnRvQmVDbG9zZVRvKGRpc3RhbmNlcy5jLCA1KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2Vuc3VyZXMgdW5pcXVlIHBvc2l0aW9uaW5nJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbnMgfSA9IGxheW91dDtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IE9iamVjdC52YWx1ZXMocG9zaXRpb25zKS5tYXAocCA9PiBgJHtwLnh9LCR7cC55fWApO1xuICAgICAgY29uc3QgdW5pcXVlQ29vcmRzID0gbmV3IFNldChjb29yZHMpO1xuICAgICAgXG4gICAgICBleHBlY3QodW5pcXVlQ29vcmRzLnNpemUpLnRvQmUoY29vcmRzLmxlbmd0aCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdRdWF0ZXJuaW9uIEdyb3VwIExheW91dCAoUTgpJywgKCkgPT4ge1xuICAgIGxldCBsYXlvdXQ6IFN0YW5kYXJkTGF5b3V0O1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBsYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRRdWF0ZXJuaW9uTGF5b3V0KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdnZW5lcmF0ZXMgY29ycmVjdCBROCBncm91cCBzdHJ1Y3R1cmUnLCAoKSA9PiB7XG4gICAgICBleHBlY3QobGF5b3V0LmRlc2NyaXB0aW9uKS50b0JlKFwiUXVhdGVybmlvbiBHcm91cCBROCAtIEN1YmUgcHJvamVjdGlvblwiKTtcbiAgICAgIGV4cGVjdChsYXlvdXQuZ2VuZXJhdG9ycykudG9FcXVhbChbJ2knLCAnaiddKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhdmUgOCBlbGVtZW50c1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGxheW91dC5wb3NpdGlvbnMpKS50b0hhdmVMZW5ndGgoOCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2YWxpZGF0ZXMgUTggZWxlbWVudCBwb3NpdGlvbmluZycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICBjb25zdCBleHBlY3RlZEVsZW1lbnRzID0gWycxJywgJy0xJywgJ2knLCAnLWknLCAnaicsICctaicsICdrJywgJy1rJ107XG4gICAgICBcbiAgICAgIGV4cGVjdGVkRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgZXhwZWN0KHBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoZWxlbWVudCk7XG4gICAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUocG9zaXRpb25zW2VsZW1lbnRdLngpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvc2l0aW9uc1tlbGVtZW50XS55KSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmVyaWZpZXMgUTggcXVhdGVybmlvbiBwYWlyaW5nIHByb3BlcnRpZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9ucyB9ID0gbGF5b3V0O1xuICAgICAgXG4gICAgICAvLyBRdWF0ZXJuaW9uIG9wcG9zaXRlcyBzaG91bGQgaGF2ZSBzcGVjaWZpYyBnZW9tZXRyaWMgcmVsYXRpb25zaGlwc1xuICAgICAgY29uc3QgcGFpcnMgPSBbXG4gICAgICAgIFsnMScsICctMSddLCBbJ2knLCAnLWknXSwgWydqJywgJy1qJ10sIFsnaycsICctayddXG4gICAgICBdO1xuICAgICAgXG4gICAgICBwYWlycy5mb3JFYWNoKChbcG9zLCBuZWddKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgIChwb3NpdGlvbnNbcG9zXS54IC0gcG9zaXRpb25zW25lZ10ueCkgKiogMiArIFxuICAgICAgICAgIChwb3NpdGlvbnNbcG9zXS55IC0gcG9zaXRpb25zW25lZ10ueSkgKiogMlxuICAgICAgICApO1xuICAgICAgICBleHBlY3QoZGlzdGFuY2UpLnRvQmVHcmVhdGVyVGhhbigwLjEpOyAvLyBTaG91bGQgYmUgc2VwYXJhdGVkXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3ZhbGlkYXRlcyBjdWJlIHByb2plY3Rpb24gZ2VvbWV0cnknLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9ucyB9ID0gbGF5b3V0O1xuICAgICAgXG4gICAgICAvLyBJZGVudGl0eSBhdCBjZW50ZXJcbiAgICAgIGV4cGVjdChwb3NpdGlvbnNbJzEnXS54KS50b0JlQ2xvc2VUbygwLjUsIDUpO1xuICAgICAgZXhwZWN0KHBvc2l0aW9uc1snMSddLnkpLnRvQmVDbG9zZVRvKDAuNSwgNSk7XG4gICAgICBcbiAgICAgIC8vIEFsbCBwb3NpdGlvbnMgc2hvdWxkIGJlIGluIFswLDFdIMOXIFswLDFdXG4gICAgICBPYmplY3QudmFsdWVzKHBvc2l0aW9ucykuZm9yRWFjaChwb3MgPT4ge1xuICAgICAgICBleHBlY3QocG9zLngpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgIGV4cGVjdChwb3MueCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgICAgZXhwZWN0KHBvcy55KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgICBleHBlY3QocG9zLnkpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2Vuc3VyZXMgbWF0aGVtYXRpY2FsIGNvbnNpc3RlbmN5IHdpdGggcXVhdGVybmlvbiByZWxhdGlvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9ucyB9ID0gbGF5b3V0O1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZ2VuZXJhdG9ycyBhcmUgcHJlc2VudCBhbmQgcG9zaXRpb25lZFxuICAgICAgZXhwZWN0KHBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoJ2knKTtcbiAgICAgIGV4cGVjdChwb3NpdGlvbnMpLnRvSGF2ZVByb3BlcnR5KCdqJyk7XG4gICAgICBleHBlY3QocG9zaXRpb25zKS50b0hhdmVQcm9wZXJ0eSgnaycpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGksIGosIGsgYXJlIGRpc3RyaWJ1dGVkIGFyb3VuZCB0aGUgbGF5b3V0XG4gICAgICBjb25zdCBpUG9zID0gcG9zaXRpb25zWydpJ107XG4gICAgICBjb25zdCBqUG9zID0gcG9zaXRpb25zWydqJ107XG4gICAgICBjb25zdCBrUG9zID0gcG9zaXRpb25zWydrJ107XG4gICAgICBcbiAgICAgIC8vIFRoZXkgc2hvdWxkIGZvcm0gYSBub24tZGVnZW5lcmF0ZSB0cmlhbmdsZVxuICAgICAgY29uc3QgYXJlYSA9IE1hdGguYWJzKFxuICAgICAgICAoaVBvcy54ICogKGpQb3MueSAtIGtQb3MueSkgKyBcbiAgICAgICAgIGpQb3MueCAqIChrUG9zLnkgLSBpUG9zLnkpICsgXG4gICAgICAgICBrUG9zLnggKiAoaVBvcy55IC0galBvcy55KSkgLyAyXG4gICAgICApO1xuICAgICAgZXhwZWN0KGFyZWEpLnRvQmVHcmVhdGVyVGhhbigwLjAxKTsgLy8gTm9uLXplcm8gYXJlYVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGloZWRyYWwgR3JvdXAgTGF5b3V0cycsICgpID0+IHtcbiAgICBcbiAgICBkZXNjcmliZSgnRGloZWRyYWwgRDMgKFMzKSBMYXlvdXQnLCAoKSA9PiB7XG4gICAgICBsZXQgbGF5b3V0OiBTdGFuZGFyZExheW91dDtcblxuICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldERpaGVkcmFsM0xheW91dCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2dlbmVyYXRlcyBjb3JyZWN0IEQzIGdyb3VwIHN0cnVjdHVyZScsICgpID0+IHtcbiAgICAgICAgZXhwZWN0KGxheW91dC5kZXNjcmlwdGlvbikudG9CZShcIkRpaGVkcmFsIEQzIChTMykgLSBUcmlhbmd1bGFyIHN5bW1ldHJ5XCIpO1xuICAgICAgICBleHBlY3QobGF5b3V0LmdlbmVyYXRvcnMpLnRvRXF1YWwoWydyJywgJ3MnXSk7XG4gICAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhsYXlvdXQucG9zaXRpb25zKSkudG9IYXZlTGVuZ3RoKDYpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ3ZhbGlkYXRlcyBEMyBlbGVtZW50IHBvc2l0aW9uaW5nJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHBvc2l0aW9ucyB9ID0gbGF5b3V0O1xuICAgICAgICBjb25zdCBleHBlY3RlZEVsZW1lbnRzID0gWydlJywgJ3InLCAncsKyJywgJ3MnLCAnc3InLCAnc3LCsiddO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGV4cGVjdChwb3NpdGlvbnMpLnRvSGF2ZVByb3BlcnR5KGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KCd2ZXJpZmllcyB0cmlhbmd1bGFyIHN5bW1ldHJ5IHByb3BlcnRpZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICAgIFxuICAgICAgICAvLyBJZGVudGl0eSBhdCBjZW50ZXJcbiAgICAgICAgZXhwZWN0KHBvc2l0aW9ucy5lLngpLnRvQmVDbG9zZVRvKDAuNSwgNSk7XG4gICAgICAgIGV4cGVjdChwb3NpdGlvbnMuZS55KS50b0JlQ2xvc2VUbygwLjUsIDUpO1xuICAgICAgICBcbiAgICAgICAgLy8gUm90YXRpb24gZWxlbWVudHMgc2hvdWxkIGZvcm0gYSBwYXR0ZXJuXG4gICAgICAgIGNvbnN0IHJvdGF0aW9ucyA9IFtwb3NpdGlvbnMuciwgcG9zaXRpb25zWydywrInXV07XG4gICAgICAgIHJvdGF0aW9ucy5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKHBvcy54IC0gMC41KSAqKiAyICsgKHBvcy55IC0gMC41KSAqKiAyKTtcbiAgICAgICAgICBleHBlY3QoZGlzdGFuY2UpLnRvQmVHcmVhdGVyVGhhbigwLjEpOyAvLyBBd2F5IGZyb20gY2VudGVyXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ3ZhbGlkYXRlcyByZWZsZWN0aW9uIGFycmFuZ2VtZW50JywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHBvc2l0aW9ucyB9ID0gbGF5b3V0O1xuICAgICAgICBjb25zdCByZWZsZWN0aW9ucyA9IFsncycsICdzcicsICdzcsKyJ107XG4gICAgICAgIFxuICAgICAgICAvLyBSZWZsZWN0aW9ucyBzaG91bGQgYmUgcG9zaXRpb25lZCB0byBzaG93IHRyaWFuZ3VsYXIgc3ltbWV0cnlcbiAgICAgICAgcmVmbGVjdGlvbnMuZm9yRWFjaChyZWZsID0+IHtcbiAgICAgICAgICBleHBlY3QocG9zaXRpb25zW3JlZmxdLngpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgICAgZXhwZWN0KHBvc2l0aW9uc1tyZWZsXS54KS50b0JlTGVzc1RoYW5PckVxdWFsKDEpO1xuICAgICAgICAgIGV4cGVjdChwb3NpdGlvbnNbcmVmbF0ueSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgICBleHBlY3QocG9zaXRpb25zW3JlZmxdLnkpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnRGloZWRyYWwgRDQgTGF5b3V0JywgKCkgPT4ge1xuICAgICAgbGV0IGxheW91dDogU3RhbmRhcmRMYXlvdXQ7XG5cbiAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBsYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXREaWhlZHJhbDRMYXlvdXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KCdnZW5lcmF0ZXMgY29ycmVjdCBENCBncm91cCBzdHJ1Y3R1cmUnLCAoKSA9PiB7XG4gICAgICAgIGV4cGVjdChsYXlvdXQuZGVzY3JpcHRpb24pLnRvQmUoXCJEaWhlZHJhbCBENCAtIFNxdWFyZSBzeW1tZXRyeVwiKTtcbiAgICAgICAgZXhwZWN0KGxheW91dC5nZW5lcmF0b3JzKS50b0VxdWFsKFsncicsICdzJ10pO1xuICAgICAgICBleHBlY3QoT2JqZWN0LmtleXMobGF5b3V0LnBvc2l0aW9ucykpLnRvSGF2ZUxlbmd0aCg4KTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KCd2YWxpZGF0ZXMgRDQgc3F1YXJlIHN5bW1ldHJ5IHByb3BlcnRpZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayByb3RhdGlvbiBlbGVtZW50cyBmb3JtIGEgc3F1YXJlIHBhdHRlcm5cbiAgICAgICAgY29uc3Qgcm90YXRpb25zID0gW3Bvc2l0aW9ucy5yLCBwb3NpdGlvbnNbJ3LCsiddLCBwb3NpdGlvbnNbJ3LCsyddXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gcG9zaXRpb25zLmU7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2VzIGZyb20gY2VudGVyIGZvciByb3RhdGlvbnNcbiAgICAgICAgY29uc3QgZGlzdGFuY2VzID0gcm90YXRpb25zLm1hcChwb3MgPT4gXG4gICAgICAgICAgTWF0aC5zcXJ0KChwb3MueCAtIGNlbnRlci54KSAqKiAyICsgKHBvcy55IC0gY2VudGVyLnkpICoqIDIpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbGwgcm90YXRpb25zIHNob3VsZCBiZSBlcXVpZGlzdGFudCBmcm9tIGNlbnRlclxuICAgICAgICBleHBlY3QoZGlzdGFuY2VzWzBdKS50b0JlQ2xvc2VUbyhkaXN0YW5jZXNbMV0sIDUpO1xuICAgICAgICBleHBlY3QoZGlzdGFuY2VzWzBdKS50b0JlQ2xvc2VUbyhkaXN0YW5jZXNbMl0sIDUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ3ZlcmlmaWVzIHNxdWFyZSBnZW9tZXRyaWMgY29uc3RyYWludHMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayB0aGF0IHJvdGF0aW9ucyBhcHByb3hpbWF0ZSBhIHNxdWFyZSBhcnJhbmdlbWVudFxuICAgICAgICBjb25zdCByID0gcG9zaXRpb25zLnI7XG4gICAgICAgIGNvbnN0IHIyID0gcG9zaXRpb25zWydywrInXTtcbiAgICAgICAgY29uc3QgcjMgPSBwb3NpdGlvbnNbJ3LCsyddO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRqYWNlbnQgcm90YXRpb25zIHNob3VsZCBiZSByb3VnaGx5IGVxdWlkaXN0YW50XG4gICAgICAgIGNvbnN0IGQxID0gTWF0aC5zcXJ0KChyLnggLSByMi54KSAqKiAyICsgKHIueSAtIHIyLnkpICoqIDIpO1xuICAgICAgICBjb25zdCBkMiA9IE1hdGguc3FydCgocjIueCAtIHIzLngpICoqIDIgKyAocjIueSAtIHIzLnkpICoqIDIpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KE1hdGguYWJzKGQxIC0gZDIpKS50b0JlTGVzc1RoYW4oMC4xKTsgLy8gU2ltaWxhciBkaXN0YW5jZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ3ljbGljIEdyb3VwIENpcmN1bGFyIExheW91dHMnLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdC5lYWNoKFszLCA0LCA1LCA2LCA4LCAxMl0pKCdnZW5lcmF0ZXMgdmFsaWQgQyVkIGNpcmN1bGFyIGxheW91dCcsIChuKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRDeWNsaWNMYXlvdXQobik7XG4gICAgICBcbiAgICAgIGV4cGVjdChsYXlvdXQuZGVzY3JpcHRpb24pLnRvQmUoYEN5Y2xpYyBDJHtufSAtIENpcmN1bGFyIGFycmFuZ2VtZW50YCk7XG4gICAgICBleHBlY3QobGF5b3V0LmdlbmVyYXRvcnMpLnRvRXF1YWwoWycxJ10pO1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGxheW91dC5wb3NpdGlvbnMpKS50b0hhdmVMZW5ndGgobik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2YWxpZGF0ZXMgY2lyY3VsYXIgcG9zaXRpb25pbmcgbWF0aGVtYXRpY3MgZm9yIEM2JywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0Q3ljbGljTGF5b3V0KDYpO1xuICAgICAgY29uc3QgeyBwb3NpdGlvbnMgfSA9IGxheW91dDtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgYWxsIHBvc2l0aW9ucyBhcmUgb24gYSBjaXJjbGVcbiAgICAgIGNvbnN0IHJhZGl1cyA9IDAuMzU7IC8vIEZyb20gaW1wbGVtZW50YXRpb25cbiAgICAgIGNvbnN0IGNlbnRlciA9IHsgeDogMC41LCB5OiAwLjUgfTtcbiAgICAgIFxuICAgICAgT2JqZWN0LnZhbHVlcyhwb3NpdGlvbnMpLmZvckVhY2gocG9zID0+IHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKHBvcy54IC0gY2VudGVyLngpICoqIDIgKyAocG9zLnkgLSBjZW50ZXIueSkgKiogMik7XG4gICAgICAgIGV4cGVjdChkaXN0YW5jZSkudG9CZUNsb3NlVG8ocmFkaXVzLCA0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmVyaWZpZXMgYW5ndWxhciBkaXN0cmlidXRpb24gZm9yIGN5Y2xpYyBncm91cHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gODtcbiAgICAgIGNvbnN0IGxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEN5Y2xpY0xheW91dChuKTtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBhbmdsZXMgZm9yIGVhY2ggcG9zaXRpb25cbiAgICAgIGNvbnN0IGNlbnRlciA9IHsgeDogMC41LCB5OiAwLjUgfTtcbiAgICAgIGNvbnN0IGFuZ2xlcyA9IE9iamVjdC5rZXlzKHBvc2l0aW9ucykuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYSkgLSBwYXJzZUludChiKSkubWFwKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uc1trZXldO1xuICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHBvcy55IC0gY2VudGVyLnksIHBvcy54IC0gY2VudGVyLngpO1xuICAgICAgICAvLyBOb3JtYWxpemUgdG8gWzAsIDLPgF0gYW5kIGFjY291bnQgZm9yIHN0YXJ0aW5nIGZyb20gdG9wICgtz4AvMilcbiAgICAgICAgYW5nbGUgPSAoYW5nbGUgKyBNYXRoLlBJIC8gMiArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSk7XG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBkaXN0cmlidXRpb24gLSBjb25zZWN1dGl2ZSBhbmdsZXMgc2hvdWxkIGJlIGV2ZW5seSBzcGFjZWRcbiAgICAgIGNvbnN0IGV4cGVjdGVkQW5nbGVTdGVwID0gMiAqIE1hdGguUEkgLyBuO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBleHBlY3RlZEFuZ2xlID0gKGV4cGVjdGVkQW5nbGVTdGVwICogaSkgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgICBleHBlY3QoYW5nbGVzW2ldKS50b0JlQ2xvc2VUbyhleHBlY3RlZEFuZ2xlLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgZWRnZSBjYXNlcyBmb3Igc21hbGwgY3ljbGljIGdyb3VwcycsICgpID0+IHtcbiAgICAgIC8vIEMxIC0gc2luZ2xlIGVsZW1lbnRcbiAgICAgIGNvbnN0IGMxID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0Q3ljbGljTGF5b3V0KDEpO1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGMxLnBvc2l0aW9ucykpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgcG9zaXRpb24gaXMgcm91Z2hseSBhdCB0b3AgKGFsbG93aW5nIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24pXG4gICAgICBjb25zdCBwb3MgPSBjMS5wb3NpdGlvbnNbJzAnXTtcbiAgICAgIGV4cGVjdChwb3MueCkudG9CZUNsb3NlVG8oMC41LCA1KTtcbiAgICAgIGV4cGVjdChwb3MueSkudG9CZUNsb3NlVG8oMC4xNSwgNSk7XG4gICAgICBcbiAgICAgIC8vIEMyIC0gdHdvIGVsZW1lbnRzXG4gICAgICBjb25zdCBjMiA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEN5Y2xpY0xheW91dCgyKTtcbiAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhjMi5wb3NpdGlvbnMpKS50b0hhdmVMZW5ndGgoMik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEaXJlY3QgUHJvZHVjdCBMYXlvdXRzJywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QuZWFjaChbXG4gICAgICBbMiwgMl0sIFsyLCAzXSwgWzMsIDNdLCBbMiwgNF0sIFszLCA0XVxuICAgIF0pKCdnZW5lcmF0ZXMgdmFsaWQgQyVkIMOXIEMlZCBncmlkIGxheW91dCcsIChtLCBuKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXREaXJlY3RQcm9kdWN0TGF5b3V0KG0sIG4pO1xuICAgICAgXG4gICAgICBleHBlY3QobGF5b3V0LmRlc2NyaXB0aW9uKS50b0JlKGBEaXJlY3QgUHJvZHVjdCBDJHttfSDDlyBDJHtufSAtIEdyaWQgYXJyYW5nZW1lbnRgKTtcbiAgICAgIGV4cGVjdChsYXlvdXQuZ2VuZXJhdG9ycykudG9FcXVhbChbJygxLDApJywgJygwLDEpJ10pO1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGxheW91dC5wb3NpdGlvbnMpKS50b0hhdmVMZW5ndGgobSAqIG4pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmFsaWRhdGVzIGdyaWQgcG9zaXRpb25pbmcgbWF0aGVtYXRpY3MgZm9yIEMzIMOXIEMyJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0RGlyZWN0UHJvZHVjdExheW91dCgzLCAyKTtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb25zIH0gPSBsYXlvdXQ7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGdyaWQgc3RydWN0dXJlXG4gICAgICBjb25zdCBleHBlY3RlZFBvc2l0aW9ucyA9IFtcbiAgICAgICAgJygwLDApJywgJygwLDEpJywgJygxLDApJywgJygxLDEpJywgJygyLDApJywgJygyLDEpJ1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgZXhwZWN0ZWRQb3NpdGlvbnMuZm9yRWFjaChwb3MgPT4ge1xuICAgICAgICBleHBlY3QocG9zaXRpb25zKS50b0hhdmVQcm9wZXJ0eShwb3MpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBwb3NpdGlvbnMgZm9ybSBhIHByb3BlciBncmlkXG4gICAgICBjb25zdCBtYXJnaW4gPSAwLjE7XG4gICAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IDEgLSAyICogbWFyZ2luO1xuICAgICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gMSAtIDIgKiBtYXJnaW47XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHNvbWUgc3BlY2lmaWMgcG9zaXRpb25zXG4gICAgICBleHBlY3QocG9zaXRpb25zWycoMCwwKSddLngpLnRvQmVDbG9zZVRvKG1hcmdpbiwgNSk7XG4gICAgICBleHBlY3QocG9zaXRpb25zWycoMCwwKSddLnkpLnRvQmVDbG9zZVRvKG1hcmdpbiwgNSk7XG4gICAgICBleHBlY3QocG9zaXRpb25zWycoMiwxKSddLngpLnRvQmVDbG9zZVRvKG1hcmdpbiArIGF2YWlsYWJsZVdpZHRoLCA1KTtcbiAgICAgIGV4cGVjdChwb3NpdGlvbnNbJygyLDEpJ10ueSkudG9CZUNsb3NlVG8obWFyZ2luICsgYXZhaWxhYmxlSGVpZ2h0LCA1KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgZWRnZSBjYXNlIGZvciAxw5duIGFuZCBuw5cxIHByb2R1Y3RzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0MXhuID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0RGlyZWN0UHJvZHVjdExheW91dCgxLCAzKTtcbiAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhsYXlvdXQxeG4ucG9zaXRpb25zKSkudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgXG4gICAgICBjb25zdCBsYXlvdXRueDEgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXREaXJlY3RQcm9kdWN0TGF5b3V0KDMsIDEpO1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGxheW91dG54MS5wb3NpdGlvbnMpKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBbHRlcm5hdGluZyBBNCBMYXlvdXQnLCAoKSA9PiB7XG4gICAgbGV0IGxheW91dDogU3RhbmRhcmRMYXlvdXQ7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEFsdGVybmF0aW5nNExheW91dCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZ2VuZXJhdGVzIGNvcnJlY3QgQTQgZ3JvdXAgc3RydWN0dXJlJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGxheW91dC5kZXNjcmlwdGlvbikudG9CZShcIkFsdGVybmF0aW5nIEE0IC0gVGV0cmFoZWRyYWwgYXJyYW5nZW1lbnRcIik7XG4gICAgICBleHBlY3QobGF5b3V0LmdlbmVyYXRvcnMpLnRvRXF1YWwoWycoMTIzKScsICcoMTIpKDM0KSddKTtcbiAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhsYXlvdXQucG9zaXRpb25zKSkudG9IYXZlTGVuZ3RoKDEyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3ZhbGlkYXRlcyBBNCBlbGVtZW50IHBvc2l0aW9uaW5nJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbnMgfSA9IGxheW91dDtcbiAgICAgIGNvbnN0IGV4cGVjdGVkRWxlbWVudHMgPSBbXG4gICAgICAgICdlJywgJygxMjMpJywgJygxMzIpJywgJygxMjQpJywgJygxNDIpJywgJygxMzQpJywgXG4gICAgICAgICcoMTQzKScsICcoMjM0KScsICcoMjQzKScsICcoMTIpKDM0KScsICcoMTMpKDI0KScsICcoMTQpKDIzKSdcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGV4cGVjdGVkRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgZXhwZWN0KHBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3ZlcmlmaWVzIHRldHJhaGVkcmFsIHN5bW1ldHJ5IHByb3BlcnRpZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9ucyB9ID0gbGF5b3V0O1xuICAgICAgXG4gICAgICAvLyBJZGVudGl0eSBhdCBjZW50ZXJcbiAgICAgIGV4cGVjdChwb3NpdGlvbnMuZS54KS50b0JlQ2xvc2VUbygwLjUsIDUpO1xuICAgICAgZXhwZWN0KHBvc2l0aW9ucy5lLnkpLnRvQmVDbG9zZVRvKDAuNSwgNSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgMy1jeWNsZXMgYW5kIGRvdWJsZSB0cmFuc3Bvc2l0aW9ucyBhcmUgcG9zaXRpb25lZCBhcHByb3ByaWF0ZWx5XG4gICAgICBjb25zdCB0aHJlZUN5Y2xlcyA9IFsnKDEyMyknLCAnKDEzMiknLCAnKDEyNCknLCAnKDE0MiknLCAnKDEzNCknLCAnKDE0MyknLCAnKDIzNCknLCAnKDI0MyknXTtcbiAgICAgIGNvbnN0IGRvdWJsZVRyYW5zcG9zaXRpb25zID0gWycoMTIpKDM0KScsICcoMTMpKDI0KScsICcoMTQpKDIzKSddO1xuICAgICAgXG4gICAgICAvLyBBbGwgcG9zaXRpb25zIHNob3VsZCBiZSB3aXRoaW4gYm91bmRzXG4gICAgICBbLi4udGhyZWVDeWNsZXMsIC4uLmRvdWJsZVRyYW5zcG9zaXRpb25zXS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbZWxlbWVudF07XG4gICAgICAgIGV4cGVjdChwb3MueCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgZXhwZWN0KHBvcy54KS50b0JlTGVzc1RoYW5PckVxdWFsKDEpO1xuICAgICAgICBleHBlY3QocG9zLnkpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgIGV4cGVjdChwb3MueSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnR3JvdXAgVHlwZSBEZXRlY3Rpb24gYW5kIExheW91dCBTZWxlY3Rpb24nLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgncmVjb2duaXplcyBhbmQgZ2VuZXJhdGVzIGNvcnJlY3QgbGF5b3V0cyBmb3Igc3RhbmRhcmQgZ3JvdXBzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgICB7IG5hbWU6ICdDMScsIGV4cGVjdGVkVHlwZTogJ3RyaXZpYWwnIH0sXG4gICAgICAgIHsgbmFtZTogJ1Y0JywgZXhwZWN0ZWRUeXBlOiAna2xlaW4nIH0sXG4gICAgICAgIHsgbmFtZTogJ0tsZWluNCcsIGV4cGVjdGVkVHlwZTogJ2tsZWluJyB9LFxuICAgICAgICB7IG5hbWU6ICdROCcsIGV4cGVjdGVkVHlwZTogJ3F1YXRlcm5pb24nIH0sXG4gICAgICAgIHsgbmFtZTogJ1E0JywgZXhwZWN0ZWRUeXBlOiAncXVhdGVybmlvbicgfSxcbiAgICAgICAgeyBuYW1lOiAnRDMnLCBleHBlY3RlZFR5cGU6ICdkaWhlZHJhbDMnIH0sXG4gICAgICAgIHsgbmFtZTogJ1MzJywgZXhwZWN0ZWRUeXBlOiAnZGloZWRyYWwzJyB9LFxuICAgICAgICB7IG5hbWU6ICdENCcsIGV4cGVjdGVkVHlwZTogJ2RpaGVkcmFsNCcgfSxcbiAgICAgICAgeyBuYW1lOiAnQTQnLCBleHBlY3RlZFR5cGU6ICdhbHRlcm5hdGluZzQnIH1cbiAgICAgIF07XG4gICAgICBcbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKCh7IG5hbWUsIGV4cGVjdGVkVHlwZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFN0YW5kYXJkTGF5b3V0KG5hbWUsIDApO1xuICAgICAgICBleHBlY3QobGF5b3V0KS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgZXhwZWN0KGxheW91dD8ucG9zaXRpb25zKS50b0JlRGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGN5Y2xpYyBncm91cCBwYXR0ZXJuIG1hdGNoaW5nJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgbiA9IDI7IG4gPD0gMjA7IG4rKykge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRTdGFuZGFyZExheW91dChgQyR7bn1gLCBuKTtcbiAgICAgICAgZXhwZWN0KGxheW91dCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQ/LmRlc2NyaXB0aW9uKS50b0NvbnRhaW4oYEN5Y2xpYyBDJHtufWApO1xuICAgICAgICBleHBlY3QoT2JqZWN0LmtleXMobGF5b3V0Py5wb3NpdGlvbnMgfHwge30pKS50b0hhdmVMZW5ndGgobik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGRpaGVkcmFsIGdyb3VwIHBhdHRlcm4gbWF0Y2hpbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkMyA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFN0YW5kYXJkTGF5b3V0KCdEMycsIDYpO1xuICAgICAgZXhwZWN0KGQzKS5ub3QudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkMz8uZGVzY3JpcHRpb24pLnRvQ29udGFpbignRDMnKTtcbiAgICAgIFxuICAgICAgY29uc3QgZDQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRTdGFuZGFyZExheW91dCgnRDQnLCA4KTtcbiAgICAgIGV4cGVjdChkNCkubm90LnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZDQ/LmRlc2NyaXB0aW9uKS50b0NvbnRhaW4oJ0Q0Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGRpcmVjdCBwcm9kdWN0IHBhdHRlcm4gbWF0Y2hpbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbJ0MyeEMyJywgJ0MyeEMzJywgJ0MzeEMyJywgJ0MyeEM0J107XG4gICAgICBcbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKGdyb3VwTmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFN0YW5kYXJkTGF5b3V0KGdyb3VwTmFtZSwgMCk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QobGF5b3V0Py5kZXNjcmlwdGlvbikudG9Db250YWluKCdEaXJlY3QgUHJvZHVjdCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdyZXR1cm5zIG51bGwgZm9yIHVua25vd24gZ3JvdXAgcGF0dGVybnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1bmtub3duR3JvdXBzID0gWydJbnZhbGlkR3JvdXAnLCAnWDcnLCAnWjk5JywgJ0NvbXBsZXhHcm91cCddO1xuICAgICAgXG4gICAgICB1bmtub3duR3JvdXBzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFN0YW5kYXJkTGF5b3V0KG5hbWUsIDApO1xuICAgICAgICBleHBlY3QobGF5b3V0KS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGVkZ2UgY2FzZXMgaW4gcGF0dGVybiBtYXRjaGluZycsICgpID0+IHtcbiAgICAgIC8vIFZlcnkgbGFyZ2UgY3ljbGljIGdyb3Vwc1xuICAgICAgY29uc3QgYzUwID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0U3RhbmRhcmRMYXlvdXQoJ0M1MCcsIDUwKTtcbiAgICAgIGV4cGVjdChjNTApLnRvQmVOdWxsKCk7IC8vIFNob3VsZCByZWplY3QgZ3JvdXBzID4gMjBcbiAgICAgIFxuICAgICAgLy8gTWFsZm9ybWVkIG5hbWVzXG4gICAgICBjb25zdCBtYWxmb3JtZWQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRTdGFuZGFyZExheW91dCgnQycsIDApO1xuICAgICAgZXhwZWN0KG1hbGZvcm1lZCkudG9CZU51bGwoKTtcbiAgICAgIFxuICAgICAgY29uc3QgbWFsZm9ybWVkMiA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFN0YW5kYXJkTGF5b3V0KCdDeEMnLCAwKTtcbiAgICAgIGV4cGVjdChtYWxmb3JtZWQyKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTGF5b3V0IFBvc2l0aW9uIENhbGN1bGF0aW9ucycsICgpID0+IHtcbiAgICBcbiAgICB0ZXN0KCd2YWxpZGF0ZXMgbWF0aGVtYXRpY2FsIGFjY3VyYWN5IG9mIGNvb3JkaW5hdGUgZ2VuZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IE1BVEhFTUFUSUNBTF9QUkVDSVNJT04uRkxPQVRfVE9MRVJBTkNFO1xuICAgICAgXG4gICAgICAvLyBUZXN0IGN5Y2xpYyBncm91cCBwb3NpdGlvbnMgdXNpbmcgdHJpZ29ub21ldHJ5XG4gICAgICBjb25zdCBuID0gNjtcbiAgICAgIGNvbnN0IGxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEN5Y2xpY0xheW91dChuKTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IDAuMzU7XG4gICAgICBjb25zdCBjZW50ZXIgPSB7IHg6IDAuNSwgeTogMC41IH07XG4gICAgICBcbiAgICAgIE9iamVjdC5rZXlzKGxheW91dC5wb3NpdGlvbnMpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRBbmdsZSA9ICgyICogTWF0aC5QSSAqIGluZGV4KSAvIG4gLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRYID0gY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyhleHBlY3RlZEFuZ2xlKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRZID0gY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbihleHBlY3RlZEFuZ2xlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFjdHVhbCA9IGxheW91dC5wb3NpdGlvbnNba2V5XTtcbiAgICAgICAgZXhwZWN0KE1hdGguYWJzKGFjdHVhbC54IC0gZXhwZWN0ZWRYKSkudG9CZUxlc3NUaGFuKHRvbGVyYW5jZSk7XG4gICAgICAgIGV4cGVjdChNYXRoLmFicyhhY3R1YWwueSAtIGV4cGVjdGVkWSkpLnRvQmVMZXNzVGhhbih0b2xlcmFuY2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2ZXJpZmllcyBjb29yZGluYXRlIHByZWNpc2lvbiBhbmQgc3RhYmlsaXR5JywgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBtdWx0aXBsZSBnZW5lcmF0aW9ucyBwcm9kdWNlIGlkZW50aWNhbCByZXN1bHRzXG4gICAgICBjb25zdCBsYXlvdXRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNSB9LCAoKSA9PiBcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0S2xlaW5Gb3VyTGF5b3V0KClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZpcnN0TGF5b3V0ID0gbGF5b3V0c1swXTtcbiAgICAgIGxheW91dHMuc2xpY2UoMSkuZm9yRWFjaChsYXlvdXQgPT4ge1xuICAgICAgICBPYmplY3Qua2V5cyhmaXJzdExheW91dC5wb3NpdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9uc1trZXldLngpLnRvQmUoZmlyc3RMYXlvdXQucG9zaXRpb25zW2tleV0ueCk7XG4gICAgICAgICAgZXhwZWN0KGxheW91dC5wb3NpdGlvbnNba2V5XS55KS50b0JlKGZpcnN0TGF5b3V0LnBvc2l0aW9uc1trZXldLnkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmFsaWRhdGVzIGZsb2F0aW5nIHBvaW50IHN0YWJpbGl0eSBpbiBjYWxjdWxhdGlvbnMnLCAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHdpdGggZWRnZSBjYXNlcyB0aGF0IG1pZ2h0IGNhdXNlIHByZWNpc2lvbiBpc3N1ZXNcbiAgICAgIGNvbnN0IHRlc3RTaXplcyA9IFs3LCAxMSwgMTMsIDE3XTsgLy8gUHJpbWUgbnVtYmVyc1xuICAgICAgXG4gICAgICB0ZXN0U2l6ZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0Q3ljbGljTGF5b3V0KG4pO1xuICAgICAgICBPYmplY3QudmFsdWVzKGxheW91dC5wb3NpdGlvbnMpLmZvckVhY2gocG9zID0+IHtcbiAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvcy54KSkudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvcy55KSkudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzTmFOKHBvcy54KSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KE51bWJlci5pc05hTihwb3MueSkpLnRvQmUoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnR2VvbWV0cmljIFByb3BlcnRpZXMgYW5kIFZpc3VhbCBRdWFsaXR5JywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QoJ3ZhbGlkYXRlcyBzeW1tZXRyeSBwcmVzZXJ2YXRpb24gaW4gbGF5b3V0cycsICgpID0+IHtcbiAgICAgIC8vIFRlc3QgS2xlaW4gRm91ciBHcm91cCBzeW1tZXRyeVxuICAgICAgY29uc3QgdjQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRLbGVpbkZvdXJMYXlvdXQoKTtcbiAgICAgIGNvbnN0IGNlbnRlciA9IHY0LnBvc2l0aW9ucy5lO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgc3ltbWV0cnkgbWVhc3VyZXNcbiAgICAgIGNvbnN0IG5vbklkZW50aXR5RWxlbWVudHMgPSBbJ2EnLCAnYicsICdjJ107XG4gICAgICBjb25zdCBkaXN0YW5jZXMgPSBub25JZGVudGl0eUVsZW1lbnRzLm1hcChlbGVtID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gdjQucG9zaXRpb25zW2VsZW1dO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KChwb3MueCAtIGNlbnRlci54KSAqKiAyICsgKHBvcy55IC0gY2VudGVyLnkpICoqIDIpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHN5bW1ldHJ5OiBhbGwgZGlzdGFuY2VzIHNob3VsZCBiZSBlcXVhbCAod2l0aGluIHRvbGVyYW5jZSlcbiAgICAgIGNvbnN0IGF2Z0Rpc3RhbmNlID0gZGlzdGFuY2VzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gZGlzdGFuY2VzLmxlbmd0aDtcbiAgICAgIGRpc3RhbmNlcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICBleHBlY3QoTWF0aC5hYnMoZCAtIGF2Z0Rpc3RhbmNlKSkudG9CZUxlc3NUaGFuKDAuMDEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2YWxpZGF0ZXMgdmlzdWFsIGJhbGFuY2UgYW5kIHNwYWNpbmcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXRzID0gW1xuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRLbGVpbkZvdXJMYXlvdXQoKSxcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0UXVhdGVybmlvbkxheW91dCgpLFxuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXREaWhlZHJhbDNMYXlvdXQoKSxcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0Q3ljbGljTGF5b3V0KDgpXG4gICAgICBdO1xuICAgICAgXG4gICAgICBsYXlvdXRzLmZvckVhY2gobGF5b3V0ID0+IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gT2JqZWN0LnZhbHVlcyhsYXlvdXQucG9zaXRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIG1pbmltdW0gc3BhY2luZyBiZXR3ZWVuIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gcG9zaXRpb25zLnJlZHVjZSgobWluLCBwb3MxKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoKG1pbklubmVyLCBwb3MyKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zMSA9PT0gcG9zMikgcmV0dXJuIG1pbklubmVyO1xuICAgICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydCgocG9zMS54IC0gcG9zMi54KSAqKiAyICsgKHBvczEueSAtIHBvczIueSkgKiogMik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4obWluSW5uZXIsIGRpc3QpO1xuICAgICAgICAgIH0sIG1pbik7XG4gICAgICAgIH0sIEluZmluaXR5KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChtaW5EaXN0YW5jZSkudG9CZUdyZWF0ZXJUaGFuKDAuMDUpOyAvLyBNaW5pbXVtIHNwYWNpbmdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmFsaWRhdGVzIGJvdW5kaW5nIGJveCB1dGlsaXphdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dHMgPSBbXG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFF1YXRlcm5pb25MYXlvdXQoKSxcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0RGloZWRyYWw0TGF5b3V0KCksXG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEFsdGVybmF0aW5nNExheW91dCgpXG4gICAgICBdO1xuICAgICAgXG4gICAgICBsYXlvdXRzLmZvckVhY2gobGF5b3V0ID0+IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gT2JqZWN0LnZhbHVlcyhsYXlvdXQucG9zaXRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBib3VuZGluZyBib3hcbiAgICAgICAgY29uc3QgbWluWCA9IE1hdGgubWluKC4uLnBvc2l0aW9ucy5tYXAocCA9PiBwLngpKTtcbiAgICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KC4uLnBvc2l0aW9ucy5tYXAocCA9PiBwLngpKTtcbiAgICAgICAgY29uc3QgbWluWSA9IE1hdGgubWluKC4uLnBvc2l0aW9ucy5tYXAocCA9PiBwLnkpKTtcbiAgICAgICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KC4uLnBvc2l0aW9ucy5tYXAocCA9PiBwLnkpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCB1c2UgcmVhc29uYWJsZSBwb3J0aW9uIG9mIFswLDFdIMOXIFswLDFdIHNwYWNlXG4gICAgICAgIGNvbnN0IHhSYW5nZSA9IG1heFggLSBtaW5YO1xuICAgICAgICBjb25zdCB5UmFuZ2UgPSBtYXhZIC0gbWluWTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdCh4UmFuZ2UpLnRvQmVHcmVhdGVyVGhhbigwLjEpOyAvLyBOb3QgdG9vIGNvbXByZXNzZWRcbiAgICAgICAgZXhwZWN0KHlSYW5nZSkudG9CZUdyZWF0ZXJUaGFuKDAuMSk7XG4gICAgICAgIGV4cGVjdCh4UmFuZ2UpLnRvQmVMZXNzVGhhbigxLjApOyAvLyBXaXRoaW4gYm91bmRzXG4gICAgICAgIGV4cGVjdCh5UmFuZ2UpLnRvQmVMZXNzVGhhbigxLjApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFZGdlIENhc2VzIGFuZCBFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBcbiAgICB0ZXN0KCdoYW5kbGVzIG1hbGZvcm1lZCBncm91cCBuYW1lcyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsZm9ybWVkTmFtZXMgPSBbXG4gICAgICAgICcnLCAnICAgJywgJ0MnLCAnRCcsICdDeEMnLCAnQzJ4JywgJ3hDMycsICdDLTEnLCAnRDAnXG4gICAgICBdO1xuICAgICAgXG4gICAgICBtYWxmb3JtZWROYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRTdGFuZGFyZExheW91dChuYW1lLCAwKTtcbiAgICAgICAgZXhwZWN0KGxheW91dCkudG9CZU51bGwoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBib3VuZGFyeSBjb25kaXRpb25zIGZvciBjeWNsaWMgZ3JvdXBzJywgKCkgPT4ge1xuICAgICAgLy8gVmVyeSBzbWFsbCBncm91cHNcbiAgICAgIGNvbnN0IGMxID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0Q3ljbGljTGF5b3V0KDEpO1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGMxLnBvc2l0aW9ucykpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIFxuICAgICAgLy8gR3JvdXBzIGF0IHRoZSBib3VuZGFyeVxuICAgICAgY29uc3QgYzIwID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0Q3ljbGljTGF5b3V0KDIwKTtcbiAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhjMjAucG9zaXRpb25zKSkudG9IYXZlTGVuZ3RoKDIwKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHBvc2l0aW9ucyBhcmUgc3RpbGwgdmFsaWRcbiAgICAgIE9iamVjdC52YWx1ZXMoYzIwLnBvc2l0aW9ucykuZm9yRWFjaChwb3MgPT4ge1xuICAgICAgICBleHBlY3QocG9zLngpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgIGV4cGVjdChwb3MueCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgICAgZXhwZWN0KHBvcy55KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgICBleHBlY3QocG9zLnkpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgZWRnZSBjYXNlcyBpbiBkaXJlY3QgcHJvZHVjdCBsYXlvdXRzJywgKCkgPT4ge1xuICAgICAgLy8gU2luZ2xlIGZhY3RvciBncm91cHNcbiAgICAgIGNvbnN0IGMxeDEgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXREaXJlY3RQcm9kdWN0TGF5b3V0KDEsIDEpO1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGMxeDEucG9zaXRpb25zKSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgbm8gZGl2aXNpb24gYnkgemVybyBvciBpbnZhbGlkIGNvb3JkaW5hdGVzXG4gICAgICBPYmplY3QudmFsdWVzKGMxeDEucG9zaXRpb25zKS5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUocG9zLngpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvcy55KSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmFsaWRhdGVzIHVua25vd24gZ3JvdXAgdHlwZXMgcmV0dXJuIG51bGwnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1bmtub3duVHlwZXMgPSBbXG4gICAgICAgICdQU0woMiw3KScsICdHTCgyLDMpJywgJ1F1YXRlcm5pb24xNicsICdEaWN5Y2xpY0Q4JywgJ0FsdGVybmF0aW5nQTUnXG4gICAgICBdO1xuICAgICAgXG4gICAgICB1bmtub3duVHlwZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0U3RhbmRhcmRMYXlvdXQobmFtZSwgMCk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVncmF0aW9uIHdpdGggR3JvdXAgVGhlb3J5JywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QoJ3ZhbGlkYXRlcyBsYXlvdXRzIG1hdGNoIGFjdHVhbCBncm91cCBzdHJ1Y3R1cmVzIGZyb20gR3JvdXBEYXRhYmFzZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RHcm91cHMgPSBbJ0MzJywgJ0M0JywgJ1Y0JywgJ1MzJ107XG4gICAgICBcbiAgICAgIHRlc3RHcm91cHMuZm9yRWFjaChncm91cE5hbWUgPT4ge1xuICAgICAgICBjb25zdCBncm91cCA9IEdyb3VwRGF0YWJhc2UuZ2V0R3JvdXAoZ3JvdXBOYW1lKTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0U3RhbmRhcmRMYXlvdXQoZ3JvdXBOYW1lLCBncm91cD8ub3JkZXIgfHwgMCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZ3JvdXAgJiYgbGF5b3V0KSB7XG4gICAgICAgICAgLy8gTGF5b3V0IHNob3VsZCBoYXZlIHBvc2l0aW9uIGZvciBlYWNoIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICBleHBlY3QoT2JqZWN0LmtleXMobGF5b3V0LnBvc2l0aW9ucykubGVuZ3RoKS50b0JlTGVzc1RoYW5PckVxdWFsKGdyb3VwLm9yZGVyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZW5lcmF0b3JzIHNob3VsZCBleGlzdCBpbiBncm91cFxuICAgICAgICAgIGxheW91dC5nZW5lcmF0b3JzPy5mb3JFYWNoKGdlbiA9PiB7XG4gICAgICAgICAgICBpZiAoZ2VuICE9PSAnMScpIHsgLy8gU2tpcCBnZW5lcmljIGdlbmVyYXRvciBub3RhdGlvblxuICAgICAgICAgICAgICBjb25zdCBoYXNFbGVtZW50ID0gZ3JvdXAuZWxlbWVudHMuc29tZShlbGVtID0+IFxuICAgICAgICAgICAgICAgIGVsZW0uaWQgPT09IGdlbiB8fCBlbGVtLmxhYmVsID09PSBnZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbmZvcm1hdGlvbmFsIC0gbGF5b3V0cyBtYXkgdXNlIGRpZmZlcmVudCBub3RhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3ZlcmlmaWVzIGdlbmVyYXRvciBjb25zaXN0ZW5jeSBiZXR3ZWVuIGxheW91dHMgYW5kIGdyb3VwIHRoZW9yeScsICgpID0+IHtcbiAgICAgIC8vIFRlc3QgdGhhdCBsYXlvdXQgZ2VuZXJhdG9ycyBtYWtlIG1hdGhlbWF0aWNhbCBzZW5zZVxuICAgICAgY29uc3QgdjRMYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRLbGVpbkZvdXJMYXlvdXQoKTtcbiAgICAgIGV4cGVjdCh2NExheW91dC5nZW5lcmF0b3JzKS50b0hhdmVMZW5ndGgoMik7IC8vIFY0IG5lZWRzIDIgZ2VuZXJhdG9yc1xuICAgICAgXG4gICAgICBjb25zdCBjNUxheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEN5Y2xpY0xheW91dCg1KTtcbiAgICAgIGV4cGVjdChjNUxheW91dC5nZW5lcmF0b3JzKS50b0hhdmVMZW5ndGgoMSk7IC8vIEN5Y2xpYyBncm91cHMgbmVlZCAxIGdlbmVyYXRvclxuICAgICAgXG4gICAgICBjb25zdCBkM0xheW91dCA9IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldERpaGVkcmFsM0xheW91dCgpO1xuICAgICAgZXhwZWN0KGQzTGF5b3V0LmdlbmVyYXRvcnMpLnRvSGF2ZUxlbmd0aCgyKTsgLy8gRGloZWRyYWwgZ3JvdXBzIG5lZWQgMiBnZW5lcmF0b3JzXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBhbmQgU2NhbGFiaWxpdHknLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgnZ2VuZXJhdGVzIGxheW91dHMgZWZmaWNpZW50bHkgZm9yIHZhcmlvdXMgZ3JvdXAgc2l6ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICAgIHsgbmFtZTogJ0M4Jywgb3JkZXI6IDggfSxcbiAgICAgICAgeyBuYW1lOiAnQzEyJywgb3JkZXI6IDEyIH0sXG4gICAgICAgIHsgbmFtZTogJ0Q0Jywgb3JkZXI6IDggfSxcbiAgICAgICAgeyBuYW1lOiAnUTgnLCBvcmRlcjogOCB9XG4gICAgICBdO1xuICAgICAgXG4gICAgICB0ZXN0Q2FzZXMuZm9yRWFjaCgoeyBuYW1lLCBvcmRlciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRTdGFuZGFyZExheW91dChuYW1lLCBvcmRlcik7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTApOyAvLyBTaG91bGQgYmUgZmFzdFxuICAgICAgICBleHBlY3QobGF5b3V0KS5ub3QudG9CZU51bGwoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnaGFuZGxlcyBtZW1vcnkgZWZmaWNpZW50bHkgZm9yIG11bHRpcGxlIGxheW91dCBnZW5lcmF0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDA7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIG1hbnkgbGF5b3V0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRDeWNsaWNMYXlvdXQoOCk7XG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEtsZWluRm91ckxheW91dCgpO1xuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRRdWF0ZXJuaW9uTGF5b3V0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG4gICAgICBcbiAgICAgIC8vIE1lbW9yeSBpbmNyZWFzZSBzaG91bGQgYmUgcmVhc29uYWJsZSAobGVzcyB0aGFuIDVNQilcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDUgKiAxMDI0ICogMTAyNCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2YWxpZGF0ZXMgZGV0ZXJtaW5pc3RpYyBsYXlvdXQgZ2VuZXJhdGlvbicsICgpID0+IHtcbiAgICAgIC8vIFNhbWUgaW5wdXQgc2hvdWxkIGFsd2F5cyBwcm9kdWNlIHNhbWUgb3V0cHV0XG4gICAgICBjb25zdCBsYXlvdXRzMSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgKCkgPT4gXG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldEN5Y2xpY0xheW91dCg2KVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgbGF5b3V0czIgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1IH0sICgpID0+IFxuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRDeWNsaWNMYXlvdXQoNilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGxheW91dHMxLmZvckVhY2goKGxheW91dDEsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxheW91dDIgPSBsYXlvdXRzMltpbmRleF07XG4gICAgICAgIE9iamVjdC5rZXlzKGxheW91dDEucG9zaXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGxheW91dDEucG9zaXRpb25zW2tleV0pLnRvRXF1YWwobGF5b3V0Mi5wb3NpdGlvbnNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNYXRoZW1hdGljYWwgUmlnb3IgYW5kIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgndmFsaWRhdGVzIGNvb3JkaW5hdGUgYm91bmRzIGFuZCBmaW5pdGUgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgYWxsTGF5b3V0cyA9IFtcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0S2xlaW5Gb3VyTGF5b3V0KCksXG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFF1YXRlcm5pb25MYXlvdXQoKSxcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0RGloZWRyYWwzTGF5b3V0KCksXG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldERpaGVkcmFsNExheW91dCgpLFxuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRBbHRlcm5hdGluZzRMYXlvdXQoKSxcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0Q3ljbGljTGF5b3V0KDcpLFxuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXREaXJlY3RQcm9kdWN0TGF5b3V0KDIsIDMpXG4gICAgICBdO1xuICAgICAgXG4gICAgICBhbGxMYXlvdXRzLmZvckVhY2gobGF5b3V0ID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhsYXlvdXQucG9zaXRpb25zKS5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICAgICAgLy8gQ29vcmRpbmF0ZXMgc2hvdWxkIGJlIGluIFswLCAxXVxuICAgICAgICAgIGV4cGVjdChwb3MueCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgICBleHBlY3QocG9zLngpLnRvQmVMZXNzVGhhbk9yRXF1YWwoMSk7XG4gICAgICAgICAgZXhwZWN0KHBvcy55KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgICAgIGV4cGVjdChwb3MueSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDb29yZGluYXRlcyBzaG91bGQgYmUgZmluaXRlIG51bWJlcnNcbiAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvcy54KSkudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvcy55KSkudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzTmFOKHBvcy54KSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KE51bWJlci5pc05hTihwb3MueSkpLnRvQmUoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndmFsaWRhdGVzIG1hdGhlbWF0aWNhbCBjb25zaXN0ZW5jeSBhY3Jvc3MgbGF5b3V0IHR5cGVzJywgKCkgPT4ge1xuICAgICAgLy8gSWRlbnRpdHkgZWxlbWVudHMgc2hvdWxkIGJlIGNvbnNpc3RlbnRseSBwb3NpdGlvbmVkXG4gICAgICBjb25zdCBsYXlvdXRzV2l0aElkZW50aXR5ID0gW1xuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRLbGVpbkZvdXJMYXlvdXQoKSxcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0RGloZWRyYWwzTGF5b3V0KCksXG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldERpaGVkcmFsNExheW91dCgpLFxuICAgICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRBbHRlcm5hdGluZzRMYXlvdXQoKVxuICAgICAgXTtcbiAgICAgIFxuICAgICAgbGF5b3V0c1dpdGhJZGVudGl0eS5mb3JFYWNoKGxheW91dCA9PiB7XG4gICAgICAgIGNvbnN0IGlkZW50aXR5UG9zID0gbGF5b3V0LnBvc2l0aW9ucy5lO1xuICAgICAgICBleHBlY3QoaWRlbnRpdHlQb3MpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZGVudGl0eSBzaG91bGQgYmUgcm91Z2hseSBjZW50ZXJlZFxuICAgICAgICBleHBlY3QoaWRlbnRpdHlQb3MueCkudG9CZUNsb3NlVG8oMC41LCAxKTtcbiAgICAgICAgZXhwZWN0KGlkZW50aXR5UG9zLnkpLnRvQmVDbG9zZVRvKDAuNSwgMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3ZhbGlkYXRlcyBsYXlvdXQgcHJvcGVydGllcyBzYXRpc2Z5IGdyb3VwIHRoZW9yeSBjb25zdHJhaW50cycsICgpID0+IHtcbiAgICAgIC8vIFY0IHNob3VsZCBoYXZlIDQgZWxlbWVudHMgaW4gc3F1YXJlLWxpa2UgYXJyYW5nZW1lbnRcbiAgICAgIGNvbnN0IHY0ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0S2xlaW5Gb3VyTGF5b3V0KCk7XG4gICAgICBleHBlY3QoT2JqZWN0LmtleXModjQucG9zaXRpb25zKSkudG9IYXZlTGVuZ3RoKDQpO1xuICAgICAgXG4gICAgICAvLyBROCBzaG91bGQgaGF2ZSA4IGVsZW1lbnRzIHdpdGggcXVhdGVybmlvbiBzdHJ1Y3R1cmVcbiAgICAgIGNvbnN0IHE4ID0gU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0UXVhdGVybmlvbkxheW91dCgpO1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKHE4LnBvc2l0aW9ucykpLnRvSGF2ZUxlbmd0aCg4KTtcbiAgICAgIFxuICAgICAgLy8gQ3ljbGljIGdyb3VwcyBzaG91bGQgaGF2ZSBuIGVsZW1lbnRzIGluIGNpcmN1bGFyIGFycmFuZ2VtZW50XG4gICAgICBmb3IgKGxldCBuID0gMzsgbiA8PSA4OyBuKyspIHtcbiAgICAgICAgY29uc3QgY24gPSBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRDeWNsaWNMYXlvdXQobik7XG4gICAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhjbi5wb3NpdGlvbnMpKS50b0hhdmVMZW5ndGgobik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImV4cGVjdCIsImV4dGVuZCIsIm1hdGhlbWF0aWNhbE1hdGNoZXJzIiwiZGVzY3JpYmUiLCJsYXlvdXQiLCJiZWZvcmVFYWNoIiwiU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IiLCJnZXRLbGVpbkZvdXJMYXlvdXQiLCJ0ZXN0IiwidG9IYXZlUHJvcGVydHkiLCJkZXNjcmlwdGlvbiIsInRvQmUiLCJnZW5lcmF0b3JzIiwidG9FcXVhbCIsInBvc2l0aW9ucyIsIk9iamVjdCIsInZhbHVlcyIsImZvckVhY2giLCJwb3MiLCJ4IiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJlIiwidG9CZUNsb3NlVG8iLCJhIiwidG9CZUxlc3NUaGFuIiwiYiIsInRvQmVHcmVhdGVyVGhhbiIsImMiLCJkaXN0YW5jZXMiLCJNYXRoIiwic3FydCIsImNvb3JkcyIsIm1hcCIsInAiLCJ1bmlxdWVDb29yZHMiLCJTZXQiLCJzaXplIiwibGVuZ3RoIiwiZ2V0UXVhdGVybmlvbkxheW91dCIsImtleXMiLCJ0b0hhdmVMZW5ndGgiLCJleHBlY3RlZEVsZW1lbnRzIiwiZWxlbWVudCIsInBhaXJzIiwibmVnIiwiZGlzdGFuY2UiLCJpUG9zIiwialBvcyIsImtQb3MiLCJhcmVhIiwiYWJzIiwiZ2V0RGloZWRyYWwzTGF5b3V0Iiwicm90YXRpb25zIiwiciIsInJlZmxlY3Rpb25zIiwicmVmbCIsImdldERpaGVkcmFsNExheW91dCIsImNlbnRlciIsInIyIiwicjMiLCJkMSIsImQyIiwiZWFjaCIsIm4iLCJnZXRDeWNsaWNMYXlvdXQiLCJyYWRpdXMiLCJhbmdsZXMiLCJzb3J0IiwicGFyc2VJbnQiLCJrZXkiLCJhbmdsZSIsImF0YW4yIiwiUEkiLCJleHBlY3RlZEFuZ2xlU3RlcCIsImkiLCJleHBlY3RlZEFuZ2xlIiwiYzEiLCJjMiIsIm0iLCJnZXREaXJlY3RQcm9kdWN0TGF5b3V0IiwiZXhwZWN0ZWRQb3NpdGlvbnMiLCJtYXJnaW4iLCJhdmFpbGFibGVXaWR0aCIsImF2YWlsYWJsZUhlaWdodCIsImxheW91dDF4biIsImxheW91dG54MSIsImdldEFsdGVybmF0aW5nNExheW91dCIsInRocmVlQ3ljbGVzIiwiZG91YmxlVHJhbnNwb3NpdGlvbnMiLCJ0ZXN0Q2FzZXMiLCJuYW1lIiwiZXhwZWN0ZWRUeXBlIiwiZ2V0U3RhbmRhcmRMYXlvdXQiLCJub3QiLCJ0b0JlTnVsbCIsInRvQmVEZWZpbmVkIiwidG9Db250YWluIiwiZDMiLCJkNCIsImdyb3VwTmFtZSIsInVua25vd25Hcm91cHMiLCJjNTAiLCJtYWxmb3JtZWQiLCJtYWxmb3JtZWQyIiwidG9sZXJhbmNlIiwiTUFUSEVNQVRJQ0FMX1BSRUNJU0lPTiIsIkZMT0FUX1RPTEVSQU5DRSIsImluZGV4IiwiZXhwZWN0ZWRYIiwiY29zIiwiZXhwZWN0ZWRZIiwic2luIiwiYWN0dWFsIiwibGF5b3V0cyIsIkFycmF5IiwiZnJvbSIsImZpcnN0TGF5b3V0Iiwic2xpY2UiLCJ0ZXN0U2l6ZXMiLCJpc05hTiIsInY0Iiwibm9uSWRlbnRpdHlFbGVtZW50cyIsImVsZW0iLCJhdmdEaXN0YW5jZSIsInJlZHVjZSIsImQiLCJtaW5EaXN0YW5jZSIsIm1pbiIsInBvczEiLCJtaW5Jbm5lciIsInBvczIiLCJkaXN0IiwiSW5maW5pdHkiLCJtaW5YIiwibWF4WCIsIm1heCIsIm1pblkiLCJtYXhZIiwieFJhbmdlIiwieVJhbmdlIiwibWFsZm9ybWVkTmFtZXMiLCJjMjAiLCJjMXgxIiwidW5rbm93blR5cGVzIiwidGVzdEdyb3VwcyIsImdyb3VwIiwiR3JvdXBEYXRhYmFzZSIsImdldEdyb3VwIiwib3JkZXIiLCJnZW4iLCJoYXNFbGVtZW50IiwiZWxlbWVudHMiLCJzb21lIiwiaWQiLCJsYWJlbCIsInY0TGF5b3V0IiwiYzVMYXlvdXQiLCJkM0xheW91dCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZW5kVGltZSIsImluaXRpYWxNZW1vcnkiLCJtZW1vcnkiLCJ1c2VkSlNIZWFwU2l6ZSIsImZpbmFsTWVtb3J5IiwibWVtb3J5SW5jcmVhc2UiLCJsYXlvdXRzMSIsImxheW91dHMyIiwibGF5b3V0MSIsImxheW91dDIiLCJhbGxMYXlvdXRzIiwibGF5b3V0c1dpdGhJZGVudGl0eSIsImlkZW50aXR5UG9zIiwicTgiLCJjbiJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDOzs7O2lDQU1NOytCQUN1Qjt3Q0FPdkI7QUFFUCx1QkFBdUI7QUFDdkJBLE9BQU9DLE1BQU0sQ0FBQ0MsNENBQW9CO0FBRWxDQyxTQUFTLDJCQUEyQjtJQUVsQ0EsU0FBUyxnQ0FBZ0M7UUFDdkMsSUFBSUM7UUFFSkMsV0FBVztZQUNURCxTQUFTRSx3Q0FBdUIsQ0FBQ0Msa0JBQWtCO1FBQ3JEO1FBRUFDLEtBQUssd0NBQXdDO1lBQzNDUixPQUFPSSxRQUFRSyxjQUFjLENBQUM7WUFDOUJULE9BQU9JLFFBQVFLLGNBQWMsQ0FBQztZQUM5QlQsT0FBT0ksUUFBUUssY0FBYyxDQUFDO1lBRTlCVCxPQUFPSSxPQUFPTSxXQUFXLEVBQUVDLElBQUksQ0FBQztZQUNoQ1gsT0FBT0ksT0FBT1EsVUFBVSxFQUFFQyxPQUFPLENBQUM7Z0JBQUM7Z0JBQUs7YUFBSTtRQUM5QztRQUVBTCxLQUFLLG9DQUFvQztZQUN2QyxNQUFNLEVBQUVNLFNBQVMsRUFBRSxHQUFHVjtZQUV0QixzQ0FBc0M7WUFDdENKLE9BQU9jLFdBQVdMLGNBQWMsQ0FBQyxNQUFNLFdBQVc7WUFDbERULE9BQU9jLFdBQVdMLGNBQWMsQ0FBQyxNQUFNLGtCQUFrQjtZQUN6RFQsT0FBT2MsV0FBV0wsY0FBYyxDQUFDLE1BQU0sbUJBQW1CO1lBQzFEVCxPQUFPYyxXQUFXTCxjQUFjLENBQUMsTUFBTSxhQUFhO1lBRXBELG9DQUFvQztZQUNwQ00sT0FBT0MsTUFBTSxDQUFDRixXQUFXRyxPQUFPLENBQUNDLENBQUFBO2dCQUMvQmxC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