{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/lib/AdvancedLayoutEngine.ts"],"sourcesContent":["// Advanced Layout Engine - Implementing Group Explorer's sophisticated layout strategies\n// This replicates and modernizes the layout algorithms from Group Explorer\n\nimport { Group, GroupElement } from './GroupTheory';\nimport { StandardLayoutGenerator, LayoutPosition } from './StandardLayouts';\n\nexport type LayoutStrategy = 'linear' | 'circular' | 'rotated';\nexport type LayoutDirection = 'X' | 'Y' | 'Z' | 'XY' | 'XZ' | 'YZ';\n\nexport interface LayoutNestingLevel {\n  generator: string;\n  strategy: LayoutStrategy;\n  direction: LayoutDirection;\n  nestingLevel: number;\n  subgroupElements?: string[];\n}\n\nexport interface AdvancedLayout {\n  positions: { [elementId: string]: { x: number, y: number, z?: number } };\n  nestingStructure: LayoutNestingLevel[];\n  description: string;\n  is3D: boolean;\n}\n\nexport class AdvancedLayoutEngine {\n  \n  /**\n   * Main entry point - generates optimal layout for any group\n   * Replicates Group Explorer's CayleyGeneratorFromStrategy logic\n   */\n  static generateOptimalLayout(\n    group: Group, \n    generators: string[], \n    prefer3D: boolean = false\n  ): AdvancedLayout {\n    \n    // First try standard layouts for well-known groups\n    const standardLayout = StandardLayoutGenerator.getStandardLayout(group.name, group.order);\n    if (standardLayout && !prefer3D) {\n      console.log(`ðŸŽ¯ Using predefined standard layout for ${group.name}`);\n      return this.convertStandardToAdvanced(standardLayout);\n    }\n\n    console.log(`ðŸ§  Computing advanced layout for ${group.name} with generators:`, generators);\n    \n    // Analyze group structure to determine optimal strategy\n    const analysis = this.analyzeGroupStructure(group, generators);\n    console.log('Group analysis:', analysis);\n    \n    // Generate nesting strategy based on generators\n    const nestingStrategy = this.generateNestingStrategy(group, generators, analysis);\n    console.log('Nesting strategy:', nestingStrategy);\n    \n    // Apply the layout strategy\n    const layout = this.applyNestingStrategy(group, nestingStrategy, prefer3D);\n    \n    return layout;\n  }\n\n  /**\n   * Analyzes group structure to determine optimal layout approach\n   * Similar to Group Explorer's strategy selection logic\n   */\n  private static analyzeGroupStructure(group: Group, generators: string[]) {\n    const analysis = {\n      isCyclic: this.isCyclic(group),\n      isAbelian: group.isAbelian,\n      isDihedral: this.isDihedral(group),\n      generatorOrders: generators.map(gen => \n        group.elements.find(e => e.id === gen)?.order || 1\n      ),\n      subgroupChain: this.computeSubgroupChain(group, generators),\n      symmetryType: this.detectSymmetryType(group)\n    };\n\n    return analysis;\n  }\n\n  /**\n   * Generates hierarchical nesting strategy\n   * Replicates Group Explorer's nesting level computation\n   */\n  private static generateNestingStrategy(\n    group: Group, \n    generators: string[], \n    analysis: any\n  ): LayoutNestingLevel[] {\n    const strategy: LayoutNestingLevel[] = [];\n    \n    // Handle trivial group special case\n    if (group.order === 1) {\n      return [{\n        generator: '',\n        strategy: 'linear',\n        direction: 'X',\n        nestingLevel: 0,\n        subgroupElements: ['e']\n      }];\n    }\n\n    // For each generator, determine optimal layout strategy\n    generators.forEach((generator, index) => {\n      const generatorElement = group.elements.find(e => e.id === generator);\n      const generatorOrder = generatorElement?.order || 1;\n      \n      let layoutStrategy: LayoutStrategy = 'linear';\n      let direction: LayoutDirection = 'X';\n      \n      // Strategy selection logic (based on Group Explorer's approach)\n      if (generatorOrder === 2) {\n        layoutStrategy = 'linear';\n        direction = index === 0 ? 'X' : (index === 1 ? 'Y' : 'Z');\n      } else if (generatorOrder <= 4 && analysis.isCyclic) {\n        layoutStrategy = 'circular';\n        direction = 'XY';\n      } else if (generatorOrder > 4 || analysis.isDihedral) {\n        layoutStrategy = 'circular';\n        direction = index === 0 ? 'XY' : 'XZ';\n      } else {\n        // For complex cases, use rotated layout\n        layoutStrategy = 'rotated';\n        direction = 'XY';\n      }\n\n      strategy.push({\n        generator,\n        strategy: layoutStrategy,\n        direction,\n        nestingLevel: index,\n        subgroupElements: this.computeGeneratedSubgroup(group, generator)\n      });\n    });\n\n    return strategy;\n  }\n\n  /**\n   * Applies the nesting strategy to generate final positions\n   * Implements Group Explorer's coordinate transformation system\n   */\n  private static applyNestingStrategy(\n    group: Group, \n    strategy: LayoutNestingLevel[], \n    is3D: boolean\n  ): AdvancedLayout {\n    const positions: { [elementId: string]: { x: number, y: number, z?: number } } = {};\n    \n    // Base case: single element at origin\n    if (group.order === 1) {\n      positions['e'] = { x: 300, y: 200, z: is3D ? 0 : undefined };\n      return {\n        positions,\n        nestingStructure: strategy,\n        description: 'Trivial group - single point',\n        is3D\n      };\n    }\n\n    // For each nesting level, arrange elements according to strategy\n    let currentElements = ['e']; // Start with identity\n    const canvasWidth = 600;\n    const canvasHeight = 400;\n    const centerX = canvasWidth / 2;\n    const centerY = canvasHeight / 2;\n\n    // Initialize identity at center\n    positions['e'] = { x: centerX, y: centerY, z: is3D ? 0 : undefined };\n\n    strategy.forEach((level, levelIndex) => {\n      const { generator, strategy: layoutStrategy, direction } = level;\n      \n      console.log(`Applying level ${levelIndex}: ${layoutStrategy} layout for generator ${generator}`);\n      \n      // Get all elements that will be positioned at this level\n      const newElements = this.getElementsForLevel(group, currentElements, generator);\n      \n      // Apply the specific layout strategy\n      switch (layoutStrategy) {\n        case 'linear':\n          this.applyLinearLayout(newElements, positions, direction, centerX, centerY, is3D);\n          break;\n        case 'circular':\n          this.applyCircularLayout(newElements, positions, direction, centerX, centerY, is3D);\n          break;\n        case 'rotated':\n          this.applyRotatedLayout(newElements, positions, direction, centerX, centerY, is3D);\n          break;\n      }\n      \n      currentElements = [...currentElements, ...newElements];\n    });\n\n    return {\n      positions,\n      nestingStructure: strategy,\n      description: `Advanced layout with ${strategy.length} nesting levels`,\n      is3D\n    };\n  }\n\n  /**\n   * Linear layout strategy - distributes elements along an axis\n   */\n  private static applyLinearLayout(\n    elements: string[], \n    positions: any, \n    direction: LayoutDirection,\n    centerX: number, \n    centerY: number, \n    is3D: boolean\n  ) {\n    const spacing = 80;\n    const startOffset = -(elements.length - 1) * spacing / 2;\n    \n    elements.forEach((element, index) => {\n      const offset = startOffset + index * spacing;\n      \n      switch (direction) {\n        case 'X':\n          positions[element] = { \n            x: centerX + offset, \n            y: centerY, \n            z: is3D ? 0 : undefined \n          };\n          break;\n        case 'Y':\n          positions[element] = { \n            x: centerX, \n            y: centerY + offset, \n            z: is3D ? 0 : undefined \n          };\n          break;\n        case 'Z':\n          positions[element] = { \n            x: centerX, \n            y: centerY, \n            z: is3D ? offset : undefined \n          };\n          break;\n      }\n    });\n  }\n\n  /**\n   * Circular layout strategy - arranges elements in a circle\n   */\n  private static applyCircularLayout(\n    elements: string[], \n    positions: any, \n    direction: LayoutDirection,\n    centerX: number, \n    centerY: number, \n    is3D: boolean\n  ) {\n    const radius = Math.min(centerX, centerY) * 0.6;\n    \n    elements.forEach((element, index) => {\n      const angle = (2 * Math.PI * index) / elements.length;\n      \n      switch (direction) {\n        case 'XY':\n          positions[element] = {\n            x: centerX + radius * Math.cos(angle),\n            y: centerY + radius * Math.sin(angle),\n            z: is3D ? 0 : undefined\n          };\n          break;\n        case 'XZ':\n          positions[element] = {\n            x: centerX + radius * Math.cos(angle),\n            y: centerY,\n            z: is3D ? radius * Math.sin(angle) : undefined\n          };\n          break;\n        case 'YZ':\n          positions[element] = {\n            x: centerX,\n            y: centerY + radius * Math.cos(angle),\n            z: is3D ? radius * Math.sin(angle) : undefined\n          };\n          break;\n      }\n    });\n  }\n\n  /**\n   * Rotated layout strategy - creates rotational symmetry patterns\n   */\n  private static applyRotatedLayout(\n    elements: string[], \n    positions: any, \n    direction: LayoutDirection,\n    centerX: number, \n    centerY: number, \n    is3D: boolean\n  ) {\n    // Similar to circular but with rotation offset\n    const radius = Math.min(centerX, centerY) * 0.7;\n    const rotationOffset = Math.PI / 4; // 45-degree offset\n    \n    elements.forEach((element, index) => {\n      const angle = (2 * Math.PI * index) / elements.length + rotationOffset;\n      \n      positions[element] = {\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle),\n        z: is3D ? 20 * Math.sin(angle * 2) : undefined // Add some 3D variation\n      };\n    });\n  }\n\n  // Helper methods for group analysis\n  private static isCyclic(group: Group): boolean {\n    return group.generators.length === 1;\n  }\n\n  private static isDihedral(group: Group): boolean {\n    return group.name.startsWith('D') && group.generators.length === 2;\n  }\n\n  private static detectSymmetryType(group: Group): string {\n    if (group.name.startsWith('C')) return 'cyclic';\n    if (group.name.startsWith('D')) return 'dihedral';\n    if (group.name.startsWith('S')) return 'symmetric';\n    if (group.name.startsWith('A')) return 'alternating';\n    if (group.name.includes('x')) return 'product';\n    return 'general';\n  }\n\n  private static computeSubgroupChain(group: Group, generators: string[]): string[][] {\n    // Simplified subgroup chain computation\n    const chain: string[][] = [['e']];\n    \n    generators.forEach(gen => {\n      const subgroup = this.computeGeneratedSubgroup(group, gen);\n      chain.push(subgroup);\n    });\n    \n    return chain;\n  }\n\n  private static computeGeneratedSubgroup(group: Group, generator: string): string[] {\n    const subgroup = new Set<string>(['e']);\n    const generatorElement = group.elements.find(e => e.id === generator);\n    \n    if (!generatorElement) return ['e'];\n    \n    let current = generator;\n    subgroup.add(current);\n    \n    // Generate powers of the generator\n    for (let i = 2; i < generatorElement.order; i++) {\n      const next = group.operations.get(current)?.get(generator);\n      if (next && !subgroup.has(next)) {\n        subgroup.add(next);\n        current = next;\n      } else {\n        break;\n      }\n    }\n    \n    return Array.from(subgroup);\n  }\n\n  private static getElementsForLevel(\n    group: Group, \n    currentElements: string[], \n    generator: string\n  ): string[] {\n    const newElements: string[] = [];\n    \n    currentElements.forEach(element => {\n      const product = group.operations.get(element)?.get(generator);\n      if (product && !currentElements.includes(product) && !newElements.includes(product)) {\n        newElements.push(product);\n      }\n    });\n    \n    return newElements;\n  }\n\n  private static convertStandardToAdvanced(standardLayout: any): AdvancedLayout {\n    const positions: { [elementId: string]: { x: number, y: number } } = {};\n    \n    Object.entries(standardLayout.positions).forEach(([elementId, pos]: [string, any]) => {\n      positions[elementId] = {\n        x: pos.x * 600,\n        y: pos.y * 400\n      };\n    });\n\n    return {\n      positions,\n      nestingStructure: [],\n      description: standardLayout.description,\n      is3D: false\n    };\n  }\n}\n"],"names":["AdvancedLayoutEngine","generateOptimalLayout","group","generators","prefer3D","standardLayout","StandardLayoutGenerator","getStandardLayout","name","order","console","log","convertStandardToAdvanced","analysis","analyzeGroupStructure","nestingStrategy","generateNestingStrategy","layout","applyNestingStrategy","isCyclic","isAbelian","isDihedral","generatorOrders","map","gen","elements","find","e","id","subgroupChain","computeSubgroupChain","symmetryType","detectSymmetryType","strategy","generator","direction","nestingLevel","subgroupElements","forEach","index","generatorElement","generatorOrder","layoutStrategy","push","computeGeneratedSubgroup","is3D","positions","x","y","z","undefined","nestingStructure","description","currentElements","canvasWidth","canvasHeight","centerX","centerY","level","levelIndex","newElements","getElementsForLevel","applyLinearLayout","applyCircularLayout","applyRotatedLayout","length","spacing","startOffset","element","offset","radius","Math","min","angle","PI","cos","sin","rotationOffset","startsWith","includes","chain","subgroup","Set","current","add","i","next","operations","get","has","Array","from","product","Object","entries","elementId","pos"],"mappings":"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"}