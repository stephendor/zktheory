f6ee234c959d7911513d8f7bea065f84
/**
 * Comprehensive Unit Tests for AdvancedLayoutEngine
 * Tests layout strategy generation, mathematical accuracy, and performance
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _AdvancedLayoutEngine = require("../../lib/AdvancedLayoutEngine");
const _GroupDatabase = require("../../lib/GroupDatabase");
const _StandardLayouts = require("../../lib/StandardLayouts");
const _mathematicalValidation = require("../utils/mathematicalValidation");
// Extend Jest matchers
expect.extend(_mathematicalValidation.mathematicalMatchers);
describe('AdvancedLayoutEngine', ()=>{
    // Test data setup
    let cyclicGroup3;
    let cyclicGroup4;
    let dihedralGroup3;
    let symmetricGroup3;
    let trivialGroup;
    beforeAll(()=>{
        // Get test groups from GroupDatabase
        cyclicGroup3 = _GroupDatabase.GroupDatabase.getGroup('C3');
        cyclicGroup4 = _GroupDatabase.GroupDatabase.getGroup('C4');
        dihedralGroup3 = _GroupDatabase.GroupDatabase.getGroup('D3');
        symmetricGroup3 = _GroupDatabase.GroupDatabase.getGroup('S3');
        // Get trivial group from database
        trivialGroup = _GroupDatabase.GroupDatabase.getGroup('C1');
    });
    describe('Layout Strategy Generation', ()=>{
        describe('generateOptimalLayout', ()=>{
            test('generates layout for trivial group', ()=>{
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(trivialGroup, []);
                expect(layout).toBeDefined();
                expect(layout.positions).toHaveProperty('e');
                expect(layout.is3D).toBe(false);
                const position = layout.positions['e'];
                expect(typeof position.x).toBe('number');
                expect(typeof position.y).toBe('number');
                expect(position.z).toBeUndefined();
            });
            test('generates layout for cyclic group C3', ()=>{
                // Use the actual generators from the group or fallback to common names
                const generators = cyclicGroup3.generators.length > 0 ? cyclicGroup3.generators : [
                    'a'
                ];
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, generators);
                expect(layout).toBeDefined();
                expect(layout.positions).toBeDefined();
                expect(layout.is3D).toBe(false);
                // Verify all elements have positions
                cyclicGroup3.elements.forEach((element)=>{
                    expect(layout.positions).toHaveProperty(element.id);
                    const pos = layout.positions[element.id];
                    expect(typeof pos.x).toBe('number');
                    expect(typeof pos.y).toBe('number');
                    expect(Number.isFinite(pos.x)).toBe(true);
                    expect(Number.isFinite(pos.y)).toBe(true);
                });
            });
            test('generates layout for cyclic group C4', ()=>{
                const generators = cyclicGroup4.generators.length > 0 ? cyclicGroup4.generators : [
                    'a'
                ];
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, generators);
                expect(layout).toBeDefined();
                expect(layout.positions).toBeDefined();
                // Verify all elements have positions
                cyclicGroup4.elements.forEach((element)=>{
                    expect(layout.positions).toHaveProperty(element.id);
                });
            });
            test('generates layout for dihedral group D3', ()=>{
                const generators = dihedralGroup3.generators.length > 0 ? dihedralGroup3.generators : [
                    'r',
                    's'
                ];
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(dihedralGroup3, generators);
                expect(layout).toBeDefined();
                expect(layout.positions).toBeDefined();
                // Verify all elements have positions
                dihedralGroup3.elements.forEach((element)=>{
                    expect(layout.positions).toHaveProperty(element.id);
                });
            });
            test('generates 3D layout when requested', ()=>{
                const generators = cyclicGroup3.generators.length > 0 ? cyclicGroup3.generators : [
                    'a'
                ];
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, generators, true);
                expect(layout.is3D).toBe(true);
                // All positions should have z coordinate when 3D is requested
                cyclicGroup3.elements.forEach((element)=>{
                    const pos = layout.positions[element.id];
                    // Z coordinate might be 0 but should be defined for 3D layouts
                    expect(pos.z).toBeDefined();
                    expect(typeof pos.z).toBe('number');
                    expect(Number.isFinite(pos.z)).toBe(true);
                });
            });
            test('uses standard layout when available and not prefer3D', ()=>{
                // Mock StandardLayoutGenerator to return a layout
                const mockStandardLayout = {
                    positions: {
                        'e': {
                            x: 0.5,
                            y: 0.5
                        },
                        'a': {
                            x: 0.3,
                            y: 0.7
                        },
                        'a2': {
                            x: 0.7,
                            y: 0.3
                        }
                    },
                    description: 'Standard C3 layout'
                };
                jest.spyOn(_StandardLayouts.StandardLayoutGenerator, 'getStandardLayout').mockReturnValue(mockStandardLayout);
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                    'a'
                ], false);
                expect(layout.description).toBe('Standard C3 layout');
                expect(layout.positions['e'].x).toBe(300); // Converted to canvas coordinates
                expect(layout.positions['e'].y).toBe(200);
                _StandardLayouts.StandardLayoutGenerator.getStandardLayout.mockRestore();
            });
        });
        describe('strategy selection logic', ()=>{
            test('selects linear strategy for order-2 generators', ()=>{
                // Create a group with order-2 elements
                const testGroup = {
                    name: 'Test',
                    order: 4,
                    elements: [
                        {
                            id: 'e',
                            label: 'e',
                            order: 1,
                            inverse: 'e',
                            conjugacyClass: 0
                        },
                        {
                            id: 'a',
                            label: 'a',
                            order: 2,
                            inverse: 'a',
                            conjugacyClass: 1
                        },
                        {
                            id: 'b',
                            label: 'b',
                            order: 2,
                            inverse: 'b',
                            conjugacyClass: 1
                        },
                        {
                            id: 'ab',
                            label: 'ab',
                            order: 2,
                            inverse: 'ab',
                            conjugacyClass: 1
                        }
                    ],
                    operations: new Map(),
                    generators: [
                        'a',
                        'b'
                    ],
                    isAbelian: true
                };
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(testGroup, [
                    'a',
                    'b'
                ]);
                // Should use linear strategies for order-2 generators
                expect(layout.nestingStructure[0].strategy).toBe('linear');
                expect(layout.nestingStructure[1].strategy).toBe('linear');
                // Should use different directions
                expect(layout.nestingStructure[0].direction).toBe('X');
                expect(layout.nestingStructure[1].direction).toBe('Y');
            });
            test('selects circular strategy for higher order cyclic groups', ()=>{
                // Mock StandardLayoutGenerator to return null to force advanced layout generation
                jest.spyOn(_StandardLayouts.StandardLayoutGenerator, 'getStandardLayout').mockReturnValue(null);
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                    'a'
                ]);
                expect(layout).toBeDefined();
                expect(layout.nestingStructure.length).toBeGreaterThan(0);
                _StandardLayouts.StandardLayoutGenerator.getStandardLayout.mockRestore();
            });
        });
    });
    describe('Nesting Structure Computation', ()=>{
        test('computes correct nesting levels', ()=>{
            const generators = [
                'r',
                's'
            ];
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(dihedralGroup3, generators);
            expect(layout.nestingStructure).toHaveLength(2);
            layout.nestingStructure.forEach((level, index)=>{
                expect(level.nestingLevel).toBe(index);
                expect(level.generator).toBe(generators[index]);
                expect(level.subgroupElements).toBeDefined();
                expect(Array.isArray(level.subgroupElements)).toBe(true);
                expect(level.subgroupElements.includes('e')).toBe(true);
            });
        });
        test('generates valid subgroup elements for each level', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                'a'
            ]);
            const subgroupElements = layout.nestingStructure[0].subgroupElements;
            expect(subgroupElements).toContain('e');
            expect(subgroupElements).toContain('a');
            expect(subgroupElements.length).toBeGreaterThan(1);
            // All subgroup elements should be valid group elements
            subgroupElements.forEach((elementId)=>{
                const element = cyclicGroup4.elements.find((e)=>e.id === elementId);
                expect(element).toBeDefined();
            });
        });
        test('maintains mathematical consistency in nesting', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(symmetricGroup3, [
                'a',
                'b'
            ]);
            // Verify nesting levels are sequential
            layout.nestingStructure.forEach((level, index)=>{
                expect(level.nestingLevel).toBe(index);
            });
            // Verify each level has valid strategy and direction
            layout.nestingStructure.forEach((level)=>{
                expect([
                    'linear',
                    'circular',
                    'rotated'
                ]).toContain(level.strategy);
                expect([
                    'X',
                    'Y',
                    'Z',
                    'XY',
                    'XZ',
                    'YZ'
                ]).toContain(level.direction);
            });
        });
    });
    describe('3D Layout Positioning', ()=>{
        test('generates valid 3D coordinates', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                'a'
            ], true);
            expect(layout.is3D).toBe(true);
            cyclicGroup4.elements.forEach((element)=>{
                const pos = layout.positions[element.id];
                expect(pos.z).toBeDefined();
                expect(typeof pos.z).toBe('number');
                expect(Number.isFinite(pos.z)).toBe(true);
            });
        });
        test('applies Z-direction linear layout correctly', ()=>{
            // Create test scenario that would use Z direction
            const testGroup = {
                name: 'TestZ',
                order: 4,
                elements: [
                    {
                        id: 'e',
                        label: 'e',
                        order: 1,
                        inverse: 'e',
                        conjugacyClass: 0
                    },
                    {
                        id: 'a',
                        label: 'a',
                        order: 2,
                        inverse: 'a',
                        conjugacyClass: 1
                    },
                    {
                        id: 'b',
                        label: 'b',
                        order: 2,
                        inverse: 'b',
                        conjugacyClass: 1
                    },
                    {
                        id: 'c',
                        label: 'c',
                        order: 2,
                        inverse: 'c',
                        conjugacyClass: 1
                    }
                ],
                operations: new Map(),
                generators: [
                    'a',
                    'b',
                    'c'
                ],
                isAbelian: true
            };
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(testGroup, [
                'a',
                'b',
                'c'
            ], true);
            // Third generator should use Z direction
            expect(layout.nestingStructure[2].direction).toBe('Z');
            // Verify Z-coordinates vary for elements positioned by third generator
            const zCoords = testGroup.elements.map((e)=>layout.positions[e.id].z);
            const uniqueZCoords = [
                ...new Set(zCoords)
            ];
            expect(uniqueZCoords.length).toBeGreaterThan(1);
        });
        test('applies XZ and YZ circular layouts correctly', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(dihedralGroup3, [
                'r',
                's'
            ], true);
            // Should have some 3D positioning
            const hasNonZeroZ = dihedralGroup3.elements.some((e)=>layout.positions[e.id].z !== undefined && layout.positions[e.id].z !== 0);
            expect(hasNonZeroZ).toBe(true);
        });
    });
    describe('Layout Strategy Application', ()=>{
        describe('Linear Layout', ()=>{
            test('distributes elements along X-axis correctly', ()=>{
                const testGroup = {
                    name: 'LinearTest',
                    order: 3,
                    elements: [
                        {
                            id: 'e',
                            label: 'e',
                            order: 1,
                            inverse: 'e',
                            conjugacyClass: 0
                        },
                        {
                            id: 'a',
                            label: 'a',
                            order: 2,
                            inverse: 'a',
                            conjugacyClass: 1
                        },
                        {
                            id: 'b',
                            label: 'b',
                            order: 2,
                            inverse: 'b',
                            conjugacyClass: 1
                        }
                    ],
                    operations: new Map(),
                    generators: [
                        'a'
                    ],
                    isAbelian: true
                };
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(testGroup, [
                    'a'
                ]);
                // Elements should be aligned along X-axis with constant Y
                const positions = Object.values(layout.positions);
                const yCoords = positions.map((p)=>p.y);
                const uniqueYCoords = [
                    ...new Set(yCoords)
                ];
                // Should have consistent Y coordinate (allowing for floating point precision)
                expect(uniqueYCoords.length).toBeLessThanOrEqual(2); // Identity might be at center
                // X coordinates should vary
                const xCoords = positions.map((p)=>p.x);
                const uniqueXCoords = [
                    ...new Set(xCoords)
                ];
                expect(uniqueXCoords.length).toBeGreaterThan(1);
            });
            test('maintains equal spacing in linear layout', ()=>{
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                    'a'
                ]);
                // Get positions in order
                const orderedPositions = cyclicGroup4.elements.sort((a, b)=>a.id.localeCompare(b.id)).map((e)=>layout.positions[e.id]);
                // Calculate spacing between adjacent elements
                const spacings = [];
                for(let i = 1; i < orderedPositions.length; i++){
                    const dx = orderedPositions[i].x - orderedPositions[i - 1].x;
                    const dy = orderedPositions[i].y - orderedPositions[i - 1].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    spacings.push(distance);
                }
                // Verify spacings are approximately equal (within tolerance)
                if (spacings.length > 1) {
                    const avgSpacing = spacings.reduce((a, b)=>a + b, 0) / spacings.length;
                    spacings.forEach((spacing)=>{
                        global.testUtils.expectMathematicalAccuracy(spacing, avgSpacing, 1);
                    });
                }
            });
        });
        describe('Circular Layout', ()=>{
            test('arranges elements in circular pattern', ()=>{
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                    'a'
                ]);
                // Should use circular layout for C4
                expect(layout.nestingStructure[0].strategy).toBe('circular');
                // Calculate distances from center for all elements
                const centerX = 300; // Canvas center
                const centerY = 200;
                const distances = cyclicGroup4.elements.map((element)=>{
                    const pos = layout.positions[element.id];
                    return Math.sqrt((pos.x - centerX) ** 2 + (pos.y - centerY) ** 2);
                });
                // All elements (except possibly identity) should be approximately the same distance from center
                const nonIdentityDistances = distances.filter((d)=>d > 10); // Filter out identity at center
                if (nonIdentityDistances.length > 1) {
                    const avgDistance = nonIdentityDistances.reduce((a, b)=>a + b, 0) / nonIdentityDistances.length;
                    nonIdentityDistances.forEach((distance)=>{
                        global.testUtils.expectMathematicalAccuracy(distance, avgDistance, 5);
                    });
                }
            });
            test('maintains angular symmetry in circular layout', ()=>{
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                    'a'
                ]);
                const centerX = 300;
                const centerY = 200;
                // Calculate angles for all non-identity elements
                const angles = cyclicGroup3.elements.filter((e)=>e.id !== 'e').map((element)=>{
                    const pos = layout.positions[element.id];
                    return Math.atan2(pos.y - centerY, pos.x - centerX);
                });
                if (angles.length > 1) {
                    // Calculate angular differences
                    const sortedAngles = angles.sort();
                    const angularDifferences = [];
                    for(let i = 1; i < sortedAngles.length; i++){
                        angularDifferences.push(sortedAngles[i] - sortedAngles[i - 1]);
                    }
                    // Add wrap-around difference
                    angularDifferences.push(2 * Math.PI - (sortedAngles[sortedAngles.length - 1] - sortedAngles[0]));
                    // All angular differences should be approximately equal
                    const expectedAngle = 2 * Math.PI / angles.length;
                    angularDifferences.forEach((angle)=>{
                        global.testUtils.expectMathematicalAccuracy(angle, expectedAngle, 0.1);
                    });
                }
            });
        });
        describe('Rotated Layout', ()=>{
            test('applies rotation offset correctly', ()=>{
                // Create scenario that uses rotated layout
                const complexGroup = {
                    name: 'Complex',
                    order: 8,
                    elements: Array.from({
                        length: 8
                    }, (_, i)=>({
                            id: `g${i}`,
                            label: `g${i}`,
                            order: i === 0 ? 1 : 8,
                            inverse: `g${i}`,
                            conjugacyClass: i
                        })),
                    operations: new Map(),
                    generators: [
                        'g1'
                    ],
                    isAbelian: false
                };
                const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(complexGroup, [
                    'g1'
                ]);
                // Verify positions are generated
                complexGroup.elements.forEach((element)=>{
                    const pos = layout.positions[element.id];
                    expect(Number.isFinite(pos.x)).toBe(true);
                    expect(Number.isFinite(pos.y)).toBe(true);
                });
            });
        });
    });
    describe('Group Structure Analysis', ()=>{
        test('correctly identifies cyclic groups', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ]);
            // Should detect cyclic structure and use appropriate strategy
            expect(layout.nestingStructure).toHaveLength(1);
            expect(layout.nestingStructure[0].strategy).toMatch(/circular|linear/);
        });
        test('correctly identifies dihedral groups', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(dihedralGroup3, [
                'r',
                's'
            ]);
            // Should have two generators and appropriate strategies
            expect(layout.nestingStructure).toHaveLength(2);
            // Should use strategies appropriate for dihedral structure
            const strategies = layout.nestingStructure.map((level)=>level.strategy);
            expect(strategies.some((s)=>s === 'circular')).toBe(true);
        });
        test('handles abelian groups correctly', ()=>{
            expect(cyclicGroup3.isAbelian).toBe(true);
            expect(cyclicGroup4.isAbelian).toBe(true);
            expect(dihedralGroup3.isAbelian).toBe(false);
            const cyclicLayout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ]);
            const dihedralLayout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(dihedralGroup3, [
                'r',
                's'
            ]);
            // Both should generate valid layouts
            expect(cyclicLayout.positions).toBeDefined();
            expect(dihedralLayout.positions).toBeDefined();
        });
    });
    describe('Standard Layout Conversion', ()=>{
        test('converts standard layout to advanced layout format', ()=>{
            const mockStandardLayout = {
                positions: {
                    'e': {
                        x: 0.5,
                        y: 0.5
                    },
                    'a': {
                        x: 0.3,
                        y: 0.7
                    },
                    'a2': {
                        x: 0.7,
                        y: 0.3
                    }
                },
                description: 'Mock standard layout'
            };
            jest.spyOn(_StandardLayouts.StandardLayoutGenerator, 'getStandardLayout').mockReturnValue(mockStandardLayout);
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ], false);
            expect(layout.positions['e'].x).toBe(300); // 0.5 * 600
            expect(layout.positions['e'].y).toBe(200); // 0.5 * 400
            expect(layout.positions['a'].x).toBe(180); // 0.3 * 600
            expect(layout.positions['a'].y).toBe(280); // 0.7 * 400
            expect(layout.description).toBe('Mock standard layout');
            expect(layout.is3D).toBe(false);
            expect(layout.nestingStructure).toHaveLength(0);
            _StandardLayouts.StandardLayoutGenerator.getStandardLayout.mockRestore();
        });
    });
    describe('Mathematical Accuracy', ()=>{
        test('maintains mathematical precision in coordinate calculations', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                'a'
            ]);
            // Verify all coordinates are finite and precise
            cyclicGroup4.elements.forEach((element)=>{
                const pos = layout.positions[element.id];
                expect(Number.isFinite(pos.x)).toBe(true);
                expect(Number.isFinite(pos.y)).toBe(true);
                expect(Number.isNaN(pos.x)).toBe(false);
                expect(Number.isNaN(pos.y)).toBe(false);
                // Coordinates should be reasonable (within canvas bounds + some margin)
                expect(pos.x).toBeGreaterThan(-100);
                expect(pos.x).toBeLessThan(700);
                expect(pos.y).toBeGreaterThan(-100);
                expect(pos.y).toBeLessThan(500);
            });
        });
        test('maintains group-theoretic consistency', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ]);
            // All group elements should have positions
            cyclicGroup3.elements.forEach((element)=>{
                expect(layout.positions).toHaveProperty(element.id);
            });
            // Number of positioned elements should match group order
            const positionedElements = Object.keys(layout.positions);
            expect(positionedElements).toHaveLength(cyclicGroup3.order);
            // Identity should be present
            expect(layout.positions).toHaveProperty('e');
        });
        test('validates layout mathematical properties', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                'a'
            ]);
            // Test mathematical invariants
            const positions = Object.values(layout.positions);
            const xCoords = positions.map((p)=>p.x);
            const yCoords = positions.map((p)=>p.y);
            // Validate numerical stability
            const validation = _mathematicalValidation.PrecisionValidator.validateFloatingPointStability([
                ...xCoords,
                ...yCoords
            ]);
            expect(validation.isValid).toBe(true);
            // Check for reasonable spread (elements shouldn't all be at same point)
            const xRange = Math.max(...xCoords) - Math.min(...xCoords);
            const yRange = Math.max(...yCoords) - Math.min(...yCoords);
            expect(xRange + yRange).toBeGreaterThan(0);
        });
    });
    describe('Performance Testing', ()=>{
        test('layout generation completes within time bounds', ()=>{
            const { result, duration } = global.testUtils.expectPerformance(()=>{
                return _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(symmetricGroup3, [
                    'a',
                    'b'
                ]);
            }, 500); // 500ms max
            expect(result).toBeDefined();
            expect(result.positions).toBeDefined();
            console.log(`Layout generation completed in ${duration.toFixed(2)}ms`);
        });
        test('memory usage is reasonable for layout generation', ()=>{
            const { result, memoryIncrease } = global.testUtils.expectMemoryUsage(()=>{
                return _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(symmetricGroup3, [
                    'a',
                    'b'
                ]);
            }, 10); // 10MB max increase
            expect(result).toBeDefined();
            console.log(`Memory increase: ${memoryIncrease.toFixed(2)}MB`);
        });
        test('scales appropriately with group size', ()=>{
            const times = [];
            const groups = [
                cyclicGroup3,
                cyclicGroup4,
                symmetricGroup3
            ];
            groups.forEach((group)=>{
                const startTime = performance.now();
                _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(group, group.generators);
                const endTime = performance.now();
                times.push(endTime - startTime);
            });
            // Performance should scale reasonably (not exponentially)
            times.forEach((time)=>{
                expect(time).toBeLessThan(1000); // 1 second max for test groups
            });
            console.log('Scaling times:', times.map((t)=>`${t.toFixed(2)}ms`));
        });
        test('deterministic behavior for same inputs', ()=>{
            const layout1 = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ]);
            const layout2 = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ]);
            // Should produce identical results
            expect(layout1.positions).toEqual(layout2.positions);
            expect(layout1.nestingStructure).toEqual(layout2.nestingStructure);
            expect(layout1.description).toBe(layout2.description);
            expect(layout1.is3D).toBe(layout2.is3D);
        });
    });
    describe('Edge Cases', ()=>{
        test('handles empty generators array', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, []);
            expect(layout).toBeDefined();
            expect(layout.positions).toBeDefined();
            // Should still position all elements somehow
            expect(Object.keys(layout.positions)).toHaveLength(cyclicGroup3.order);
        });
        test('handles invalid generator names gracefully', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'invalid'
            ]);
            expect(layout).toBeDefined();
            expect(layout.positions).toBeDefined();
        // Should not crash, but may have default behavior
        });
        test('handles groups with single element', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(trivialGroup, []);
            expect(layout).toBeDefined();
            expect(layout.positions).toHaveProperty('e');
            expect(layout.nestingStructure).toHaveLength(1);
            expect(layout.description).toContain('Trivial group');
        });
        test('handles large number of generators', ()=>{
            const manyGenerators = Array.from({
                length: 10
            }, (_, i)=>`g${i}`);
            // Should not crash even with many generators
            expect(()=>{
                _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, manyGenerators);
            }).not.toThrow();
        });
        test('handles extreme coordinate values gracefully', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                'a'
            ], true);
            // Verify coordinates are not extreme
            cyclicGroup4.elements.forEach((element)=>{
                const pos = layout.positions[element.id];
                expect(Math.abs(pos.x)).toBeLessThan(1e6);
                expect(Math.abs(pos.y)).toBeLessThan(1e6);
                if (pos.z !== undefined) {
                    expect(Math.abs(pos.z)).toBeLessThan(1e6);
                }
            });
        });
    });
    describe('Integration with Group Theory', ()=>{
        test('respects group structure in layout', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ]);
            // Verify all group elements are represented
            const layoutElementIds = Object.keys(layout.positions);
            const groupElementIds = cyclicGroup3.elements.map((e)=>e.id);
            expect(layoutElementIds.sort()).toEqual(groupElementIds.sort());
        });
        test('validates against group axioms', ()=>{
            // Verify our test groups are mathematically valid
            [
                cyclicGroup3,
                cyclicGroup4,
                dihedralGroup3,
                symmetricGroup3,
                trivialGroup
            ].forEach((group)=>{
                expect(group).toBeValidGroup();
            });
        });
        test('maintains generator relationships in layout', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                'a'
            ]);
            // Generator should be included in nesting structure
            expect(layout.nestingStructure[0].generator).toBe('a');
            expect(layout.nestingStructure[0].subgroupElements).toContain('a');
            expect(layout.nestingStructure[0].subgroupElements).toContain('e');
        });
    });
    describe('Layout Quality Metrics', ()=>{
        test('minimizes edge crossings in planar layouts', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup4, [
                'a'
            ]);
            // For cyclic groups, circular layout should minimize crossings
            // Verify elements are positioned to form a reasonable graph
            const positions = layout.positions;
            const elementIds = Object.keys(positions);
            // Calculate minimum distance between any two elements
            let minDistance = Infinity;
            for(let i = 0; i < elementIds.length; i++){
                for(let j = i + 1; j < elementIds.length; j++){
                    const pos1 = positions[elementIds[i]];
                    const pos2 = positions[elementIds[j]];
                    const distance = Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2);
                    minDistance = Math.min(minDistance, distance);
                }
            }
            // Elements shouldn't be too close (overlap) or too far apart
            expect(minDistance).toBeGreaterThan(5);
            expect(minDistance).toBeLessThan(200);
        });
        test('maintains visual balance in layout', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(cyclicGroup3, [
                'a'
            ]);
            // Calculate center of mass of all positioned elements
            const positions = Object.values(layout.positions);
            const centerX = positions.reduce((sum, pos)=>sum + pos.x, 0) / positions.length;
            const centerY = positions.reduce((sum, pos)=>sum + pos.y, 0) / positions.length;
            // Center of mass should be reasonably close to canvas center
            const canvasCenterX = 300;
            const canvasCenterY = 200;
            expect(Math.abs(centerX - canvasCenterX)).toBeLessThan(100);
            expect(Math.abs(centerY - canvasCenterY)).toBeLessThan(100);
        });
        test('optimizes space utilization', ()=>{
            const layout = _AdvancedLayoutEngine.AdvancedLayoutEngine.generateOptimalLayout(symmetricGroup3, [
                'a',
                'b'
            ]);
            // Calculate bounding box of all elements
            const positions = Object.values(layout.positions);
            const minX = Math.min(...positions.map((p)=>p.x));
            const maxX = Math.max(...positions.map((p)=>p.x));
            const minY = Math.min(...positions.map((p)=>p.y));
            const maxY = Math.max(...positions.map((p)=>p.y));
            const width = maxX - minX;
            const height = maxY - minY;
            // Layout should use reasonable portion of canvas space
            expect(width).toBeGreaterThan(50); // Not too cramped
            expect(height).toBeGreaterThan(50);
            expect(width).toBeLessThan(600); // Not exceeding canvas
            expect(height).toBeLessThan(400);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3N0ZXBoZW4tZG9ybWFuL2Rldi96a3RoZW9yeS9zcmMvX190ZXN0c19fL2xpYi9BZHZhbmNlZExheW91dEVuZ2luZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tcHJlaGVuc2l2ZSBVbml0IFRlc3RzIGZvciBBZHZhbmNlZExheW91dEVuZ2luZVxuICogVGVzdHMgbGF5b3V0IHN0cmF0ZWd5IGdlbmVyYXRpb24sIG1hdGhlbWF0aWNhbCBhY2N1cmFjeSwgYW5kIHBlcmZvcm1hbmNlXG4gKi9cblxuaW1wb3J0IHtcbiAgQWR2YW5jZWRMYXlvdXRFbmdpbmUsXG4gIHR5cGUgQWR2YW5jZWRMYXlvdXQsXG4gIHR5cGUgTGF5b3V0U3RyYXRlZ3ksXG4gIHR5cGUgTGF5b3V0RGlyZWN0aW9uLFxuICB0eXBlIExheW91dE5lc3RpbmdMZXZlbFxufSBmcm9tICdAL2xpYi9BZHZhbmNlZExheW91dEVuZ2luZSc7XG5cbmltcG9ydCB7IEdyb3VwLCBHcm91cEVsZW1lbnQsIEdyb3VwVGhlb3J5TGlicmFyeSB9IGZyb20gJ0AvbGliL0dyb3VwVGhlb3J5JztcbmltcG9ydCB7IEdyb3VwRGF0YWJhc2UgfSBmcm9tICdAL2xpYi9Hcm91cERhdGFiYXNlJztcbmltcG9ydCB7IFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yIH0gZnJvbSAnQC9saWIvU3RhbmRhcmRMYXlvdXRzJztcblxuaW1wb3J0IHtcbiAgR3JvdXBUaGVvcnlWYWxpZGF0b3IsXG4gIFByZWNpc2lvblZhbGlkYXRvcixcbiAgUGVyZm9ybWFuY2VWYWxpZGF0b3IsXG4gIG1hdGhlbWF0aWNhbE1hdGNoZXJzLFxuICBNQVRIRU1BVElDQUxfUFJFQ0lTSU9OLFxuICBhZ2dyZWdhdGVWYWxpZGF0aW9uUmVzdWx0c1xufSBmcm9tICcuLi91dGlscy9tYXRoZW1hdGljYWxWYWxpZGF0aW9uJztcblxuLy8gRXh0ZW5kIEplc3QgbWF0Y2hlcnNcbmV4cGVjdC5leHRlbmQobWF0aGVtYXRpY2FsTWF0Y2hlcnMpO1xuXG5kZXNjcmliZSgnQWR2YW5jZWRMYXlvdXRFbmdpbmUnLCAoKSA9PiB7XG4gIFxuICAvLyBUZXN0IGRhdGEgc2V0dXBcbiAgbGV0IGN5Y2xpY0dyb3VwMzogR3JvdXA7XG4gIGxldCBjeWNsaWNHcm91cDQ6IEdyb3VwO1xuICBsZXQgZGloZWRyYWxHcm91cDM6IEdyb3VwO1xuICBsZXQgc3ltbWV0cmljR3JvdXAzOiBHcm91cDtcbiAgbGV0IHRyaXZpYWxHcm91cDogR3JvdXA7XG5cbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAvLyBHZXQgdGVzdCBncm91cHMgZnJvbSBHcm91cERhdGFiYXNlXG4gICAgY3ljbGljR3JvdXAzID0gR3JvdXBEYXRhYmFzZS5nZXRHcm91cCgnQzMnKSE7XG4gICAgY3ljbGljR3JvdXA0ID0gR3JvdXBEYXRhYmFzZS5nZXRHcm91cCgnQzQnKSE7XG4gICAgZGloZWRyYWxHcm91cDMgPSBHcm91cERhdGFiYXNlLmdldEdyb3VwKCdEMycpITtcbiAgICBzeW1tZXRyaWNHcm91cDMgPSBHcm91cERhdGFiYXNlLmdldEdyb3VwKCdTMycpITtcbiAgICBcbiAgICAvLyBHZXQgdHJpdmlhbCBncm91cCBmcm9tIGRhdGFiYXNlXG4gICAgdHJpdmlhbEdyb3VwID0gR3JvdXBEYXRhYmFzZS5nZXRHcm91cCgnQzEnKSE7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMYXlvdXQgU3RyYXRlZ3kgR2VuZXJhdGlvbicsICgpID0+IHtcbiAgICBcbiAgICBkZXNjcmliZSgnZ2VuZXJhdGVPcHRpbWFsTGF5b3V0JywgKCkgPT4ge1xuICAgICAgdGVzdCgnZ2VuZXJhdGVzIGxheW91dCBmb3IgdHJpdmlhbCBncm91cCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KHRyaXZpYWxHcm91cCwgW10pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGxheW91dCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KGxheW91dC5wb3NpdGlvbnMpLnRvSGF2ZVByb3BlcnR5KCdlJyk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQuaXMzRCkudG9CZShmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGxheW91dC5wb3NpdGlvbnNbJ2UnXTtcbiAgICAgICAgZXhwZWN0KHR5cGVvZiBwb3NpdGlvbi54KS50b0JlKCdudW1iZXInKTtcbiAgICAgICAgZXhwZWN0KHR5cGVvZiBwb3NpdGlvbi55KS50b0JlKCdudW1iZXInKTtcbiAgICAgICAgZXhwZWN0KHBvc2l0aW9uLnopLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KCdnZW5lcmF0ZXMgbGF5b3V0IGZvciBjeWNsaWMgZ3JvdXAgQzMnLCAoKSA9PiB7XG4gICAgICAgIC8vIFVzZSB0aGUgYWN0dWFsIGdlbmVyYXRvcnMgZnJvbSB0aGUgZ3JvdXAgb3IgZmFsbGJhY2sgdG8gY29tbW9uIG5hbWVzXG4gICAgICAgIGNvbnN0IGdlbmVyYXRvcnMgPSBjeWNsaWNHcm91cDMuZ2VuZXJhdG9ycy5sZW5ndGggPiAwID8gY3ljbGljR3JvdXAzLmdlbmVyYXRvcnMgOiBbJ2EnXTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwMywgZ2VuZXJhdG9ycyk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobGF5b3V0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9ucykudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KGxheW91dC5pczNEKS50b0JlKGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBhbGwgZWxlbWVudHMgaGF2ZSBwb3NpdGlvbnNcbiAgICAgICAgY3ljbGljR3JvdXAzLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgZXhwZWN0KGxheW91dC5wb3NpdGlvbnMpLnRvSGF2ZVByb3BlcnR5KGVsZW1lbnQuaWQpO1xuICAgICAgICAgIGNvbnN0IHBvcyA9IGxheW91dC5wb3NpdGlvbnNbZWxlbWVudC5pZF07XG4gICAgICAgICAgZXhwZWN0KHR5cGVvZiBwb3MueCkudG9CZSgnbnVtYmVyJyk7XG4gICAgICAgICAgZXhwZWN0KHR5cGVvZiBwb3MueSkudG9CZSgnbnVtYmVyJyk7XG4gICAgICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShwb3MueCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShwb3MueSkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2dlbmVyYXRlcyBsYXlvdXQgZm9yIGN5Y2xpYyBncm91cCBDNCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdG9ycyA9IGN5Y2xpY0dyb3VwNC5nZW5lcmF0b3JzLmxlbmd0aCA+IDAgPyBjeWNsaWNHcm91cDQuZ2VuZXJhdG9ycyA6IFsnYSddO1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXA0LCBnZW5lcmF0b3JzKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChsYXlvdXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQucG9zaXRpb25zKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IGFsbCBlbGVtZW50cyBoYXZlIHBvc2l0aW9uc1xuICAgICAgICBjeWNsaWNHcm91cDQuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoZWxlbWVudC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2dlbmVyYXRlcyBsYXlvdXQgZm9yIGRpaGVkcmFsIGdyb3VwIEQzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBnZW5lcmF0b3JzID0gZGloZWRyYWxHcm91cDMuZ2VuZXJhdG9ycy5sZW5ndGggPiAwID8gZGloZWRyYWxHcm91cDMuZ2VuZXJhdG9ycyA6IFsncicsICdzJ107XG4gICAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChkaWhlZHJhbEdyb3VwMywgZ2VuZXJhdG9ycyk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobGF5b3V0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9ucykudG9CZURlZmluZWQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBhbGwgZWxlbWVudHMgaGF2ZSBwb3NpdGlvbnNcbiAgICAgICAgZGloZWRyYWxHcm91cDMuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoZWxlbWVudC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ2dlbmVyYXRlcyAzRCBsYXlvdXQgd2hlbiByZXF1ZXN0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvcnMgPSBjeWNsaWNHcm91cDMuZ2VuZXJhdG9ycy5sZW5ndGggPiAwID8gY3ljbGljR3JvdXAzLmdlbmVyYXRvcnMgOiBbJ2EnXTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwMywgZ2VuZXJhdG9ycywgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobGF5b3V0LmlzM0QpLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbGwgcG9zaXRpb25zIHNob3VsZCBoYXZlIHogY29vcmRpbmF0ZSB3aGVuIDNEIGlzIHJlcXVlc3RlZFxuICAgICAgICBjeWNsaWNHcm91cDMuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBwb3MgPSBsYXlvdXQucG9zaXRpb25zW2VsZW1lbnQuaWRdO1xuICAgICAgICAgIC8vIFogY29vcmRpbmF0ZSBtaWdodCBiZSAwIGJ1dCBzaG91bGQgYmUgZGVmaW5lZCBmb3IgM0QgbGF5b3V0c1xuICAgICAgICAgIGV4cGVjdChwb3MueikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICBleHBlY3QodHlwZW9mIHBvcy56KS50b0JlKCdudW1iZXInKTtcbiAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvcy56ISkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ3VzZXMgc3RhbmRhcmQgbGF5b3V0IHdoZW4gYXZhaWxhYmxlIGFuZCBub3QgcHJlZmVyM0QnLCAoKSA9PiB7XG4gICAgICAgIC8vIE1vY2sgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IgdG8gcmV0dXJuIGEgbGF5b3V0XG4gICAgICAgIGNvbnN0IG1vY2tTdGFuZGFyZExheW91dCA9IHtcbiAgICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICAgICdlJzogeyB4OiAwLjUsIHk6IDAuNSB9LFxuICAgICAgICAgICAgJ2EnOiB7IHg6IDAuMywgeTogMC43IH0sXG4gICAgICAgICAgICAnYTInOiB7IHg6IDAuNywgeTogMC4zIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnU3RhbmRhcmQgQzMgbGF5b3V0J1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgamVzdC5zcHlPbihTdGFuZGFyZExheW91dEdlbmVyYXRvciwgJ2dldFN0YW5kYXJkTGF5b3V0JykubW9ja1JldHVyblZhbHVlKG1vY2tTdGFuZGFyZExheW91dCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSwgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGxheW91dC5kZXNjcmlwdGlvbikudG9CZSgnU3RhbmRhcmQgQzMgbGF5b3V0Jyk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQucG9zaXRpb25zWydlJ10ueCkudG9CZSgzMDApOyAvLyBDb252ZXJ0ZWQgdG8gY2FudmFzIGNvb3JkaW5hdGVzXG4gICAgICAgIGV4cGVjdChsYXlvdXQucG9zaXRpb25zWydlJ10ueSkudG9CZSgyMDApO1xuICAgICAgICBcbiAgICAgICAgU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IuZ2V0U3RhbmRhcmRMYXlvdXQubW9ja1Jlc3RvcmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3N0cmF0ZWd5IHNlbGVjdGlvbiBsb2dpYycsICgpID0+IHtcbiAgICAgIHRlc3QoJ3NlbGVjdHMgbGluZWFyIHN0cmF0ZWd5IGZvciBvcmRlci0yIGdlbmVyYXRvcnMnLCAoKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGdyb3VwIHdpdGggb3JkZXItMiBlbGVtZW50c1xuICAgICAgICBjb25zdCB0ZXN0R3JvdXA6IEdyb3VwID0ge1xuICAgICAgICAgIG5hbWU6ICdUZXN0JyxcbiAgICAgICAgICBvcmRlcjogNCxcbiAgICAgICAgICBlbGVtZW50czogW1xuICAgICAgICAgICAgeyBpZDogJ2UnLCBsYWJlbDogJ2UnLCBvcmRlcjogMSwgaW52ZXJzZTogJ2UnLCBjb25qdWdhY3lDbGFzczogMCB9LFxuICAgICAgICAgICAgeyBpZDogJ2EnLCBsYWJlbDogJ2EnLCBvcmRlcjogMiwgaW52ZXJzZTogJ2EnLCBjb25qdWdhY3lDbGFzczogMSB9LFxuICAgICAgICAgICAgeyBpZDogJ2InLCBsYWJlbDogJ2InLCBvcmRlcjogMiwgaW52ZXJzZTogJ2InLCBjb25qdWdhY3lDbGFzczogMSB9LFxuICAgICAgICAgICAgeyBpZDogJ2FiJywgbGFiZWw6ICdhYicsIG9yZGVyOiAyLCBpbnZlcnNlOiAnYWInLCBjb25qdWdhY3lDbGFzczogMSB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBvcGVyYXRpb25zOiBuZXcgTWFwKCksXG4gICAgICAgICAgZ2VuZXJhdG9yczogWydhJywgJ2InXSxcbiAgICAgICAgICBpc0FiZWxpYW46IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dCh0ZXN0R3JvdXAsIFsnYScsICdiJ10pO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIHVzZSBsaW5lYXIgc3RyYXRlZ2llcyBmb3Igb3JkZXItMiBnZW5lcmF0b3JzXG4gICAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5zdHJhdGVneSkudG9CZSgnbGluZWFyJyk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVsxXS5zdHJhdGVneSkudG9CZSgnbGluZWFyJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgdXNlIGRpZmZlcmVudCBkaXJlY3Rpb25zXG4gICAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5kaXJlY3Rpb24pLnRvQmUoJ1gnKTtcbiAgICAgICAgZXhwZWN0KGxheW91dC5uZXN0aW5nU3RydWN0dXJlWzFdLmRpcmVjdGlvbikudG9CZSgnWScpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoJ3NlbGVjdHMgY2lyY3VsYXIgc3RyYXRlZ3kgZm9yIGhpZ2hlciBvcmRlciBjeWNsaWMgZ3JvdXBzJywgKCkgPT4ge1xuICAgICAgICAvLyBNb2NrIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yIHRvIHJldHVybiBudWxsIHRvIGZvcmNlIGFkdmFuY2VkIGxheW91dCBnZW5lcmF0aW9uXG4gICAgICAgIGplc3Quc3B5T24oU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IsICdnZXRTdGFuZGFyZExheW91dCcpLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChjeWNsaWNHcm91cDQsIFsnYSddKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChsYXlvdXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgXG4gICAgICAgIFN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yLmdldFN0YW5kYXJkTGF5b3V0Lm1vY2tSZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ05lc3RpbmcgU3RydWN0dXJlIENvbXB1dGF0aW9uJywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QoJ2NvbXB1dGVzIGNvcnJlY3QgbmVzdGluZyBsZXZlbHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBnZW5lcmF0b3JzID0gWydyJywgJ3MnXTtcbiAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChkaWhlZHJhbEdyb3VwMywgZ2VuZXJhdG9ycyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZSkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgXG4gICAgICBsYXlvdXQubmVzdGluZ1N0cnVjdHVyZS5mb3JFYWNoKChsZXZlbCwgaW5kZXgpID0+IHtcbiAgICAgICAgZXhwZWN0KGxldmVsLm5lc3RpbmdMZXZlbCkudG9CZShpbmRleCk7XG4gICAgICAgIGV4cGVjdChsZXZlbC5nZW5lcmF0b3IpLnRvQmUoZ2VuZXJhdG9yc1tpbmRleF0pO1xuICAgICAgICBleHBlY3QobGV2ZWwuc3ViZ3JvdXBFbGVtZW50cykudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkobGV2ZWwuc3ViZ3JvdXBFbGVtZW50cykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChsZXZlbC5zdWJncm91cEVsZW1lbnRzIS5pbmNsdWRlcygnZScpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdnZW5lcmF0ZXMgdmFsaWQgc3ViZ3JvdXAgZWxlbWVudHMgZm9yIGVhY2ggbGV2ZWwnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXA0LCBbJ2EnXSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN1Ymdyb3VwRWxlbWVudHMgPSBsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5zdWJncm91cEVsZW1lbnRzITtcbiAgICAgIGV4cGVjdChzdWJncm91cEVsZW1lbnRzKS50b0NvbnRhaW4oJ2UnKTtcbiAgICAgIGV4cGVjdChzdWJncm91cEVsZW1lbnRzKS50b0NvbnRhaW4oJ2EnKTtcbiAgICAgIGV4cGVjdChzdWJncm91cEVsZW1lbnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDEpO1xuICAgICAgXG4gICAgICAvLyBBbGwgc3ViZ3JvdXAgZWxlbWVudHMgc2hvdWxkIGJlIHZhbGlkIGdyb3VwIGVsZW1lbnRzXG4gICAgICBzdWJncm91cEVsZW1lbnRzLmZvckVhY2goZWxlbWVudElkID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGN5Y2xpY0dyb3VwNC5lbGVtZW50cy5maW5kKGUgPT4gZS5pZCA9PT0gZWxlbWVudElkKTtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ21haW50YWlucyBtYXRoZW1hdGljYWwgY29uc2lzdGVuY3kgaW4gbmVzdGluZycsICgpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChzeW1tZXRyaWNHcm91cDMsIFsnYScsICdiJ10pO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgbmVzdGluZyBsZXZlbHMgYXJlIHNlcXVlbnRpYWxcbiAgICAgIGxheW91dC5uZXN0aW5nU3RydWN0dXJlLmZvckVhY2goKGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QobGV2ZWwubmVzdGluZ0xldmVsKS50b0JlKGluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZWFjaCBsZXZlbCBoYXMgdmFsaWQgc3RyYXRlZ3kgYW5kIGRpcmVjdGlvblxuICAgICAgbGF5b3V0Lm5lc3RpbmdTdHJ1Y3R1cmUuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgIGV4cGVjdChbJ2xpbmVhcicsICdjaXJjdWxhcicsICdyb3RhdGVkJ10pLnRvQ29udGFpbihsZXZlbC5zdHJhdGVneSk7XG4gICAgICAgIGV4cGVjdChbJ1gnLCAnWScsICdaJywgJ1hZJywgJ1haJywgJ1laJ10pLnRvQ29udGFpbihsZXZlbC5kaXJlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCczRCBMYXlvdXQgUG9zaXRpb25pbmcnLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgnZ2VuZXJhdGVzIHZhbGlkIDNEIGNvb3JkaW5hdGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwNCwgWydhJ10sIHRydWUpO1xuICAgICAgXG4gICAgICBleHBlY3QobGF5b3V0LmlzM0QpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGN5Y2xpY0dyb3VwNC5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBsYXlvdXQucG9zaXRpb25zW2VsZW1lbnQuaWRdO1xuICAgICAgICBleHBlY3QocG9zLnopLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgcG9zLnopLnRvQmUoJ251bWJlcicpO1xuICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKHBvcy56ISkpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2FwcGxpZXMgWi1kaXJlY3Rpb24gbGluZWFyIGxheW91dCBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdGVzdCBzY2VuYXJpbyB0aGF0IHdvdWxkIHVzZSBaIGRpcmVjdGlvblxuICAgICAgY29uc3QgdGVzdEdyb3VwOiBHcm91cCA9IHtcbiAgICAgICAgbmFtZTogJ1Rlc3RaJyxcbiAgICAgICAgb3JkZXI6IDQsXG4gICAgICAgIGVsZW1lbnRzOiBbXG4gICAgICAgICAgeyBpZDogJ2UnLCBsYWJlbDogJ2UnLCBvcmRlcjogMSwgaW52ZXJzZTogJ2UnLCBjb25qdWdhY3lDbGFzczogMCB9LFxuICAgICAgICAgIHsgaWQ6ICdhJywgbGFiZWw6ICdhJywgb3JkZXI6IDIsIGludmVyc2U6ICdhJywgY29uanVnYWN5Q2xhc3M6IDEgfSxcbiAgICAgICAgICB7IGlkOiAnYicsIGxhYmVsOiAnYicsIG9yZGVyOiAyLCBpbnZlcnNlOiAnYicsIGNvbmp1Z2FjeUNsYXNzOiAxIH0sXG4gICAgICAgICAgeyBpZDogJ2MnLCBsYWJlbDogJ2MnLCBvcmRlcjogMiwgaW52ZXJzZTogJ2MnLCBjb25qdWdhY3lDbGFzczogMSB9XG4gICAgICAgIF0sXG4gICAgICAgIG9wZXJhdGlvbnM6IG5ldyBNYXAoKSxcbiAgICAgICAgZ2VuZXJhdG9yczogWydhJywgJ2InLCAnYyddLFxuICAgICAgICBpc0FiZWxpYW46IHRydWVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dCh0ZXN0R3JvdXAsIFsnYScsICdiJywgJ2MnXSwgdHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFRoaXJkIGdlbmVyYXRvciBzaG91bGQgdXNlIFogZGlyZWN0aW9uXG4gICAgICBleHBlY3QobGF5b3V0Lm5lc3RpbmdTdHJ1Y3R1cmVbMl0uZGlyZWN0aW9uKS50b0JlKCdaJyk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBaLWNvb3JkaW5hdGVzIHZhcnkgZm9yIGVsZW1lbnRzIHBvc2l0aW9uZWQgYnkgdGhpcmQgZ2VuZXJhdG9yXG4gICAgICBjb25zdCB6Q29vcmRzID0gdGVzdEdyb3VwLmVsZW1lbnRzLm1hcChlID0+IGxheW91dC5wb3NpdGlvbnNbZS5pZF0ueiEpO1xuICAgICAgY29uc3QgdW5pcXVlWkNvb3JkcyA9IFsuLi5uZXcgU2V0KHpDb29yZHMpXTtcbiAgICAgIGV4cGVjdCh1bmlxdWVaQ29vcmRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDEpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnYXBwbGllcyBYWiBhbmQgWVogY2lyY3VsYXIgbGF5b3V0cyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoZGloZWRyYWxHcm91cDMsIFsncicsICdzJ10sIHRydWUpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGF2ZSBzb21lIDNEIHBvc2l0aW9uaW5nXG4gICAgICBjb25zdCBoYXNOb25aZXJvWiA9IGRpaGVkcmFsR3JvdXAzLmVsZW1lbnRzLnNvbWUoZSA9PiBcbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uc1tlLmlkXS56ICE9PSB1bmRlZmluZWQgJiYgbGF5b3V0LnBvc2l0aW9uc1tlLmlkXS56ICE9PSAwXG4gICAgICApO1xuICAgICAgZXhwZWN0KGhhc05vblplcm9aKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTGF5b3V0IFN0cmF0ZWd5IEFwcGxpY2F0aW9uJywgKCkgPT4ge1xuICAgIFxuICAgIGRlc2NyaWJlKCdMaW5lYXIgTGF5b3V0JywgKCkgPT4ge1xuICAgICAgdGVzdCgnZGlzdHJpYnV0ZXMgZWxlbWVudHMgYWxvbmcgWC1heGlzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgICAgY29uc3QgdGVzdEdyb3VwOiBHcm91cCA9IHtcbiAgICAgICAgICBuYW1lOiAnTGluZWFyVGVzdCcsXG4gICAgICAgICAgb3JkZXI6IDMsXG4gICAgICAgICAgZWxlbWVudHM6IFtcbiAgICAgICAgICAgIHsgaWQ6ICdlJywgbGFiZWw6ICdlJywgb3JkZXI6IDEsIGludmVyc2U6ICdlJywgY29uanVnYWN5Q2xhc3M6IDAgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdhJywgbGFiZWw6ICdhJywgb3JkZXI6IDIsIGludmVyc2U6ICdhJywgY29uanVnYWN5Q2xhc3M6IDEgfSxcbiAgICAgICAgICAgIHsgaWQ6ICdiJywgbGFiZWw6ICdiJywgb3JkZXI6IDIsIGludmVyc2U6ICdiJywgY29uanVnYWN5Q2xhc3M6IDEgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgb3BlcmF0aW9uczogbmV3IE1hcCgpLFxuICAgICAgICAgIGdlbmVyYXRvcnM6IFsnYSddLFxuICAgICAgICAgIGlzQWJlbGlhbjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KHRlc3RHcm91cCwgWydhJ10pO1xuICAgICAgICBcbiAgICAgICAgLy8gRWxlbWVudHMgc2hvdWxkIGJlIGFsaWduZWQgYWxvbmcgWC1heGlzIHdpdGggY29uc3RhbnQgWVxuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBPYmplY3QudmFsdWVzKGxheW91dC5wb3NpdGlvbnMpO1xuICAgICAgICBjb25zdCB5Q29vcmRzID0gcG9zaXRpb25zLm1hcChwID0+IHAueSk7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVlDb29yZHMgPSBbLi4ubmV3IFNldCh5Q29vcmRzKV07XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgaGF2ZSBjb25zaXN0ZW50IFkgY29vcmRpbmF0ZSAoYWxsb3dpbmcgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbilcbiAgICAgICAgZXhwZWN0KHVuaXF1ZVlDb29yZHMubGVuZ3RoKS50b0JlTGVzc1RoYW5PckVxdWFsKDIpOyAvLyBJZGVudGl0eSBtaWdodCBiZSBhdCBjZW50ZXJcbiAgICAgICAgXG4gICAgICAgIC8vIFggY29vcmRpbmF0ZXMgc2hvdWxkIHZhcnlcbiAgICAgICAgY29uc3QgeENvb3JkcyA9IHBvc2l0aW9ucy5tYXAocCA9PiBwLngpO1xuICAgICAgICBjb25zdCB1bmlxdWVYQ29vcmRzID0gWy4uLm5ldyBTZXQoeENvb3JkcyldO1xuICAgICAgICBleHBlY3QodW5pcXVlWENvb3Jkcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigxKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KCdtYWludGFpbnMgZXF1YWwgc3BhY2luZyBpbiBsaW5lYXIgbGF5b3V0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXA0LCBbJ2EnXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgcG9zaXRpb25zIGluIG9yZGVyXG4gICAgICAgIGNvbnN0IG9yZGVyZWRQb3NpdGlvbnMgPSBjeWNsaWNHcm91cDQuZWxlbWVudHNcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKVxuICAgICAgICAgIC5tYXAoZSA9PiBsYXlvdXQucG9zaXRpb25zW2UuaWRdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzcGFjaW5nIGJldHdlZW4gYWRqYWNlbnQgZWxlbWVudHNcbiAgICAgICAgY29uc3Qgc3BhY2luZ3M6IG51bWJlcltdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3JkZXJlZFBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGR4ID0gb3JkZXJlZFBvc2l0aW9uc1tpXS54IC0gb3JkZXJlZFBvc2l0aW9uc1tpLTFdLng7XG4gICAgICAgICAgY29uc3QgZHkgPSBvcmRlcmVkUG9zaXRpb25zW2ldLnkgLSBvcmRlcmVkUG9zaXRpb25zW2ktMV0ueTtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICAgICAgICBzcGFjaW5ncy5wdXNoKGRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IHNwYWNpbmdzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsICh3aXRoaW4gdG9sZXJhbmNlKVxuICAgICAgICBpZiAoc3BhY2luZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IGF2Z1NwYWNpbmcgPSBzcGFjaW5ncy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHNwYWNpbmdzLmxlbmd0aDtcbiAgICAgICAgICBzcGFjaW5ncy5mb3JFYWNoKHNwYWNpbmcgPT4ge1xuICAgICAgICAgICAgZ2xvYmFsLnRlc3RVdGlscy5leHBlY3RNYXRoZW1hdGljYWxBY2N1cmFjeShzcGFjaW5nLCBhdmdTcGFjaW5nLCAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ2lyY3VsYXIgTGF5b3V0JywgKCkgPT4ge1xuICAgICAgdGVzdCgnYXJyYW5nZXMgZWxlbWVudHMgaW4gY2lyY3VsYXIgcGF0dGVybicsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwNCwgWydhJ10pO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIHVzZSBjaXJjdWxhciBsYXlvdXQgZm9yIEM0XG4gICAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5zdHJhdGVneSkudG9CZSgnY2lyY3VsYXInKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZXMgZnJvbSBjZW50ZXIgZm9yIGFsbCBlbGVtZW50c1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gMzAwOyAvLyBDYW52YXMgY2VudGVyXG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSAyMDA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBjeWNsaWNHcm91cDQuZWxlbWVudHMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHBvcyA9IGxheW91dC5wb3NpdGlvbnNbZWxlbWVudC5pZF07XG4gICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgocG9zLnggLSBjZW50ZXJYKSoqMiArIChwb3MueSAtIGNlbnRlclkpKioyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbGwgZWxlbWVudHMgKGV4Y2VwdCBwb3NzaWJseSBpZGVudGl0eSkgc2hvdWxkIGJlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9uSWRlbnRpdHlEaXN0YW5jZXMgPSBkaXN0YW5jZXMuZmlsdGVyKGQgPT4gZCA+IDEwKTsgLy8gRmlsdGVyIG91dCBpZGVudGl0eSBhdCBjZW50ZXJcbiAgICAgICAgaWYgKG5vbklkZW50aXR5RGlzdGFuY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBhdmdEaXN0YW5jZSA9IG5vbklkZW50aXR5RGlzdGFuY2VzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gbm9uSWRlbnRpdHlEaXN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgIG5vbklkZW50aXR5RGlzdGFuY2VzLmZvckVhY2goZGlzdGFuY2UgPT4ge1xuICAgICAgICAgICAgZ2xvYmFsLnRlc3RVdGlscy5leHBlY3RNYXRoZW1hdGljYWxBY2N1cmFjeShkaXN0YW5jZSwgYXZnRGlzdGFuY2UsIDUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGVzdCgnbWFpbnRhaW5zIGFuZ3VsYXIgc3ltbWV0cnkgaW4gY2lyY3VsYXIgbGF5b3V0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjZW50ZXJYID0gMzAwO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0gMjAwO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZ2xlcyBmb3IgYWxsIG5vbi1pZGVudGl0eSBlbGVtZW50c1xuICAgICAgICBjb25zdCBhbmdsZXMgPSBjeWNsaWNHcm91cDMuZWxlbWVudHNcbiAgICAgICAgICAuZmlsdGVyKGUgPT4gZS5pZCAhPT0gJ2UnKVxuICAgICAgICAgIC5tYXAoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBsYXlvdXQucG9zaXRpb25zW2VsZW1lbnQuaWRdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIocG9zLnkgLSBjZW50ZXJZLCBwb3MueCAtIGNlbnRlclgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFuZ2xlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZ3VsYXIgZGlmZmVyZW5jZXNcbiAgICAgICAgICBjb25zdCBzb3J0ZWRBbmdsZXMgPSBhbmdsZXMuc29ydCgpO1xuICAgICAgICAgIGNvbnN0IGFuZ3VsYXJEaWZmZXJlbmNlczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvcnRlZEFuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYW5ndWxhckRpZmZlcmVuY2VzLnB1c2goc29ydGVkQW5nbGVzW2ldIC0gc29ydGVkQW5nbGVzW2ktMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgd3JhcC1hcm91bmQgZGlmZmVyZW5jZVxuICAgICAgICAgIGFuZ3VsYXJEaWZmZXJlbmNlcy5wdXNoKDIgKiBNYXRoLlBJIC0gKHNvcnRlZEFuZ2xlc1tzb3J0ZWRBbmdsZXMubGVuZ3RoLTFdIC0gc29ydGVkQW5nbGVzWzBdKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxsIGFuZ3VsYXIgZGlmZmVyZW5jZXMgc2hvdWxkIGJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgICAgICBjb25zdCBleHBlY3RlZEFuZ2xlID0gMiAqIE1hdGguUEkgLyBhbmdsZXMubGVuZ3RoO1xuICAgICAgICAgIGFuZ3VsYXJEaWZmZXJlbmNlcy5mb3JFYWNoKGFuZ2xlID0+IHtcbiAgICAgICAgICAgIGdsb2JhbC50ZXN0VXRpbHMuZXhwZWN0TWF0aGVtYXRpY2FsQWNjdXJhY3koYW5nbGUsIGV4cGVjdGVkQW5nbGUsIDAuMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1JvdGF0ZWQgTGF5b3V0JywgKCkgPT4ge1xuICAgICAgdGVzdCgnYXBwbGllcyByb3RhdGlvbiBvZmZzZXQgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgICAvLyBDcmVhdGUgc2NlbmFyaW8gdGhhdCB1c2VzIHJvdGF0ZWQgbGF5b3V0XG4gICAgICAgIGNvbnN0IGNvbXBsZXhHcm91cDogR3JvdXAgPSB7XG4gICAgICAgICAgbmFtZTogJ0NvbXBsZXgnLFxuICAgICAgICAgIG9yZGVyOiA4LFxuICAgICAgICAgIGVsZW1lbnRzOiBBcnJheS5mcm9tKHtsZW5ndGg6IDh9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgICAgIGlkOiBgZyR7aX1gLFxuICAgICAgICAgICAgbGFiZWw6IGBnJHtpfWAsXG4gICAgICAgICAgICBvcmRlcjogaSA9PT0gMCA/IDEgOiA4LFxuICAgICAgICAgICAgaW52ZXJzZTogYGcke2l9YCxcbiAgICAgICAgICAgIGNvbmp1Z2FjeUNsYXNzOiBpXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIG9wZXJhdGlvbnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICBnZW5lcmF0b3JzOiBbJ2cxJ10sXG4gICAgICAgICAgaXNBYmVsaWFuOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGNvbXBsZXhHcm91cCwgWydnMSddKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBwb3NpdGlvbnMgYXJlIGdlbmVyYXRlZFxuICAgICAgICBjb21wbGV4R3JvdXAuZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBwb3MgPSBsYXlvdXQucG9zaXRpb25zW2VsZW1lbnQuaWRdO1xuICAgICAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUocG9zLngpKS50b0JlKHRydWUpO1xuICAgICAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUocG9zLnkpKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnR3JvdXAgU3RydWN0dXJlIEFuYWx5c2lzJywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QoJ2NvcnJlY3RseSBpZGVudGlmaWVzIGN5Y2xpYyBncm91cHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBkZXRlY3QgY3ljbGljIHN0cnVjdHVyZSBhbmQgdXNlIGFwcHJvcHJpYXRlIHN0cmF0ZWd5XG4gICAgICBleHBlY3QobGF5b3V0Lm5lc3RpbmdTdHJ1Y3R1cmUpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5zdHJhdGVneSkudG9NYXRjaCgvY2lyY3VsYXJ8bGluZWFyLyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdjb3JyZWN0bHkgaWRlbnRpZmllcyBkaWhlZHJhbCBncm91cHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoZGloZWRyYWxHcm91cDMsIFsncicsICdzJ10pO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGF2ZSB0d28gZ2VuZXJhdG9ycyBhbmQgYXBwcm9wcmlhdGUgc3RyYXRlZ2llc1xuICAgICAgZXhwZWN0KGxheW91dC5uZXN0aW5nU3RydWN0dXJlKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCB1c2Ugc3RyYXRlZ2llcyBhcHByb3ByaWF0ZSBmb3IgZGloZWRyYWwgc3RydWN0dXJlXG4gICAgICBjb25zdCBzdHJhdGVnaWVzID0gbGF5b3V0Lm5lc3RpbmdTdHJ1Y3R1cmUubWFwKGxldmVsID0+IGxldmVsLnN0cmF0ZWd5KTtcbiAgICAgIGV4cGVjdChzdHJhdGVnaWVzLnNvbWUocyA9PiBzID09PSAnY2lyY3VsYXInKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgYWJlbGlhbiBncm91cHMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGN5Y2xpY0dyb3VwMy5pc0FiZWxpYW4pLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoY3ljbGljR3JvdXA0LmlzQWJlbGlhbikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkaWhlZHJhbEdyb3VwMy5pc0FiZWxpYW4pLnRvQmUoZmFsc2UpO1xuICAgICAgXG4gICAgICBjb25zdCBjeWNsaWNMYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSk7XG4gICAgICBjb25zdCBkaWhlZHJhbExheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChkaWhlZHJhbEdyb3VwMywgWydyJywgJ3MnXSk7XG4gICAgICBcbiAgICAgIC8vIEJvdGggc2hvdWxkIGdlbmVyYXRlIHZhbGlkIGxheW91dHNcbiAgICAgIGV4cGVjdChjeWNsaWNMYXlvdXQucG9zaXRpb25zKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRpaGVkcmFsTGF5b3V0LnBvc2l0aW9ucykudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N0YW5kYXJkIExheW91dCBDb252ZXJzaW9uJywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QoJ2NvbnZlcnRzIHN0YW5kYXJkIGxheW91dCB0byBhZHZhbmNlZCBsYXlvdXQgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1N0YW5kYXJkTGF5b3V0ID0ge1xuICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICAnZSc6IHsgeDogMC41LCB5OiAwLjUgfSxcbiAgICAgICAgICAnYSc6IHsgeDogMC4zLCB5OiAwLjcgfSxcbiAgICAgICAgICAnYTInOiB7IHg6IDAuNywgeTogMC4zIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdNb2NrIHN0YW5kYXJkIGxheW91dCdcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGplc3Quc3B5T24oU3RhbmRhcmRMYXlvdXRHZW5lcmF0b3IsICdnZXRTdGFuZGFyZExheW91dCcpLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3RhbmRhcmRMYXlvdXQpO1xuICAgICAgXG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9uc1snZSddLngpLnRvQmUoMzAwKTsgLy8gMC41ICogNjAwXG4gICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9uc1snZSddLnkpLnRvQmUoMjAwKTsgLy8gMC41ICogNDAwXG4gICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9uc1snYSddLngpLnRvQmUoMTgwKTsgLy8gMC4zICogNjAwXG4gICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9uc1snYSddLnkpLnRvQmUoMjgwKTsgLy8gMC43ICogNDAwXG4gICAgICBleHBlY3QobGF5b3V0LmRlc2NyaXB0aW9uKS50b0JlKCdNb2NrIHN0YW5kYXJkIGxheW91dCcpO1xuICAgICAgZXhwZWN0KGxheW91dC5pczNEKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZSkudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgXG4gICAgICBTdGFuZGFyZExheW91dEdlbmVyYXRvci5nZXRTdGFuZGFyZExheW91dC5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWF0aGVtYXRpY2FsIEFjY3VyYWN5JywgKCkgPT4ge1xuICAgIFxuICAgIHRlc3QoJ21haW50YWlucyBtYXRoZW1hdGljYWwgcHJlY2lzaW9uIGluIGNvb3JkaW5hdGUgY2FsY3VsYXRpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwNCwgWydhJ10pO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgYWxsIGNvb3JkaW5hdGVzIGFyZSBmaW5pdGUgYW5kIHByZWNpc2VcbiAgICAgIGN5Y2xpY0dyb3VwNC5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBsYXlvdXQucG9zaXRpb25zW2VsZW1lbnQuaWRdO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KE51bWJlci5pc0Zpbml0ZShwb3MueCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChOdW1iZXIuaXNGaW5pdGUocG9zLnkpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoTnVtYmVyLmlzTmFOKHBvcy54KSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChOdW1iZXIuaXNOYU4ocG9zLnkpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvb3JkaW5hdGVzIHNob3VsZCBiZSByZWFzb25hYmxlICh3aXRoaW4gY2FudmFzIGJvdW5kcyArIHNvbWUgbWFyZ2luKVxuICAgICAgICBleHBlY3QocG9zLngpLnRvQmVHcmVhdGVyVGhhbigtMTAwKTtcbiAgICAgICAgZXhwZWN0KHBvcy54KS50b0JlTGVzc1RoYW4oNzAwKTtcbiAgICAgICAgZXhwZWN0KHBvcy55KS50b0JlR3JlYXRlclRoYW4oLTEwMCk7XG4gICAgICAgIGV4cGVjdChwb3MueSkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ21haW50YWlucyBncm91cC10aGVvcmV0aWMgY29uc2lzdGVuY3knLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSk7XG4gICAgICBcbiAgICAgIC8vIEFsbCBncm91cCBlbGVtZW50cyBzaG91bGQgaGF2ZSBwb3NpdGlvbnNcbiAgICAgIGN5Y2xpY0dyb3VwMy5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoZWxlbWVudC5pZCk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTnVtYmVyIG9mIHBvc2l0aW9uZWQgZWxlbWVudHMgc2hvdWxkIG1hdGNoIGdyb3VwIG9yZGVyXG4gICAgICBjb25zdCBwb3NpdGlvbmVkRWxlbWVudHMgPSBPYmplY3Qua2V5cyhsYXlvdXQucG9zaXRpb25zKTtcbiAgICAgIGV4cGVjdChwb3NpdGlvbmVkRWxlbWVudHMpLnRvSGF2ZUxlbmd0aChjeWNsaWNHcm91cDMub3JkZXIpO1xuICAgICAgXG4gICAgICAvLyBJZGVudGl0eSBzaG91bGQgYmUgcHJlc2VudFxuICAgICAgZXhwZWN0KGxheW91dC5wb3NpdGlvbnMpLnRvSGF2ZVByb3BlcnR5KCdlJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2YWxpZGF0ZXMgbGF5b3V0IG1hdGhlbWF0aWNhbCBwcm9wZXJ0aWVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwNCwgWydhJ10pO1xuICAgICAgXG4gICAgICAvLyBUZXN0IG1hdGhlbWF0aWNhbCBpbnZhcmlhbnRzXG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBPYmplY3QudmFsdWVzKGxheW91dC5wb3NpdGlvbnMpO1xuICAgICAgY29uc3QgeENvb3JkcyA9IHBvc2l0aW9ucy5tYXAocCA9PiBwLngpO1xuICAgICAgY29uc3QgeUNvb3JkcyA9IHBvc2l0aW9ucy5tYXAocCA9PiBwLnkpO1xuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBudW1lcmljYWwgc3RhYmlsaXR5XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gUHJlY2lzaW9uVmFsaWRhdG9yLnZhbGlkYXRlRmxvYXRpbmdQb2ludFN0YWJpbGl0eShbLi4ueENvb3JkcywgLi4ueUNvb3Jkc10pO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHJlYXNvbmFibGUgc3ByZWFkIChlbGVtZW50cyBzaG91bGRuJ3QgYWxsIGJlIGF0IHNhbWUgcG9pbnQpXG4gICAgICBjb25zdCB4UmFuZ2UgPSBNYXRoLm1heCguLi54Q29vcmRzKSAtIE1hdGgubWluKC4uLnhDb29yZHMpO1xuICAgICAgY29uc3QgeVJhbmdlID0gTWF0aC5tYXgoLi4ueUNvb3JkcykgLSBNYXRoLm1pbiguLi55Q29vcmRzKTtcbiAgICAgIGV4cGVjdCh4UmFuZ2UgKyB5UmFuZ2UpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgnbGF5b3V0IGdlbmVyYXRpb24gY29tcGxldGVzIHdpdGhpbiB0aW1lIGJvdW5kcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCBkdXJhdGlvbiB9ID0gZ2xvYmFsLnRlc3RVdGlscy5leHBlY3RQZXJmb3JtYW5jZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoc3ltbWV0cmljR3JvdXAzLCBbJ2EnLCAnYiddKTtcbiAgICAgIH0sIDUwMCk7IC8vIDUwMG1zIG1heFxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wb3NpdGlvbnMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBjb25zb2xlLmxvZyhgTGF5b3V0IGdlbmVyYXRpb24gY29tcGxldGVkIGluICR7ZHVyYXRpb24udG9GaXhlZCgyKX1tc2ApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnbWVtb3J5IHVzYWdlIGlzIHJlYXNvbmFibGUgZm9yIGxheW91dCBnZW5lcmF0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQsIG1lbW9yeUluY3JlYXNlIH0gPSBnbG9iYWwudGVzdFV0aWxzLmV4cGVjdE1lbW9yeVVzYWdlKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChzeW1tZXRyaWNHcm91cDMsIFsnYScsICdiJ10pO1xuICAgICAgfSwgMTApOyAvLyAxME1CIG1heCBpbmNyZWFzZVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgY29uc29sZS5sb2coYE1lbW9yeSBpbmNyZWFzZTogJHttZW1vcnlJbmNyZWFzZS50b0ZpeGVkKDIpfU1CYCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzY2FsZXMgYXBwcm9wcmlhdGVseSB3aXRoIGdyb3VwIHNpemUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0aW1lczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGNvbnN0IGdyb3VwcyA9IFtjeWNsaWNHcm91cDMsIGN5Y2xpY0dyb3VwNCwgc3ltbWV0cmljR3JvdXAzXTtcbiAgICAgIFxuICAgICAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGdyb3VwLCBncm91cC5nZW5lcmF0b3JzKTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aW1lcy5wdXNoKGVuZFRpbWUgLSBzdGFydFRpbWUpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFBlcmZvcm1hbmNlIHNob3VsZCBzY2FsZSByZWFzb25hYmx5IChub3QgZXhwb25lbnRpYWxseSlcbiAgICAgIHRpbWVzLmZvckVhY2godGltZSA9PiB7XG4gICAgICAgIGV4cGVjdCh0aW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIDEgc2Vjb25kIG1heCBmb3IgdGVzdCBncm91cHNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU2NhbGluZyB0aW1lczonLCB0aW1lcy5tYXAodCA9PiBgJHt0LnRvRml4ZWQoMil9bXNgKSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdkZXRlcm1pbmlzdGljIGJlaGF2aW9yIGZvciBzYW1lIGlucHV0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dDEgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSk7XG4gICAgICBjb25zdCBsYXlvdXQyID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwMywgWydhJ10pO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgcHJvZHVjZSBpZGVudGljYWwgcmVzdWx0c1xuICAgICAgZXhwZWN0KGxheW91dDEucG9zaXRpb25zKS50b0VxdWFsKGxheW91dDIucG9zaXRpb25zKTtcbiAgICAgIGV4cGVjdChsYXlvdXQxLm5lc3RpbmdTdHJ1Y3R1cmUpLnRvRXF1YWwobGF5b3V0Mi5uZXN0aW5nU3RydWN0dXJlKTtcbiAgICAgIGV4cGVjdChsYXlvdXQxLmRlc2NyaXB0aW9uKS50b0JlKGxheW91dDIuZGVzY3JpcHRpb24pO1xuICAgICAgZXhwZWN0KGxheW91dDEuaXMzRCkudG9CZShsYXlvdXQyLmlzM0QpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICBcbiAgICB0ZXN0KCdoYW5kbGVzIGVtcHR5IGdlbmVyYXRvcnMgYXJyYXknLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbXSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChsYXlvdXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9ucykudG9CZURlZmluZWQoKTtcbiAgICAgIC8vIFNob3VsZCBzdGlsbCBwb3NpdGlvbiBhbGwgZWxlbWVudHMgc29tZWhvd1xuICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKGxheW91dC5wb3NpdGlvbnMpKS50b0hhdmVMZW5ndGgoY3ljbGljR3JvdXAzLm9yZGVyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgaW52YWxpZCBnZW5lcmF0b3IgbmFtZXMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChjeWNsaWNHcm91cDMsIFsnaW52YWxpZCddKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGxheW91dCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChsYXlvdXQucG9zaXRpb25zKS50b0JlRGVmaW5lZCgpO1xuICAgICAgLy8gU2hvdWxkIG5vdCBjcmFzaCwgYnV0IG1heSBoYXZlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgZ3JvdXBzIHdpdGggc2luZ2xlIGVsZW1lbnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQodHJpdmlhbEdyb3VwLCBbXSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChsYXlvdXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobGF5b3V0LnBvc2l0aW9ucykudG9IYXZlUHJvcGVydHkoJ2UnKTtcbiAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KGxheW91dC5kZXNjcmlwdGlvbikudG9Db250YWluKCdUcml2aWFsIGdyb3VwJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGxhcmdlIG51bWJlciBvZiBnZW5lcmF0b3JzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFueUdlbmVyYXRvcnMgPSBBcnJheS5mcm9tKHtsZW5ndGg6IDEwfSwgKF8sIGkpID0+IGBnJHtpfWApO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IGNyYXNoIGV2ZW4gd2l0aCBtYW55IGdlbmVyYXRvcnNcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChjeWNsaWNHcm91cDMsIG1hbnlHZW5lcmF0b3JzKTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIGV4dHJlbWUgY29vcmRpbmF0ZSB2YWx1ZXMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dCA9IEFkdmFuY2VkTGF5b3V0RW5naW5lLmdlbmVyYXRlT3B0aW1hbExheW91dChjeWNsaWNHcm91cDQsIFsnYSddLCB0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNvb3JkaW5hdGVzIGFyZSBub3QgZXh0cmVtZVxuICAgICAgY3ljbGljR3JvdXA0LmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGxheW91dC5wb3NpdGlvbnNbZWxlbWVudC5pZF07XG4gICAgICAgIGV4cGVjdChNYXRoLmFicyhwb3MueCkpLnRvQmVMZXNzVGhhbigxZTYpO1xuICAgICAgICBleHBlY3QoTWF0aC5hYnMocG9zLnkpKS50b0JlTGVzc1RoYW4oMWU2KTtcbiAgICAgICAgaWYgKHBvcy56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleHBlY3QoTWF0aC5hYnMocG9zLnopKS50b0JlTGVzc1RoYW4oMWU2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhdGlvbiB3aXRoIEdyb3VwIFRoZW9yeScsICgpID0+IHtcbiAgICBcbiAgICB0ZXN0KCdyZXNwZWN0cyBncm91cCBzdHJ1Y3R1cmUgaW4gbGF5b3V0JywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwMywgWydhJ10pO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgYWxsIGdyb3VwIGVsZW1lbnRzIGFyZSByZXByZXNlbnRlZFxuICAgICAgY29uc3QgbGF5b3V0RWxlbWVudElkcyA9IE9iamVjdC5rZXlzKGxheW91dC5wb3NpdGlvbnMpO1xuICAgICAgY29uc3QgZ3JvdXBFbGVtZW50SWRzID0gY3ljbGljR3JvdXAzLmVsZW1lbnRzLm1hcChlID0+IGUuaWQpO1xuICAgICAgXG4gICAgICBleHBlY3QobGF5b3V0RWxlbWVudElkcy5zb3J0KCkpLnRvRXF1YWwoZ3JvdXBFbGVtZW50SWRzLnNvcnQoKSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCd2YWxpZGF0ZXMgYWdhaW5zdCBncm91cCBheGlvbXMnLCAoKSA9PiB7XG4gICAgICAvLyBWZXJpZnkgb3VyIHRlc3QgZ3JvdXBzIGFyZSBtYXRoZW1hdGljYWxseSB2YWxpZFxuICAgICAgW2N5Y2xpY0dyb3VwMywgY3ljbGljR3JvdXA0LCBkaWhlZHJhbEdyb3VwMywgc3ltbWV0cmljR3JvdXAzLCB0cml2aWFsR3JvdXBdLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgICBleHBlY3QoZ3JvdXApLnRvQmVWYWxpZEdyb3VwKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ21haW50YWlucyBnZW5lcmF0b3IgcmVsYXRpb25zaGlwcyBpbiBsYXlvdXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXA0LCBbJ2EnXSk7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRvciBzaG91bGQgYmUgaW5jbHVkZWQgaW4gbmVzdGluZyBzdHJ1Y3R1cmVcbiAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5nZW5lcmF0b3IpLnRvQmUoJ2EnKTtcbiAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5zdWJncm91cEVsZW1lbnRzKS50b0NvbnRhaW4oJ2EnKTtcbiAgICAgIGV4cGVjdChsYXlvdXQubmVzdGluZ1N0cnVjdHVyZVswXS5zdWJncm91cEVsZW1lbnRzKS50b0NvbnRhaW4oJ2UnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xheW91dCBRdWFsaXR5IE1ldHJpY3MnLCAoKSA9PiB7XG4gICAgXG4gICAgdGVzdCgnbWluaW1pemVzIGVkZ2UgY3Jvc3NpbmdzIGluIHBsYW5hciBsYXlvdXRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGF5b3V0ID0gQWR2YW5jZWRMYXlvdXRFbmdpbmUuZ2VuZXJhdGVPcHRpbWFsTGF5b3V0KGN5Y2xpY0dyb3VwNCwgWydhJ10pO1xuICAgICAgXG4gICAgICAvLyBGb3IgY3ljbGljIGdyb3VwcywgY2lyY3VsYXIgbGF5b3V0IHNob3VsZCBtaW5pbWl6ZSBjcm9zc2luZ3NcbiAgICAgIC8vIFZlcmlmeSBlbGVtZW50cyBhcmUgcG9zaXRpb25lZCB0byBmb3JtIGEgcmVhc29uYWJsZSBncmFwaFxuICAgICAgY29uc3QgcG9zaXRpb25zID0gbGF5b3V0LnBvc2l0aW9ucztcbiAgICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIGFueSB0d28gZWxlbWVudHNcbiAgICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50SWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGVsZW1lbnRJZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBwb3MxID0gcG9zaXRpb25zW2VsZW1lbnRJZHNbaV1dO1xuICAgICAgICAgIGNvbnN0IHBvczIgPSBwb3NpdGlvbnNbZWxlbWVudElkc1tqXV07XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoKHBvczEueCAtIHBvczIueCkqKjIgKyAocG9zMS55IC0gcG9zMi55KSoqMik7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1pbihtaW5EaXN0YW5jZSwgZGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEVsZW1lbnRzIHNob3VsZG4ndCBiZSB0b28gY2xvc2UgKG92ZXJsYXApIG9yIHRvbyBmYXIgYXBhcnRcbiAgICAgIGV4cGVjdChtaW5EaXN0YW5jZSkudG9CZUdyZWF0ZXJUaGFuKDUpO1xuICAgICAgZXhwZWN0KG1pbkRpc3RhbmNlKS50b0JlTGVzc1RoYW4oMjAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ21haW50YWlucyB2aXN1YWwgYmFsYW5jZSBpbiBsYXlvdXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoY3ljbGljR3JvdXAzLCBbJ2EnXSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBjZW50ZXIgb2YgbWFzcyBvZiBhbGwgcG9zaXRpb25lZCBlbGVtZW50c1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gT2JqZWN0LnZhbHVlcyhsYXlvdXQucG9zaXRpb25zKTtcbiAgICAgIGNvbnN0IGNlbnRlclggPSBwb3NpdGlvbnMucmVkdWNlKChzdW0sIHBvcykgPT4gc3VtICsgcG9zLngsIDApIC8gcG9zaXRpb25zLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBwb3NpdGlvbnMucmVkdWNlKChzdW0sIHBvcykgPT4gc3VtICsgcG9zLnksIDApIC8gcG9zaXRpb25zLmxlbmd0aDtcbiAgICAgIFxuICAgICAgLy8gQ2VudGVyIG9mIG1hc3Mgc2hvdWxkIGJlIHJlYXNvbmFibHkgY2xvc2UgdG8gY2FudmFzIGNlbnRlclxuICAgICAgY29uc3QgY2FudmFzQ2VudGVyWCA9IDMwMDtcbiAgICAgIGNvbnN0IGNhbnZhc0NlbnRlclkgPSAyMDA7XG4gICAgICBcbiAgICAgIGV4cGVjdChNYXRoLmFicyhjZW50ZXJYIC0gY2FudmFzQ2VudGVyWCkpLnRvQmVMZXNzVGhhbigxMDApO1xuICAgICAgZXhwZWN0KE1hdGguYWJzKGNlbnRlclkgLSBjYW52YXNDZW50ZXJZKSkudG9CZUxlc3NUaGFuKDEwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdvcHRpbWl6ZXMgc3BhY2UgdXRpbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBBZHZhbmNlZExheW91dEVuZ2luZS5nZW5lcmF0ZU9wdGltYWxMYXlvdXQoc3ltbWV0cmljR3JvdXAzLCBbJ2EnLCAnYiddKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhbGwgZWxlbWVudHNcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IE9iamVjdC52YWx1ZXMobGF5b3V0LnBvc2l0aW9ucyk7XG4gICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4oLi4ucG9zaXRpb25zLm1hcChwID0+IHAueCkpO1xuICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KC4uLnBvc2l0aW9ucy5tYXAocCA9PiBwLngpKTtcbiAgICAgIGNvbnN0IG1pblkgPSBNYXRoLm1pbiguLi5wb3NpdGlvbnMubWFwKHAgPT4gcC55KSk7XG4gICAgICBjb25zdCBtYXhZID0gTWF0aC5tYXgoLi4ucG9zaXRpb25zLm1hcChwID0+IHAueSkpO1xuICAgICAgXG4gICAgICBjb25zdCB3aWR0aCA9IG1heFggLSBtaW5YO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG4gICAgICBcbiAgICAgIC8vIExheW91dCBzaG91bGQgdXNlIHJlYXNvbmFibGUgcG9ydGlvbiBvZiBjYW52YXMgc3BhY2VcbiAgICAgIGV4cGVjdCh3aWR0aCkudG9CZUdyZWF0ZXJUaGFuKDUwKTsgLy8gTm90IHRvbyBjcmFtcGVkXG4gICAgICBleHBlY3QoaGVpZ2h0KS50b0JlR3JlYXRlclRoYW4oNTApO1xuICAgICAgZXhwZWN0KHdpZHRoKS50b0JlTGVzc1RoYW4oNjAwKTsgLy8gTm90IGV4Y2VlZGluZyBjYW52YXNcbiAgICAgIGV4cGVjdChoZWlnaHQpLnRvQmVMZXNzVGhhbig0MDApO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJleHBlY3QiLCJleHRlbmQiLCJtYXRoZW1hdGljYWxNYXRjaGVycyIsImRlc2NyaWJlIiwiY3ljbGljR3JvdXAzIiwiY3ljbGljR3JvdXA0IiwiZGloZWRyYWxHcm91cDMiLCJzeW1tZXRyaWNHcm91cDMiLCJ0cml2aWFsR3JvdXAiLCJiZWZvcmVBbGwiLCJHcm91cERhdGFiYXNlIiwiZ2V0R3JvdXAiLCJ0ZXN0IiwibGF5b3V0IiwiQWR2YW5jZWRMYXlvdXRFbmdpbmUiLCJnZW5lcmF0ZU9wdGltYWxMYXlvdXQiLCJ0b0JlRGVmaW5lZCIsInBvc2l0aW9ucyIsInRvSGF2ZVByb3BlcnR5IiwiaXMzRCIsInRvQmUiLCJwb3NpdGlvbiIsIngiLCJ5IiwieiIsInRvQmVVbmRlZmluZWQiLCJnZW5lcmF0b3JzIiwibGVuZ3RoIiwiZWxlbWVudHMiLCJmb3JFYWNoIiwiZWxlbWVudCIsImlkIiwicG9zIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJtb2NrU3RhbmRhcmRMYXlvdXQiLCJkZXNjcmlwdGlvbiIsImplc3QiLCJzcHlPbiIsIlN0YW5kYXJkTGF5b3V0R2VuZXJhdG9yIiwibW9ja1JldHVyblZhbHVlIiwiZ2V0U3RhbmRhcmRMYXlvdXQiLCJtb2NrUmVzdG9yZSIsInRlc3RHcm91cCIsIm5hbWUiLCJvcmRlciIsImxhYmVsIiwiaW52ZXJzZSIsImNvbmp1Z2FjeUNsYXNzIiwib3BlcmF0aW9ucyIsIk1hcCIsImlzQWJlbGlhbiIsIm5lc3RpbmdTdHJ1Y3R1cmUiLCJzdHJhdGVneSIsImRpcmVjdGlvbiIsInRvQmVHcmVhdGVyVGhhbiIsInRvSGF2ZUxlbmd0aCIsImxldmVsIiwiaW5kZXgiLCJuZXN0aW5nTGV2ZWwiLCJnZW5lcmF0b3IiLCJzdWJncm91cEVsZW1lbnRzIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5jbHVkZXMiLCJ0b0NvbnRhaW4iLCJlbGVtZW50SWQiLCJmaW5kIiwiZSIsInpDb29yZHMiLCJtYXAiLCJ1bmlxdWVaQ29vcmRzIiwiU2V0IiwiaGFzTm9uWmVyb1oiLCJzb21lIiwidW5kZWZpbmVkIiwiT2JqZWN0IiwidmFsdWVzIiwieUNvb3JkcyIsInAiLCJ1bmlxdWVZQ29vcmRzIiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsInhDb29yZHMiLCJ1bmlxdWVYQ29vcmRzIiwib3JkZXJlZFBvc2l0aW9ucyIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJzcGFjaW5ncyIsImkiLCJkeCIsImR5IiwiZGlzdGFuY2UiLCJNYXRoIiwic3FydCIsInB1c2giLCJhdmdTcGFjaW5nIiwicmVkdWNlIiwic3BhY2luZyIsImdsb2JhbCIsInRlc3RVdGlscyIsImV4cGVjdE1hdGhlbWF0aWNhbEFjY3VyYWN5IiwiY2VudGVyWCIsImNlbnRlclkiLCJkaXN0YW5jZXMiLCJub25JZGVudGl0eURpc3RhbmNlcyIsImZpbHRlciIsImQiLCJhdmdEaXN0YW5jZSIsImFuZ2xlcyIsImF0YW4yIiwic29ydGVkQW5nbGVzIiwiYW5ndWxhckRpZmZlcmVuY2VzIiwiUEkiLCJleHBlY3RlZEFuZ2xlIiwiYW5nbGUiLCJjb21wbGV4R3JvdXAiLCJmcm9tIiwiXyIsInRvTWF0Y2giLCJzdHJhdGVnaWVzIiwicyIsImN5Y2xpY0xheW91dCIsImRpaGVkcmFsTGF5b3V0IiwiaXNOYU4iLCJ0b0JlTGVzc1RoYW4iLCJwb3NpdGlvbmVkRWxlbWVudHMiLCJrZXlzIiwidmFsaWRhdGlvbiIsIlByZWNpc2lvblZhbGlkYXRvciIsInZhbGlkYXRlRmxvYXRpbmdQb2ludFN0YWJpbGl0eSIsImlzVmFsaWQiLCJ4UmFuZ2UiLCJtYXgiLCJtaW4iLCJ5UmFuZ2UiLCJyZXN1bHQiLCJkdXJhdGlvbiIsImV4cGVjdFBlcmZvcm1hbmNlIiwiY29uc29sZSIsImxvZyIsInRvRml4ZWQiLCJtZW1vcnlJbmNyZWFzZSIsImV4cGVjdE1lbW9yeVVzYWdlIiwidGltZXMiLCJncm91cHMiLCJncm91cCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZW5kVGltZSIsInRpbWUiLCJ0IiwibGF5b3V0MSIsImxheW91dDIiLCJ0b0VxdWFsIiwibWFueUdlbmVyYXRvcnMiLCJub3QiLCJ0b1Rocm93IiwiYWJzIiwibGF5b3V0RWxlbWVudElkcyIsImdyb3VwRWxlbWVudElkcyIsInRvQmVWYWxpZEdyb3VwIiwiZWxlbWVudElkcyIsIm1pbkRpc3RhbmNlIiwiSW5maW5pdHkiLCJqIiwicG9zMSIsInBvczIiLCJzdW0iLCJjYW52YXNDZW50ZXJYIiwiY2FudmFzQ2VudGVyWSIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJ3aWR0aCIsImhlaWdodCJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDOzs7O3NDQVFNOytCQUd1QjtpQ0FDVTt3Q0FTakM7QUFFUCx1QkFBdUI7QUFDdkJBLE9BQU9DLE1BQU0sQ0FBQ0MsNENBQW9CO0FBRWxDQyxTQUFTLHdCQUF3QjtJQUUvQixrQkFBa0I7SUFDbEIsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUVKQyxVQUFVO1FBQ1IscUNBQXFDO1FBQ3JDTCxlQUFlTSw0QkFBYSxDQUFDQyxRQUFRLENBQUM7UUFDdENOLGVBQWVLLDRCQUFhLENBQUNDLFFBQVEsQ0FBQztRQUN0Q0wsaUJBQWlCSSw0QkFBYSxDQUFDQyxRQUFRLENBQUM7UUFDeENKLGtCQUFrQkcsNEJBQWEsQ0FBQ0MsUUFBUSxDQUFDO1FBRXpDLGtDQUFrQztR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