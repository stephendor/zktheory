{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/__tests__/lib/EllipticCurveGroup.test.ts"],"sourcesContent":["/**\n * Comprehensive Jest Unit Tests for Elliptic Curve Groups\n * Tests mathematical accuracy, group properties, and arithmetic operations\n */\n\nimport {\n  EllipticCurveArithmetic,\n  EllipticCurveGroupGenerator,\n  EllipticCurveAnimator,\n  type EllipticCurve,\n  type EllipticCurvePoint,\n  type EllipticCurveGroup,\n  type PointAdditionAnimation\n} from '@/lib/EllipticCurveGroups';\nimport { \n  mathematicalMatchers,\n  MATHEMATICAL_PRECISION,\n  EllipticCurveValidator,\n  ValidationResult,\n  aggregateValidationResults\n} from '../utils/mathematicalValidation';\n\n// Extend Jest matchers\nexpect.extend(mathematicalMatchers);\n\ndescribe('EllipticCurveArithmetic', () => {\n  \n  describe('Modular Arithmetic Operations', () => {\n    \n    test('calculates modular inverse correctly', () => {\n      expect(EllipticCurveArithmetic.modInverse(3, 7)).toBe(5); // 3 * 5 ≡ 1 (mod 7)\n      expect(EllipticCurveArithmetic.modInverse(2, 5)).toBe(3); // 2 * 3 ≡ 1 (mod 5)\n      expect(EllipticCurveArithmetic.modInverse(7, 11)).toBe(8); // 7 * 8 ≡ 1 (mod 11)\n    });\n    \n    test('throws error for invalid modular inverse inputs', () => {\n      expect(() => EllipticCurveArithmetic.modInverse(0, 5)).toThrow('Cannot find inverse of 0');\n      expect(() => EllipticCurveArithmetic.modInverse(3, 0)).toThrow('Modulus must be positive');\n      expect(() => EllipticCurveArithmetic.modInverse(6, 9)).toThrow('does not exist'); // gcd(6,9) = 3 ≠ 1\n    });\n    \n    test('calculates modular exponentiation correctly', () => {\n      expect(EllipticCurveArithmetic.modPow(2, 3, 5)).toBe(3); // 2³ ≡ 3 (mod 5)\n      expect(EllipticCurveArithmetic.modPow(3, 4, 7)).toBe(4); // 3⁴ ≡ 4 (mod 7)\n      expect(EllipticCurveArithmetic.modPow(5, 0, 13)).toBe(1); // x⁰ ≡ 1 (mod n)\n    });\n    \n    test('handles edge cases in modular operations', () => {\n      expect(EllipticCurveArithmetic.modPow(0, 5, 7)).toBe(0);\n      expect(EllipticCurveArithmetic.modPow(1, 100, 13)).toBe(1);\n      expect(EllipticCurveArithmetic.modInverse(-2, 7)).toBe(3); // -2 ≡ 5 (mod 7), 5⁻¹ ≡ 3\n    });\n  });\n\n  describe('Point Validation', () => {\n    const testCurve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    test('validates points on curve correctly', () => {\n      const validPoint: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      const invalidPoint: EllipticCurvePoint = { x: 1, y: 1, isIdentity: false };\n      const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n\n      expect(EllipticCurveArithmetic.isOnCurve(validPoint, testCurve)).toBe(true);\n      expect(EllipticCurveArithmetic.isOnCurve(invalidPoint, testCurve)).toBe(false);\n      expect(EllipticCurveArithmetic.isOnCurve(identityPoint, testCurve)).toBe(true);\n    });\n\n    test('validates identity point handling', () => {\n      const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      expect(EllipticCurveArithmetic.isOnCurve(identityPoint, testCurve)).toBe(true);\n      \n      // Test malformed identity points\n      const malformedIdentity1: EllipticCurvePoint = { x: 5, y: null, isIdentity: true };\n      const malformedIdentity2: EllipticCurvePoint = { x: null, y: 3, isIdentity: true };\n      \n      expect(EllipticCurveArithmetic.isOnCurve(malformedIdentity1, testCurve)).toBe(true);\n      expect(EllipticCurveArithmetic.isOnCurve(malformedIdentity2, testCurve)).toBe(true);\n    });\n\n    test('validates points using mathematical validation framework', () => {\n      const validPoint: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      expect(validPoint).toBeValidEllipticCurvePoint(testCurve);\n      \n      const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      expect(identityPoint).toBeValidEllipticCurvePoint(testCurve);\n    });\n  });\n\n  describe('Point Addition', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n    const point1: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n    const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n\n    test('handles identity element correctly', () => {\n      const result1 = EllipticCurveArithmetic.addPoints(identityPoint, point1, curve);\n      const result2 = EllipticCurveArithmetic.addPoints(point1, identityPoint, curve);\n      \n      expect(result1).toEqual(point1);\n      expect(result2).toEqual(point1);\n      expect(result1).toBeValidEllipticCurvePoint(curve);\n      expect(result2).toBeValidEllipticCurvePoint(curve);\n    });\n\n    test('adds distinct points correctly', () => {\n      const result = EllipticCurveArithmetic.addPoints(point1, point2, curve);\n      \n      expect(result.isIdentity).toBe(false);\n      expect(result).toBeValidEllipticCurvePoint(curve);\n      expect(EllipticCurveArithmetic.isOnCurve(result, curve)).toBe(true);\n    });\n\n    test('handles point doubling', () => {\n      const result = EllipticCurveArithmetic.addPoints(point1, point1, curve);\n      \n      expect(result).toBeValidEllipticCurvePoint(curve);\n      expect(EllipticCurveArithmetic.isOnCurve(result, curve)).toBe(true);\n    });\n\n    test('handles inverse points correctly', () => {\n      const point: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      const inversePoint: EllipticCurvePoint = { x: 0, y: 4, isIdentity: false }; // -1 ≡ 4 (mod 5)\n      \n      const result = EllipticCurveArithmetic.addPoints(point, inversePoint, curve);\n      \n      expect(result.isIdentity).toBe(true);\n      expect(result.x).toBeNull();\n      expect(result.y).toBeNull();\n    });\n\n    test('handles vertical tangent case', () => {\n      // Find a point where doubling gives identity (has order 2)\n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const orderTwoPoint = points.find(p => \n        !p.isIdentity && \n        EllipticCurveArithmetic.getPointOrder(p, curve) === 2\n      );\n      \n      if (orderTwoPoint) {\n        const result = EllipticCurveArithmetic.addPoints(orderTwoPoint, orderTwoPoint, curve);\n        expect(result.isIdentity).toBe(true);\n      }\n    });\n\n    test('validates group law properties', () => {\n      const points = [\n        identityPoint,\n        point1,\n        point2,\n        { x: 3, y: 0, isIdentity: false }\n      ].filter(p => EllipticCurveArithmetic.isOnCurve(p, curve));\n\n      // Test associativity: (P + Q) + R = P + (Q + R)\n      for (let i = 0; i < points.length && i < 3; i++) {\n        for (let j = 0; j < points.length && j < 3; j++) {\n          for (let k = 0; k < points.length && k < 3; k++) {\n            const p = points[i];\n            const q = points[j];\n            const r = points[k];\n\n            const left = EllipticCurveArithmetic.addPoints(\n              EllipticCurveArithmetic.addPoints(p, q, curve),\n              r,\n              curve\n            );\n            const right = EllipticCurveArithmetic.addPoints(\n              p,\n              EllipticCurveArithmetic.addPoints(q, r, curve),\n              curve\n            );\n\n            expect(left.isIdentity).toBe(right.isIdentity);\n            if (!left.isIdentity && !right.isIdentity) {\n              expect(left.x).toBe(right.x);\n              expect(left.y).toBe(right.y);\n            }\n          }\n        }\n      }\n    });\n\n    test('validates commutativity: P + Q = Q + P', () => {\n      const result1 = EllipticCurveArithmetic.addPoints(point1, point2, curve);\n      const result2 = EllipticCurveArithmetic.addPoints(point2, point1, curve);\n      \n      expect(result1.isIdentity).toBe(result2.isIdentity);\n      if (!result1.isIdentity) {\n        expect(result1.x).toBe(result2.x);\n        expect(result1.y).toBe(result2.y);\n      }\n    });\n  });\n\n  describe('Scalar Multiplication', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    const basePoint: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n\n    test('handles scalar multiplication edge cases', () => {\n      const result0 = EllipticCurveArithmetic.scalarMultiply(basePoint, 0, curve);\n      const result1 = EllipticCurveArithmetic.scalarMultiply(basePoint, 1, curve);\n      \n      expect(result0.isIdentity).toBe(true);\n      expect(result1).toEqual(basePoint);\n    });\n\n    test('performs scalar multiplication correctly', () => {\n      const result2 = EllipticCurveArithmetic.scalarMultiply(basePoint, 2, curve);\n      const result3 = EllipticCurveArithmetic.scalarMultiply(basePoint, 3, curve);\n      \n      // 2P should equal P + P\n      const doubling = EllipticCurveArithmetic.addPoints(basePoint, basePoint, curve);\n      expect(result2).toEqual(doubling);\n      \n      // Results should be on curve\n      expect(result2).toBeValidEllipticCurvePoint(curve);\n      expect(result3).toBeValidEllipticCurvePoint(curve);\n    });\n\n    test('validates distributive property: k(P + Q) = kP + kQ', () => {\n      const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n      const k = 3;\n      \n      if (EllipticCurveArithmetic.isOnCurve(point2, curve)) {\n        const sum = EllipticCurveArithmetic.addPoints(basePoint, point2, curve);\n        const left = EllipticCurveArithmetic.scalarMultiply(sum, k, curve);\n        \n        const kP = EllipticCurveArithmetic.scalarMultiply(basePoint, k, curve);\n        const kQ = EllipticCurveArithmetic.scalarMultiply(point2, k, curve);\n        const right = EllipticCurveArithmetic.addPoints(kP, kQ, curve);\n        \n        expect(left.isIdentity).toBe(right.isIdentity);\n        if (!left.isIdentity) {\n          expect(left.x).toBe(right.x);\n          expect(left.y).toBe(right.y);\n        }\n      }\n    });\n\n    test('handles identity point in scalar multiplication', () => {\n      const identity: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      const result = EllipticCurveArithmetic.scalarMultiply(identity, 5, curve);\n      \n      expect(result.isIdentity).toBe(true);\n    });\n  });\n\n  describe('Point Order Calculation', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    test('calculates point orders correctly', () => {\n      const identity: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      expect(EllipticCurveArithmetic.getPointOrder(identity, curve)).toBe(1);\n      \n      // Generate all points and test their orders\n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      \n      points.forEach(point => {\n        const order = EllipticCurveArithmetic.getPointOrder(point, curve);\n        expect(order).toBeGreaterThan(0);\n        \n        if (order !== -1) { // Order found within limit\n          // Verify that order * point = identity\n          const result = EllipticCurveArithmetic.scalarMultiply(point, order, curve);\n          expect(result.isIdentity).toBe(true);\n        }\n      });\n    });\n\n    test('validates Lagrange theorem for point orders', () => {\n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const groupOrder = points.length;\n      \n      points.forEach(point => {\n        const pointOrder = EllipticCurveArithmetic.getPointOrder(point, curve);\n        if (pointOrder !== -1 && pointOrder > 0) {\n          expect(groupOrder % pointOrder).toBe(0);\n        }\n      });\n    });\n\n    test('handles edge cases in order calculation', () => {\n      // Test with a problematic curve where computation might fail\n      const badCurve: EllipticCurve = {\n        a: 0, b: 0, p: 2, // Singular curve\n        name: 'bad_curve',\n        displayName: 'y² = x³ (mod 2)'\n      };\n      \n      const point: EllipticCurvePoint = { x: 1, y: 1, isIdentity: false };\n      const order = EllipticCurveArithmetic.getPointOrder(point, badCurve);\n      \n      // Should handle gracefully, returning valid order or -1\n      expect(typeof order).toBe('number');\n      expect(order).toBeGreaterThanOrEqual(-1);\n    });\n  });\n});\n\ndescribe('EllipticCurveGroupGenerator', () => {\n  \n  describe('Point Generation', () => {\n    \n    test('generates valid curve points', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      \n      expect(Array.isArray(points)).toBe(true);\n      expect(points.length).toBeGreaterThan(0);\n      \n      // First point should be identity\n      expect(points[0].isIdentity).toBe(true);\n      expect(points[0].x).toBeNull();\n      expect(points[0].y).toBeNull();\n      \n      // All points should be on the curve\n      points.forEach(point => {\n        expect(EllipticCurveArithmetic.isOnCurve(point, curve)).toBe(true);\n        expect(point).toBeValidEllipticCurvePoint(curve);\n      });\n    });\n\n    test('generates expected number of points for known curves', () => {\n      // E: y² = x³ + x + 1 (mod 5) has 8 points including identity\n      const curve1: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'E_5_1_1',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const points1 = EllipticCurveGroupGenerator.generateCurvePoints(curve1);\n      expect(points1.length).toBe(8);\n      \n      // E: y² = x³ + x + 6 (mod 7) has 12 points including identity\n      const curve2: EllipticCurve = {\n        a: 1, b: 6, p: 7,\n        name: 'E_7_1_6',\n        displayName: 'y² = x³ + x + 6 (mod 7)'\n      };\n      \n      const points2 = EllipticCurveGroupGenerator.generateCurvePoints(curve2);\n      expect(points2.length).toBe(12);\n    });\n\n    test('validates Hasse bound for generated groups', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n      \n      curves.forEach(curve => {\n        const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n        const groupOrder = points.length;\n        \n        // Hasse bound: |#E(Fp) - (p + 1)| ≤ 2√p\n        const bound = 2 * Math.sqrt(curve.p);\n        const difference = Math.abs(groupOrder - (curve.p + 1));\n        \n        expect(difference).toBeLessThanOrEqual(bound);\n      });\n    });\n\n    test('generates unique points', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const pointStrings = points.map(p => \n        p.isIdentity ? 'O' : `(${p.x},${p.y})`\n      );\n      const uniquePoints = new Set(pointStrings);\n      \n      expect(uniquePoints.size).toBe(points.length);\n    });\n  });\n\n  describe('Group Creation', () => {\n    \n    test('creates valid elliptic curve group structure', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'E_5_1_1',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const group = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      \n      expect(group.curve).toEqual(curve);\n      expect(group.name).toBe('EC_E_5_1_1');\n      expect(group.displayName).toBe('E: y² = x³ + 1x + 1 (mod 5)');\n      expect(group.order).toBe(group.points.length);\n      expect(group.points.length).toBeGreaterThan(0);\n      expect(group.points[0].isIdentity).toBe(true);\n    });\n\n    test('validates group properties', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves().slice(0, 3);\n      \n      curves.forEach(curve => {\n        const group = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n        \n        expect(group.order).toBeGreaterThan(0);\n        expect(group.points.length).toBe(group.order);\n        expect(group.name).toContain('EC_');\n        expect(group.displayName).toContain('y²');\n        expect(group.displayName).toContain(`(mod ${curve.p})`);\n      });\n    });\n  });\n\n  describe('Predefined Curves', () => {\n    \n    test('provides valid predefined curves', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n      \n      expect(Array.isArray(curves)).toBe(true);\n      expect(curves.length).toBeGreaterThan(0);\n      \n      curves.forEach(curve => {\n        expect(curve).toHaveProperty('a');\n        expect(curve).toHaveProperty('b');\n        expect(curve).toHaveProperty('p');\n        expect(curve).toHaveProperty('name');\n        expect(curve).toHaveProperty('displayName');\n        \n        expect(typeof curve.a).toBe('number');\n        expect(typeof curve.b).toBe('number');\n        expect(typeof curve.p).toBe('number');\n        expect(typeof curve.name).toBe('string');\n        expect(typeof curve.displayName).toBe('string');\n        \n        expect(curve.p).toBeGreaterThan(1);\n        expect(Number.isInteger(curve.p)).toBe(true);\n        \n        // Validate using mathematical validation framework\n        const validation = EllipticCurveValidator.validateCurve(curve);\n        expect(validation.isValid).toBe(true);\n      });\n    });\n\n    test('validates discriminant for predefined curves', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n      \n      curves.forEach(curve => {\n        // Check discriminant: Δ = -16(4a³ + 27b²) ≠ 0 (mod p)\n        const discriminant = -16 * (4 * Math.pow(curve.a, 3) + 27 * Math.pow(curve.b, 2));\n        expect(discriminant % curve.p).not.toBe(0);\n      });\n    });\n  });\n\n  describe('Standard Group Conversion', () => {\n    \n    test('converts to standard group format correctly', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'E_5_1_1',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      expect(standardGroup.name).toBe(ecGroup.name);\n      expect(standardGroup.displayName).toBe(ecGroup.displayName);\n      expect(standardGroup.order).toBe(ecGroup.order);\n      expect(standardGroup.isAbelian).toBe(true);\n      expect(Array.isArray(standardGroup.elements)).toBe(true);\n      expect(standardGroup.operations instanceof Map).toBe(true);\n      expect(Array.isArray(standardGroup.generators)).toBe(true);\n      \n      // Validate element structure\n      standardGroup.elements.forEach((element: any) => {\n        expect(element).toHaveProperty('id');\n        expect(element).toHaveProperty('label');\n        expect(element).toHaveProperty('latex');\n        expect(element).toHaveProperty('order');\n        expect(element).toHaveProperty('inverse');\n        expect(element).toHaveProperty('conjugacyClass');\n        \n        expect(typeof element.id).toBe('string');\n        expect(typeof element.label).toBe('string');\n        expect(typeof element.latex).toBe('string');\n        expect(typeof element.order).toBe('number');\n        expect(typeof element.inverse).toBe('string');\n        expect(typeof element.conjugacyClass).toBe('number');\n      });\n    });\n\n    test('validates operation table in standard group', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      // Check operation table completeness\n      expect(standardGroup.operations.size).toBe(standardGroup.order);\n      \n      standardGroup.operations.forEach((operationMap: Map<string, string>, element1: string) => {\n        expect(operationMap.size).toBe(standardGroup.order);\n        \n        operationMap.forEach((result: string, element2: string) => {\n          // Result should be a valid element ID\n          expect(standardGroup.elements.some((e: any) => e.id === result)).toBe(true);\n        });\n      });\n    });\n\n    test('validates inverse relationships in standard group', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      standardGroup.elements.forEach((element: any) => {\n        const inverse = standardGroup.elements.find((e: any) => e.id === element.inverse);\n        expect(inverse).toBeDefined();\n        \n        // Check that element * inverse = identity\n        const product = standardGroup.operations.get(element.id)?.get(element.inverse);\n        expect(product).toBe('P0'); // P0 should be identity\n      });\n    });\n  });\n});\n\ndescribe('EllipticCurveAnimator', () => {\n  \n  describe('Animation Generation', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    const point1: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n    const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n    const identity: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n\n    test('generates valid animation frames for point addition', () => {\n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve, 800, 600\n      );\n      \n      expect(Array.isArray(frames)).toBe(true);\n      expect(frames.length).toBeGreaterThan(0);\n      \n      // Check frame structure\n      frames.forEach(frame => {\n        expect(frame).toHaveProperty('step');\n        expect(frame).toHaveProperty('progress');\n        expect(typeof frame.step).toBe('string');\n        expect(typeof frame.progress).toBe('number');\n        expect(frame.progress).toBeGreaterThanOrEqual(0);\n        expect(frame.progress).toBeLessThanOrEqual(1);\n      });\n      \n      // First frame should be 'selecting'\n      expect(frames[0].step).toBe('selecting');\n      expect(frames[0].progress).toBe(0);\n      \n      // Last frame should be 'completed'\n      expect(frames[frames.length - 1].step).toBe('completed');\n      expect(frames[frames.length - 1].progress).toBe(1);\n    });\n\n    test('handles identity point animations', () => {\n      const frames1 = EllipticCurveAnimator.generateAdditionAnimation(\n        identity, point1, curve\n      );\n      const frames2 = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, identity, curve\n      );\n      \n      expect(frames1.length).toBeGreaterThan(0);\n      expect(frames2.length).toBeGreaterThan(0);\n      \n      // Should start with selecting and end with completed\n      expect(frames1[0].step).toBe('selecting');\n      expect(frames1[frames1.length - 1].step).toBe('completed');\n      expect(frames2[0].step).toBe('selecting');\n      expect(frames2[frames2.length - 1].step).toBe('completed');\n    });\n\n    test('validates animation progression', () => {\n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve\n      );\n      \n      // Progress should be monotonically increasing\n      for (let i = 1; i < frames.length; i++) {\n        expect(frames[i].progress).toBeGreaterThanOrEqual(frames[i - 1].progress);\n      }\n      \n      // All expected steps should be present for non-identity points\n      const steps = frames.map(f => f.step);\n      expect(steps).toContain('selecting');\n      expect(steps).toContain('completed');\n    });\n\n    test('handles edge cases in animation generation', () => {\n      // Same point (doubling)\n      const doublingFrames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point1, curve\n      );\n      expect(doublingFrames.length).toBeGreaterThan(0);\n      \n      // Both identity points\n      const identityFrames = EllipticCurveAnimator.generateAdditionAnimation(\n        identity, identity, curve\n      );\n      expect(identityFrames.length).toBeGreaterThan(0);\n    });\n\n    test('validates animation results match arithmetic', () => {\n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve\n      );\n      \n      const lastFrame = frames[frames.length - 1];\n      const arithmeticResult = EllipticCurveArithmetic.addPoints(point1, point2, curve);\n      \n      expect(lastFrame.result).toEqual(arithmeticResult);\n    });\n  });\n\n  describe('Performance and Edge Cases', () => {\n    \n    test('generates animations efficiently', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 11,\n        name: 'perf_test',\n        displayName: 'y² = x³ + x + 1 (mod 11)'\n      };\n      \n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const startTime = performance.now();\n      \n      // Generate animations for first few point pairs\n      for (let i = 0; i < Math.min(3, points.length); i++) {\n        for (let j = 0; j < Math.min(3, points.length); j++) {\n          EllipticCurveAnimator.generateAdditionAnimation(\n            points[i], points[j], curve\n          );\n        }\n      }\n      \n      const endTime = performance.now();\n      expect(endTime - startTime).toBeLessThan(100); // Should be fast\n    });\n\n    test('handles large canvas dimensions', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const point1: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n      \n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve, 1920, 1080\n      );\n      \n      expect(frames.length).toBeGreaterThan(0);\n      \n      // Check that line points (if any) respect canvas bounds\n      frames.forEach(frame => {\n        if (frame.linePoints) {\n          frame.linePoints.forEach(point => {\n            expect(point.x).toBeGreaterThanOrEqual(0);\n            expect(point.x).toBeLessThanOrEqual(1920);\n            expect(point.y).toBeGreaterThanOrEqual(0);\n            expect(point.y).toBeLessThanOrEqual(1080);\n          });\n        }\n      });\n    });\n  });\n});\n\ndescribe('Integration Tests', () => {\n  \n  test('validates complete elliptic curve group workflow', () => {\n    // Create curve\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'integration_test',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n    \n    // Generate group\n    const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n    \n    // Convert to standard format\n    const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n    \n    // Test all points and operations\n    ecGroup.points.forEach(point => {\n      expect(point).toBeValidEllipticCurvePoint(curve);\n      expect(EllipticCurveArithmetic.isOnCurve(point, curve)).toBe(true);\n      \n      const order = EllipticCurveArithmetic.getPointOrder(point, curve);\n      if (order > 0 && order !== -1) {\n        expect(ecGroup.order % order).toBe(0); // Lagrange theorem\n      }\n    });\n    \n    // Test standard group properties\n    expect(standardGroup.elements.length).toBe(ecGroup.order);\n    expect(standardGroup.operations.size).toBe(ecGroup.order);\n    expect(standardGroup.isAbelian).toBe(true);\n  });\n\n  test('validates mathematical consistency across all predefined curves', () => {\n    const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n    \n    curves.forEach(curve => {\n      // Validate curve parameters\n      const curveValidation = EllipticCurveValidator.validateCurve(curve);\n      expect(curveValidation.isValid).toBe(true);\n      \n      // Generate group and validate\n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      \n      // Validate Hasse bound\n      const hasseValidation = EllipticCurveValidator.validateHasseBound(\n        ecGroup.order, curve.p\n      );\n      expect(hasseValidation.isValid).toBe(true);\n      \n      // Test group operations maintain closure\n      const testPoints = ecGroup.points.slice(0, Math.min(4, ecGroup.points.length));\n      testPoints.forEach(p1 => {\n        testPoints.forEach(p2 => {\n          const sum = EllipticCurveArithmetic.addPoints(p1, p2, curve);\n          expect(sum).toBeValidEllipticCurvePoint(curve);\n          expect(EllipticCurveArithmetic.isOnCurve(sum, curve)).toBe(true);\n          \n          // Result should be in the group\n          const isInGroup = ecGroup.points.some(p => \n            p.isIdentity === sum.isIdentity &&\n            p.x === sum.x && \n            p.y === sum.y\n          );\n          expect(isInGroup).toBe(true);\n        });\n      });\n    });\n  });\n\n  test('validates performance across different curve sizes', () => {\n    const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n    \n    curves.forEach(curve => {\n      const startTime = performance.now();\n      \n      // Generate group\n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      \n      // Convert to standard format\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      // Test some operations\n      if (ecGroup.points.length > 1) {\n        EllipticCurveArithmetic.addPoints(\n          ecGroup.points[1], \n          ecGroup.points[1], \n          curve\n        );\n      }\n      \n      const endTime = performance.now();\n      \n      // Should complete reasonably quickly even for larger curves\n      expect(endTime - startTime).toBeLessThan(1000); // 1 second limit\n    });\n  });\n\n  test('validates deterministic behavior', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 7,\n      name: 'deterministic_test',\n      displayName: 'y² = x³ + x + 1 (mod 7)'\n    };\n    \n    // Generate multiple times and ensure identical results\n    const results = Array.from({ length: 3 }, () => \n      EllipticCurveGroupGenerator.createEllipticCurveGroup(curve)\n    );\n    \n    const firstResult = results[0];\n    results.slice(1).forEach(result => {\n      expect(result.order).toBe(firstResult.order);\n      expect(result.points.length).toBe(firstResult.points.length);\n      \n      // Points should be identical (though order might differ)\n      expect(result.points).toEqual(expect.arrayContaining(firstResult.points));\n    });\n  });\n});"],"names":["expect","extend","mathematicalMatchers","describe","test","EllipticCurveArithmetic","modInverse","toBe","toThrow","modPow","testCurve","a","b","p","name","displayName","validPoint","x","y","isIdentity","invalidPoint","identityPoint","isOnCurve","malformedIdentity1","malformedIdentity2","toBeValidEllipticCurvePoint","curve","point1","point2","result1","addPoints","result2","toEqual","result","point","inversePoint","toBeNull","points","EllipticCurveGroupGenerator","generateCurvePoints","orderTwoPoint","find","getPointOrder","filter","i","length","j","k","q","r","left","right","basePoint","result0","scalarMultiply","result3","doubling","sum","kP","kQ","identity","forEach","order","toBeGreaterThan","groupOrder","pointOrder","badCurve","toBeGreaterThanOrEqual","Array","isArray","curve1","points1","curve2","points2","curves","getPredefinedCurves","bound","Math","sqrt","difference","abs","toBeLessThanOrEqual","pointStrings","map","uniquePoints","Set","size","group","createEllipticCurveGroup","slice","toContain","toHaveProperty","Number","isInteger","validation","EllipticCurveValidator","validateCurve","isValid","discriminant","pow","not","ecGroup","standardGroup","toStandardGroup","isAbelian","elements","operations","Map","generators","element","id","label","latex","inverse","conjugacyClass","operationMap","element1","element2","some","e","toBeDefined","product","get","frames","EllipticCurveAnimator","generateAdditionAnimation","frame","step","progress","frames1","frames2","steps","f","doublingFrames","identityFrames","lastFrame","arithmeticResult","startTime","performance","now","min","endTime","toBeLessThan","linePoints","curveValidation","hasseValidation","validateHasseBound","testPoints","p1","p2","isInGroup","results","from","firstResult","arrayContaining"],"mappings":"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"}