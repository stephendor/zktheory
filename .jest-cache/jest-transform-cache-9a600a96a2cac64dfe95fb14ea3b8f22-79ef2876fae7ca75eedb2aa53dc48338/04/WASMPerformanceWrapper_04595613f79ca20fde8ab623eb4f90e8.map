{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/lib/performance/WASMPerformanceWrapper.ts"],"sourcesContent":["/**\n * WASM Performance Wrapper\n * Specialized performance monitoring for WebAssembly mathematical computations\n * Handles TDA Rust core operations and other WASM-based mathematical functions\n */\n\nimport { mathematicalPerformanceMonitor, type MathematicalOperation } from './MathematicalPerformanceMonitor';\n\nexport interface WASMOperationContext {\n  operation: string;\n  wasmModule: string;\n  functionName: string;\n  inputSize: number;\n  expectedComplexity: 'O(1)' | 'O(n)' | 'O(n²)' | 'O(n³)' | 'O(2^n)' | 'unknown';\n  inputData?: any;\n  validationFn?: (result: any) => number; // Accuracy validation\n}\n\nexport interface WASMPerformanceMetrics {\n  executionTime: number;\n  memoryIncrease: number;\n  wasmHeapSize?: number;\n  jsHeapSize?: number;\n  accuracy?: number;\n  inputComplexity: number;\n}\n\nexport class WASMPerformanceWrapper {\n  private static instance: WASMPerformanceWrapper;\n  private wasmModules: Map<string, any> = new Map();\n  private performanceCache: Map<string, WASMPerformanceMetrics[]> = new Map();\n\n  private constructor() {}\n\n  static getInstance(): WASMPerformanceWrapper {\n    if (!WASMPerformanceWrapper.instance) {\n      WASMPerformanceWrapper.instance = new WASMPerformanceWrapper();\n    }\n    return WASMPerformanceWrapper.instance;\n  }\n\n  /**\n   * Register a WASM module for performance monitoring\n   */\n  registerWASMModule(name: string, module: any): void {\n    this.wasmModules.set(name, module);\n  }\n\n  /**\n   * Wrap a WASM function call with performance monitoring\n   */\n  async wrapWASMOperation<T>(\n    context: WASMOperationContext,\n    wasmFunction: () => Promise<T> | T,\n    options?: {\n      environment?: 'development' | 'testing' | 'production';\n      trackMemory?: boolean;\n      cacheResults?: boolean;\n    }\n  ): Promise<T> {\n    const operation: MathematicalOperation = {\n      operation: `wasm_${context.operation}`,\n      category: this.categorizeWASMOperation(context.operation),\n      complexity: context.expectedComplexity,\n      inputSize: context.inputSize,\n      expectedTimeMs: this.estimateExecutionTime(context),\n      maxAllowedTimeMs: this.getMaxAllowedTime(context)\n    };\n\n    return await mathematicalPerformanceMonitor.monitorMathematicalOperation(\n      operation,\n      async () => {\n        const startMemory = options?.trackMemory ? this.getWASMMemoryUsage() : undefined;\n        \n        try {\n          const result = await wasmFunction();\n          \n          // Store performance metrics in cache if requested\n          if (options?.cacheResults) {\n            this.cachePerformanceMetrics(context, startMemory);\n          }\n          \n          return result;\n        } catch (error) {\n          console.error(`WASM operation ${context.operation} failed:`, error);\n          throw error;\n        }\n      },\n      {\n        environment: options?.environment,\n        trackMemory: options?.trackMemory,\n        validateResult: context.validationFn\n      }\n    );\n  }\n\n  /**\n   * Wrap synchronous WASM function calls\n   */\n  wrapSyncWASMOperation<T>(\n    context: WASMOperationContext,\n    wasmFunction: () => T,\n    options?: {\n      environment?: 'development' | 'testing' | 'production';\n      trackMemory?: boolean;\n      cacheResults?: boolean;\n    }\n  ): T {\n    const operation: MathematicalOperation = {\n      operation: `wasm_${context.operation}`,\n      category: this.categorizeWASMOperation(context.operation),\n      complexity: context.expectedComplexity,\n      inputSize: context.inputSize,\n      expectedTimeMs: this.estimateExecutionTime(context),\n      maxAllowedTimeMs: this.getMaxAllowedTime(context)\n    };\n\n    return mathematicalPerformanceMonitor.monitorSyncMathematicalOperation(\n      operation,\n      () => {\n        const startMemory = options?.trackMemory ? this.getWASMMemoryUsage() : undefined;\n        \n        try {\n          const result = wasmFunction();\n          \n          // Store performance metrics in cache if requested\n          if (options?.cacheResults) {\n            this.cachePerformanceMetrics(context, startMemory);\n          }\n          \n          return result;\n        } catch (error) {\n          console.error(`WASM operation ${context.operation} failed:`, error);\n          throw error;\n        }\n      },\n      {\n        environment: options?.environment,\n        trackMemory: options?.trackMemory,\n        validateResult: context.validationFn\n      }\n    );\n  }\n\n  /**\n   * Specific wrapper for TDA Rust core operations\n   */\n  async wrapTDAOperation<T>(\n    operationName: string,\n    inputData: any,\n    wasmFunction: () => Promise<T> | T,\n    options?: {\n      validateTopology?: boolean;\n      expectedBetti?: number[];\n      environment?: 'development' | 'testing' | 'production';\n    }\n  ): Promise<T> {\n    const inputSize = this.calculateTDAInputSize(inputData);\n    \n    const context: WASMOperationContext = {\n      operation: `tda_${operationName}`,\n      wasmModule: 'tda_rust_core',\n      functionName: operationName,\n      inputSize,\n      expectedComplexity: this.getTDAComplexity(operationName, inputSize),\n      inputData,\n      validationFn: options?.validateTopology ? this.createTDAValidator(options.expectedBetti) : undefined\n    };\n\n    return await this.wrapWASMOperation(context, wasmFunction, {\n      environment: options?.environment,\n      trackMemory: true,\n      cacheResults: true\n    });\n  }\n\n  /**\n   * Specific wrapper for Cayley graph operations\n   */\n  async wrapCayleyOperation<T>(\n    operationName: string,\n    groupOrder: number,\n    wasmFunction: () => Promise<T> | T,\n    options?: {\n      validateGroupProperties?: boolean;\n      environment?: 'development' | 'testing' | 'production';\n    }\n  ): Promise<T> {\n    const context: WASMOperationContext = {\n      operation: `cayley_${operationName}`,\n      wasmModule: 'cayley_core',\n      functionName: operationName,\n      inputSize: groupOrder,\n      expectedComplexity: this.getCayleyComplexity(operationName, groupOrder),\n      validationFn: options?.validateGroupProperties ? this.createCayleyValidator(groupOrder) : undefined\n    };\n\n    return await this.wrapWASMOperation(context, wasmFunction, {\n      environment: options?.environment,\n      trackMemory: true,\n      cacheResults: true\n    });\n  }\n\n  private categorizeWASMOperation(operation: string): 'group_theory' | 'elliptic_curves' | 'tda' | 'visualization' | 'latex_rendering' {\n    if (operation.includes('tda') || operation.includes('persistence') || operation.includes('homology')) {\n      return 'tda';\n    }\n    if (operation.includes('cayley') || operation.includes('group') || operation.includes('algebra')) {\n      return 'group_theory';\n    }\n    if (operation.includes('elliptic') || operation.includes('curve') || operation.includes('field')) {\n      return 'elliptic_curves';\n    }\n    if (operation.includes('render') || operation.includes('draw') || operation.includes('canvas')) {\n      return 'visualization';\n    }\n    if (operation.includes('latex') || operation.includes('math') || operation.includes('katex')) {\n      return 'latex_rendering';\n    }\n    return 'tda'; // Default fallback\n  }\n\n  private estimateExecutionTime(context: WASMOperationContext): number {\n    const { operation, inputSize, expectedComplexity } = context;\n    \n    // Base estimates in milliseconds\n    const baseTime = {\n      'tda_persistence': 100,\n      'tda_homology': 500,\n      'cayley_generation': 50,\n      'cayley_layout': 200,\n      'group_validation': 20,\n      'default': 100\n    };\n\n    const base = baseTime[operation as keyof typeof baseTime] || baseTime.default;\n    \n    // Apply complexity scaling\n    switch (expectedComplexity) {\n      case 'O(1)': return base;\n      case 'O(n)': return base * Math.log(inputSize + 1);\n      case 'O(n²)': return base * Math.pow(Math.log(inputSize + 1), 2);\n      case 'O(n³)': return base * Math.pow(Math.log(inputSize + 1), 3);\n      case 'O(2^n)': return Math.min(base * Math.pow(2, Math.min(inputSize, 10)), 10000);\n      default: return base * Math.log(inputSize + 1);\n    }\n  }\n\n  private getMaxAllowedTime(context: WASMOperationContext): number {\n    const estimated = this.estimateExecutionTime(context);\n    // Allow 3x the estimated time as maximum\n    return Math.max(estimated * 3, 1000); // Minimum 1 second\n  }\n\n  private calculateTDAInputSize(inputData: any): number {\n    if (Array.isArray(inputData)) {\n      return inputData.length;\n    }\n    if (inputData?.points && Array.isArray(inputData.points)) {\n      return inputData.points.length;\n    }\n    if (typeof inputData === 'object' && inputData?.size) {\n      return inputData.size;\n    }\n    return 100; // Default estimate\n  }\n\n  private getTDAComplexity(operationName: string, inputSize: number): 'O(1)' | 'O(n)' | 'O(n²)' | 'O(n³)' | 'O(2^n)' | 'unknown' {\n    switch (operationName) {\n      case 'persistence_diagram':\n      case 'homology_computation':\n        return inputSize < 50 ? 'O(n²)' : 'O(n³)';\n      case 'filtration_construction':\n        return 'O(n²)';\n      case 'barcode_generation':\n        return 'O(n)';\n      case 'landscape_computation':\n        return 'O(n²)';\n      default:\n        return 'O(n²)';\n    }\n  }\n\n  private getCayleyComplexity(operationName: string, groupOrder: number): 'O(1)' | 'O(n)' | 'O(n²)' | 'O(n³)' | 'O(2^n)' | 'unknown' {\n    switch (operationName) {\n      case 'group_generation':\n        return groupOrder < 20 ? 'O(n²)' : 'O(n³)';\n      case 'layout_calculation':\n        return 'O(n²)';\n      case 'subgroup_detection':\n        return 'O(n²)';\n      case 'conjugacy_classes':\n        return 'O(n²)';\n      default:\n        return 'O(n²)';\n    }\n  }\n\n  private createTDAValidator(expectedBetti?: number[]) {\n    return (result: any): number => {\n      try {\n        if (!result || !result.intervals) {\n          return 0.0; // Invalid result\n        }\n\n        // Basic validation: check if we have reasonable intervals\n        const intervals = result.intervals;\n        if (!Array.isArray(intervals) || intervals.length === 0) {\n          return 0.5; // Partially valid\n        }\n\n        // Check if intervals have expected structure\n        const hasValidStructure = intervals.every(interval => \n          typeof interval.birth === 'number' && \n          typeof interval.death === 'number' &&\n          interval.birth <= interval.death\n        );\n\n        if (!hasValidStructure) {\n          return 0.3; // Poor structure\n        }\n\n        // If expected Betti numbers provided, validate against them\n        if (expectedBetti) {\n          const actualBetti = this.computeBettiNumbers(intervals);\n          const bettiAccuracy = this.compareBettiNumbers(actualBetti, expectedBetti);\n          return 0.7 + (0.3 * bettiAccuracy); // Base score + Betti accuracy\n        }\n\n        return 1.0; // Fully valid\n      } catch (error) {\n        console.warn('TDA validation failed:', error);\n        return 0.0;\n      }\n    };\n  }\n\n  private createCayleyValidator(groupOrder: number) {\n    return (result: any): number => {\n      try {\n        if (!result) return 0.0;\n\n        // Validate group structure if applicable\n        if (result.elements && Array.isArray(result.elements)) {\n          if (result.elements.length !== groupOrder) {\n            return 0.5; // Wrong number of elements\n          }\n          \n          // Check for identity element\n          const hasIdentity = result.elements.some((el: any) => el.id === 'e');\n          if (!hasIdentity) {\n            return 0.6; // Missing identity\n          }\n          \n          return 1.0; // Valid group structure\n        }\n\n        // Validate visualization data\n        if (result.nodes && result.edges) {\n          const nodeCount = Array.isArray(result.nodes) ? result.nodes.length : 0;\n          if (nodeCount !== groupOrder) {\n            return 0.7; // Wrong number of nodes\n          }\n          return 1.0; // Valid visualization\n        }\n\n        return 0.8; // Generic valid result\n      } catch (error) {\n        console.warn('Cayley validation failed:', error);\n        return 0.0;\n      }\n    };\n  }\n\n  private computeBettiNumbers(intervals: any[]): number[] {\n    const dimensions = new Set(intervals.map(i => i.dimension));\n    const maxDim = Math.max(...dimensions);\n    const betti: number[] = [];\n\n    for (let d = 0; d <= maxDim; d++) {\n      const dimIntervals = intervals.filter(i => i.dimension === d && i.death > i.birth);\n      betti[d] = dimIntervals.length;\n    }\n\n    return betti;\n  }\n\n  private compareBettiNumbers(actual: number[], expected: number[]): number {\n    const maxLength = Math.max(actual.length, expected.length);\n    let matches = 0;\n\n    for (let i = 0; i < maxLength; i++) {\n      const actualVal = actual[i] || 0;\n      const expectedVal = expected[i] || 0;\n      if (actualVal === expectedVal) matches++;\n    }\n\n    return matches / maxLength;\n  }\n\n  private getWASMMemoryUsage(): { wasmHeap: number; jsHeap: number } {\n    let wasmHeap = 0;\n    let jsHeap = 0;\n\n    // Try to get WASM memory usage\n    try {\n      // This would need to be adapted based on the specific WASM module\n      const wasmModule = this.wasmModules.get('tda_rust_core');\n      if (wasmModule && wasmModule.memory) {\n        wasmHeap = wasmModule.memory.buffer.byteLength;\n      }\n    } catch (error) {\n      // Ignore WASM memory errors\n    }\n\n    // Get JS heap usage\n    try {\n      const performance = globalThis.performance as any;\n      if (performance?.memory) {\n        jsHeap = performance.memory.usedJSHeapSize || 0;\n      }\n    } catch (error) {\n      // Ignore JS memory errors\n    }\n\n    return { wasmHeap, jsHeap };\n  }\n\n  private cachePerformanceMetrics(context: WASMOperationContext, startMemory?: any): void {\n    const key = `${context.wasmModule}_${context.functionName}`;\n    const existing = this.performanceCache.get(key) || [];\n    \n    // For now, just store the operation context\n    // In a real implementation, we'd calculate and store actual metrics\n    const metrics: WASMPerformanceMetrics = {\n      executionTime: 0, // Would be filled by the monitoring system\n      memoryIncrease: 0, // Would be calculated\n      inputComplexity: context.inputSize\n    };\n\n    existing.push(metrics);\n    \n    // Keep only the last 100 measurements\n    if (existing.length > 100) {\n      existing.splice(0, existing.length - 100);\n    }\n    \n    this.performanceCache.set(key, existing);\n  }\n\n  /**\n   * Get cached performance metrics for analysis\n   */\n  getCachedMetrics(wasmModule: string, functionName: string): WASMPerformanceMetrics[] {\n    const key = `${wasmModule}_${functionName}`;\n    return this.performanceCache.get(key) || [];\n  }\n\n  /**\n   * Clear performance cache\n   */\n  clearCache(): void {\n    this.performanceCache.clear();\n  }\n\n  /**\n   * Generate WASM-specific performance report\n   */\n  generateWASMReport(): {\n    modules: string[];\n    operations: Record<string, { callCount: number; averageTime: number; }>;\n    recommendations: string[];\n  } {\n    const modules = Array.from(this.wasmModules.keys());\n    const operations: Record<string, { callCount: number; averageTime: number; }> = {};\n    const recommendations: string[] = [];\n\n    // Analyze cached metrics\n    for (const [key, metrics] of this.performanceCache.entries()) {\n      const callCount = metrics.length;\n      const averageTime = callCount > 0 \n        ? metrics.reduce((sum, m) => sum + m.executionTime, 0) / callCount \n        : 0;\n      \n      operations[key] = { callCount, averageTime };\n\n      // Generate recommendations\n      if (callCount > 50 && averageTime > 1000) {\n        recommendations.push(`Consider optimizing ${key} - high frequency and slow execution`);\n      }\n    }\n\n    return {\n      modules,\n      operations,\n      recommendations\n    };\n  }\n}\n\n// Export singleton instance\nexport const wasmPerformanceWrapper = WASMPerformanceWrapper.getInstance();\n\n// Helper functions for common WASM operations\nexport function withTDAPerformanceMonitoring<T>(\n  operationName: string,\n  inputData: any,\n  wasmFunction: () => Promise<T> | T,\n  options?: {\n    validateTopology?: boolean;\n    expectedBetti?: number[];\n    environment?: 'development' | 'testing' | 'production';\n  }\n): Promise<T> {\n  return wasmPerformanceWrapper.wrapTDAOperation(operationName, inputData, wasmFunction, options);\n}\n\nexport function withCayleyPerformanceMonitoring<T>(\n  operationName: string,\n  groupOrder: number,\n  wasmFunction: () => Promise<T> | T,\n  options?: {\n    validateGroupProperties?: boolean;\n    environment?: 'development' | 'testing' | 'production';\n  }\n): Promise<T> {\n  return wasmPerformanceWrapper.wrapCayleyOperation(operationName, groupOrder, wasmFunction, options);\n}"],"names":["WASMPerformanceWrapper","wasmPerformanceWrapper","withCayleyPerformanceMonitoring","withTDAPerformanceMonitoring","wasmModules","Map","performanceCache","getInstance","instance","registerWASMModule","name","module","set","wrapWASMOperation","context","wasmFunction","options","operation","category","categorizeWASMOperation","complexity","expectedComplexity","inputSize","expectedTimeMs","estimateExecutionTime","maxAllowedTimeMs","getMaxAllowedTime","mathematicalPerformanceMonitor","monitorMathematicalOperation","startMemory","trackMemory","getWASMMemoryUsage","undefined","result","cacheResults","cachePerformanceMetrics","error","console","environment","validateResult","validationFn","wrapSyncWASMOperation","monitorSyncMathematicalOperation","wrapTDAOperation","operationName","inputData","calculateTDAInputSize","wasmModule","functionName","getTDAComplexity","validateTopology","createTDAValidator","expectedBetti","wrapCayleyOperation","groupOrder","getCayleyComplexity","validateGroupProperties","createCayleyValidator","includes","baseTime","base","default","Math","log","pow","min","estimated","max","Array","isArray","length","points","size","intervals","hasValidStructure","every","interval","birth","death","actualBetti","computeBettiNumbers","bettiAccuracy","compareBettiNumbers","warn","elements","hasIdentity","some","el","id","nodes","edges","nodeCount","dimensions","Set","map","i","dimension","maxDim","betti","d","dimIntervals","filter","actual","expected","maxLength","matches","actualVal","expectedVal","wasmHeap","jsHeap","get","memory","buffer","byteLength","performance","globalThis","usedJSHeapSize","key","existing","metrics","executionTime","memoryIncrease","inputComplexity","push","splice","getCachedMetrics","clearCache","clear","generateWASMReport","modules","from","keys","operations","recommendations","entries","callCount","averageTime","reduce","sum","m"],"mappings":"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"}