{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/__tests__/performance/PerformanceMetrics.test.ts"],"sourcesContent":["import { PerformanceMetricsCollector, MetricsBuffer } from '../../lib/performance';\nimport { PerformanceMetric } from '../../lib/performance/types';\n\ndescribe('PerformanceMetrics', () => {\n  let collector: PerformanceMetricsCollector;\n  let buffer: MetricsBuffer;\n\n  beforeEach(() => {\n    collector = PerformanceMetricsCollector.getInstance();\n    buffer = new MetricsBuffer();\n    // Clear any existing metrics\n    collector.clearMetrics();\n  });\n\n  describe('PerformanceMetricsCollector', () => {\n    it('should be a singleton', () => {\n      const instance1 = PerformanceMetricsCollector.getInstance();\n      const instance2 = PerformanceMetricsCollector.getInstance();\n      expect(instance1).toBe(instance2);\n    });\n\n    it('should collect metrics correctly', () => {\n      const metric: PerformanceMetric = {\n        id: 'test_metric',\n        timestamp: Date.now(),\n        category: 'computation',\n        value: 100,\n        unit: 'ms',\n        metadata: { test: true }\n      };\n\n      collector.collectMetric(metric);\n      const metrics = collector.getMetrics();\n      \n      expect(metrics).toHaveLength(1);\n      expect(metrics[0]).toEqual(metric);\n    });\n\n    it('should handle timer functionality', () => {\n      const stopTimer = collector.startTimer('test_component', 'computation');\n      \n      // Simulate some work\n      const start = performance.now();\n      while (performance.now() - start < 1) {\n        // Busy wait for ~1ms\n      }\n      \n      stopTimer();\n      \n      const metrics = collector.getMetrics();\n      expect(metrics).toHaveLength(1);\n      expect(metrics[0].id).toBe('test_component_computation');\n      expect(metrics[0].category).toBe('computation');\n      expect(metrics[0].value).toBeGreaterThan(0);\n      expect(metrics[0].unit).toBe('ms');\n    });\n\n    it('should respect enable/disable state', () => {\n      collector.disable();\n      collector.collectMetric({\n        id: 'test',\n        timestamp: Date.now(),\n        category: 'computation',\n        value: 100,\n        unit: 'ms'\n      });\n      \n      expect(collector.getMetrics()).toHaveLength(0);\n      \n      collector.enable();\n      collector.collectMetric({\n        id: 'test',\n        timestamp: Date.now(),\n        category: 'computation',\n        value: 100,\n        unit: 'ms'\n      });\n      \n      expect(collector.getMetrics()).toHaveLength(1);\n    });\n\n    it('should apply sampling correctly', () => {\n      collector.setSampleRate(0.5); // 50% sampling\n      \n      // Collect 10 metrics\n      for (let i = 0; i < 10; i++) {\n        collector.collectMetric({\n          id: `test_${i}`,\n          timestamp: Date.now(),\n          category: 'computation',\n          value: i,\n          unit: 'ms'\n        });\n      }\n      \n      const metrics = collector.getMetrics();\n      // With 50% sampling, we should have roughly 5 metrics (allowing for randomness)\n      expect(metrics.length).toBeLessThanOrEqual(10);\n      expect(metrics.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('MetricsBuffer', () => {\n    it('should add and retrieve metrics', () => {\n      const metric: PerformanceMetric = {\n        id: 'test',\n        timestamp: Date.now(),\n        category: 'computation',\n        value: 100,\n        unit: 'ms'\n      };\n\n      buffer.addMetric(metric);\n      const metrics = buffer.getMetrics();\n      \n      expect(metrics).toHaveLength(1);\n      expect(metrics[0]).toEqual(metric);\n    });\n\n    it('should filter metrics by category', () => {\n      const computationMetric: PerformanceMetric = {\n        id: 'comp_1',\n        timestamp: Date.now(),\n        category: 'computation',\n        value: 100,\n        unit: 'ms'\n      };\n\n      const memoryMetric: PerformanceMetric = {\n        id: 'mem_1',\n        timestamp: Date.now(),\n        category: 'memory',\n        value: 1024,\n        unit: 'bytes'\n      };\n\n      buffer.addMetric(computationMetric);\n      buffer.addMetric(memoryMetric);\n\n      const computationMetrics = buffer.getMetrics('computation');\n      const memoryMetrics = buffer.getMetrics('memory');\n\n      expect(computationMetrics).toHaveLength(1);\n      expect(computationMetrics[0].category).toBe('computation');\n      expect(memoryMetrics).toHaveLength(1);\n      expect(memoryMetrics[0].category).toBe('memory');\n    });\n\n    it('should filter metrics by time range', () => {\n      const now = Date.now();\n      const oldMetric: PerformanceMetric = {\n        id: 'old',\n        timestamp: now - 10000, // 10 seconds ago\n        category: 'computation',\n        value: 100,\n        unit: 'ms'\n      };\n\n      const newMetric: PerformanceMetric = {\n        id: 'new',\n        timestamp: now,\n        category: 'computation',\n        value: 200,\n        unit: 'ms'\n      };\n\n      buffer.addMetric(oldMetric);\n      buffer.addMetric(newMetric);\n\n      const recentMetrics = buffer.getMetrics(undefined, {\n        start: now - 5000,\n        end: now + 1000\n      });\n\n      expect(recentMetrics).toHaveLength(1);\n      expect(recentMetrics[0].id).toBe('new');\n    });\n\n    it('should respect max buffer size', () => {\n      const smallBuffer = new MetricsBuffer(3, 60000); // Max 3 metrics\n\n      for (let i = 0; i < 5; i++) {\n        smallBuffer.addMetric({\n          id: `test_${i}`,\n          timestamp: Date.now(),\n          category: 'computation',\n          value: i,\n          unit: 'ms'\n        });\n      }\n\n      const metrics = smallBuffer.getMetrics();\n      expect(metrics).toHaveLength(3);\n      // Should keep the most recent metrics\n      expect(metrics[0].id).toBe('test_2');\n      expect(metrics[1].id).toBe('test_3');\n      expect(metrics[2].id).toBe('test_4');\n    });\n\n    it('should provide metrics summary', () => {\n      buffer.addMetric({\n        id: 'comp_1',\n        timestamp: Date.now(),\n        category: 'computation',\n        value: 100,\n        unit: 'ms'\n      });\n\n      buffer.addMetric({\n        id: 'comp_2',\n        timestamp: Date.now(),\n        category: 'computation',\n        value: 200,\n        unit: 'ms'\n      });\n\n      buffer.addMetric({\n        id: 'mem_1',\n        timestamp: Date.now(),\n        category: 'memory',\n        value: 1024,\n        unit: 'bytes'\n      });\n\n      const summary = buffer.getMetricsSummary();\n      \n      expect(summary.total).toBe(3);\n      expect(summary.byCategory.computation).toBe(2);\n      expect(summary.byCategory.memory).toBe(1);\n      expect(summary.byComponent.comp).toBe(2);\n      expect(summary.byComponent.mem).toBe(1);\n    });\n  });\n\n  describe('Integration', () => {\n    it('should work together correctly', () => {\n      const stopTimer = collector.startTimer('integration_test', 'computation');\n      \n      // Simulate work\n      const start = performance.now();\n      while (performance.now() - start < 1) {\n        // Busy wait for ~1ms\n      }\n      \n      stopTimer();\n      \n      const metrics = collector.getMetrics();\n      expect(metrics).toHaveLength(1);\n      \n      const metric = metrics[0];\n      expect(metric.id).toBe('integration_test_computation');\n      expect(metric.category).toBe('computation');\n      expect(metric.value).toBeGreaterThan(0);\n      expect(metric.unit).toBe('ms');\n      expect(metric.metadata).toBeDefined();\n    });\n  });\n});\n"],"names":["describe","collector","buffer","beforeEach","PerformanceMetricsCollector","getInstance","MetricsBuffer","clearMetrics","it","instance1","instance2","expect","toBe","metric","id","timestamp","Date","now","category","value","unit","metadata","test","collectMetric","metrics","getMetrics","toHaveLength","toEqual","stopTimer","startTimer","start","performance","toBeGreaterThan","disable","enable","setSampleRate","i","length","toBeLessThanOrEqual","addMetric","computationMetric","memoryMetric","computationMetrics","memoryMetrics","oldMetric","newMetric","recentMetrics","undefined","end","smallBuffer","summary","getMetricsSummary","total","byCategory","computation","memory","byComponent","comp","mem","toBeDefined"],"mappings":"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"}