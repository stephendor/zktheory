{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/lib/EllipticCurveGroups.ts"],"sourcesContent":["/**\n * Elliptic Curve Groups Library\n * Implements elliptic curve groups over finite fields for Cayley graph visualization\n */\n\nexport interface EllipticCurvePoint {\n  x: number | null; // null represents point at infinity\n  y: number | null;\n  isIdentity: boolean;\n}\n\nexport interface EllipticCurve {\n  a: number;\n  b: number;\n  p: number; // prime modulus\n  name: string;\n  displayName: string;\n}\n\nexport interface EllipticCurveGroup {\n  curve: EllipticCurve;\n  points: EllipticCurvePoint[];\n  order: number;\n  name: string;\n  displayName: string;\n}\n\nexport class EllipticCurveArithmetic {\n  /**\n   * Modular inverse using extended Euclidean algorithm\n   */\n  static modInverse(a: number, m: number): number {\n    if (m <= 0) throw new Error('Modulus must be positive');\n    if (a === 0) throw new Error('Cannot find inverse of 0');\n    \n    a = ((a % m) + m) % m;\n    \n    let [oldR, r] = [a, m];\n    let [oldS, s] = [1, 0];\n    \n    while (r !== 0) {\n      const quotient = Math.floor(oldR / r);\n      [oldR, r] = [r, oldR - quotient * r];\n      [oldS, s] = [s, oldS - quotient * s];\n    }\n    \n    if (oldR !== 1) {\n      throw new Error(`Modular inverse of ${a} mod ${m} does not exist (gcd = ${oldR})`);\n    }\n    \n    return ((oldS % m) + m) % m;\n  }\n\n  /**\n   * Modular exponentiation\n   */\n  static modPow(base: number, exp: number, mod: number): number {\n    let result = 1;\n    base = base % mod;\n    while (exp > 0) {\n      if (exp % 2 === 1) {\n        result = (result * base) % mod;\n      }\n      exp = Math.floor(exp / 2);\n      base = (base * base) % mod;\n    }\n    return result;\n  }\n\n  /**\n   * Check if a point is on the elliptic curve y² = x³ + ax + b (mod p)\n   */\n  static isOnCurve(point: EllipticCurvePoint, curve: EllipticCurve): boolean {\n    if (point.isIdentity) return true;\n    if (point.x === null || point.y === null) return point.isIdentity;\n    \n    const { a, b, p } = curve;\n    const leftSide = (point.y * point.y) % p;\n    const rightSide = (point.x * point.x * point.x + a * point.x + b) % p;\n    \n    return leftSide === ((rightSide % p + p) % p);\n  }\n\n  /**\n   * Add two points on an elliptic curve\n   */\n  static addPoints(\n    p1: EllipticCurvePoint, \n    p2: EllipticCurvePoint, \n    curve: EllipticCurve\n  ): EllipticCurvePoint {\n    // Handle identity element (point at infinity)\n    if (p1.isIdentity) return { ...p2 };\n    if (p2.isIdentity) return { ...p1 };\n\n    const { p: prime } = curve;\n\n    // Handle case where points are inverses of each other\n    if (p1.x === p2.x && p1.y === (prime - p2.y!) % prime) {\n      return { x: null, y: null, isIdentity: true };\n    }\n\n    let slope: number;\n\n    if (p1.x === p2.x && p1.y === p2.y) {\n      // Point doubling: slope = (3x₁² + a) / (2y₁)\n      const numerator = (3 * p1.x! * p1.x! + curve.a) % prime;\n      const denominator = (2 * p1.y!) % prime;\n      \n      if (denominator === 0) {\n        // Point is its own inverse (vertical tangent)\n        return { x: null, y: null, isIdentity: true };\n      }\n      \n      slope = (numerator * this.modInverse(denominator, prime)) % prime;\n    } else {\n      // Point addition: slope = (y₂ - y₁) / (x₂ - x₁)\n      const numerator = (p2.y! - p1.y! + prime) % prime;\n      const denominator = (p2.x! - p1.x! + prime) % prime;\n      \n      if (denominator === 0) {\n        // Vertical line case - points are inverses\n        return { x: null, y: null, isIdentity: true };\n      }\n      \n      slope = (numerator * this.modInverse(denominator, prime)) % prime;\n    }\n\n    // Calculate result point\n    const x3 = (slope * slope - p1.x! - p2.x! + prime * 3) % prime;\n    const y3 = (slope * (p1.x! - x3) - p1.y! + prime * 2) % prime;\n\n    return {\n      x: x3,\n      y: y3,\n      isIdentity: false\n    };\n  }\n\n  /**\n   * Scalar multiplication: multiply point by scalar\n   */\n  static scalarMultiply(\n    point: EllipticCurvePoint, \n    scalar: number, \n    curve: EllipticCurve\n  ): EllipticCurvePoint {\n    if (scalar === 0 || point.isIdentity) {\n      return { x: null, y: null, isIdentity: true };\n    }\n\n    if (scalar === 1) return { ...point };\n\n    let result: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n    let addend = { ...point };\n    \n    while (scalar > 0) {\n      if (scalar % 2 === 1) {\n        result = this.addPoints(result, addend, curve);\n      }\n      addend = this.addPoints(addend, addend, curve);\n      scalar = Math.floor(scalar / 2);\n    }\n\n    return result;\n  }\n\n  /**\n   * Find the order of a point (smallest positive integer n such that nP = O)\n   */\n  static getPointOrder(point: EllipticCurvePoint, curve: EllipticCurve): number {\n    if (point.isIdentity) return 1;\n\n    try {\n      let current = { ...point };\n      let order = 1;\n\n      while (!current.isIdentity && order < 100) { // Safety limit\n        current = this.addPoints(current, point, curve);\n        order++;\n      }\n\n      return current.isIdentity ? order : -1; // -1 indicates order > 100\n    } catch (error) {\n      console.warn(`⚠️ Failed to calculate order for point (${point.x}, ${point.y}):`, error);\n      return 1; // Return 1 as a safe default\n    }\n  }\n}\n\nexport class EllipticCurveGroupGenerator {\n  /**\n   * Generate all points on an elliptic curve over a finite field\n   */\n  static generateCurvePoints(curve: EllipticCurve): EllipticCurvePoint[] {\n    const points: EllipticCurvePoint[] = [];\n    \n    // Add point at infinity (identity element)\n    points.push({ x: null, y: null, isIdentity: true });\n\n    // Find all points (x, y) where y² ≡ x³ + ax + b (mod p)\n    for (let x = 0; x < curve.p; x++) {\n      const rhs = (x * x * x + curve.a * x + curve.b) % curve.p;\n      \n      for (let y = 0; y < curve.p; y++) {\n        if ((y * y) % curve.p === rhs) {\n          points.push({ x, y, isIdentity: false });\n        }\n      }\n    }\n\n    return points;\n  }\n\n  /**\n   * Create an elliptic curve group structure\n   */\n  static createEllipticCurveGroup(curve: EllipticCurve): EllipticCurveGroup {\n    const points = this.generateCurvePoints(curve);\n    \n    return {\n      curve,\n      points,\n      order: points.length,\n      name: `EC_${curve.name}`,\n      displayName: `E: y² = x³ + ${curve.a}x + ${curve.b} (mod ${curve.p})`\n    };\n  }\n\n  /**\n   * Get predefined elliptic curves for demonstration\n   */\n  static getPredefinedCurves(): EllipticCurve[] {\n    return [\n      {\n        a: 1, b: 1, p: 5,\n        name: 'E_5_1_1',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      },\n      {\n        a: 1, b: 6, p: 7,\n        name: 'E_7_1_6', \n        displayName: 'y² = x³ + x + 6 (mod 7)'\n      },\n      {\n        a: 2, b: 3, p: 7,\n        name: 'E_7_2_3',\n        displayName: 'y² = x³ + 2x + 3 (mod 7)'\n      },\n      {\n        a: 0, b: 7, p: 11,\n        name: 'E_11_0_7',\n        displayName: 'y² = x³ + 7 (mod 11)'\n      },\n      {\n        a: 1, b: 1, p: 11,\n        name: 'E_11_1_1',\n        displayName: 'y² = x³ + x + 1 (mod 11)'\n      },\n      {\n        a: 1, b: 0, p: 13,\n        name: 'E_13_1_0',\n        displayName: 'y² = x³ + x (mod 13)'\n      }\n    ];\n  }\n\n  /**\n   * Convert elliptic curve group to standard group format\n   */\n  static toStandardGroup(ecGroup: EllipticCurveGroup): any {\n    const { points, curve } = ecGroup;\n    \n    // Create group elements\n    const elements = points.map((point, index) => ({\n      id: `P${index}`,\n      label: point.isIdentity ? 'O' : `(${point.x},${point.y})`,\n      latex: point.isIdentity ? '\\\\mathcal{O}' : `(${point.x},${point.y})`,\n      order: EllipticCurveArithmetic.getPointOrder(point, curve),\n      inverse: '', // Will be calculated below\n      conjugacyClass: 0 // EC groups are abelian, so each element is its own conjugacy class\n    }));\n\n    // Calculate inverses\n    elements.forEach((element, i) => {\n      const point = points[i];\n      if (point.isIdentity) {\n        element.inverse = element.id;\n      } else {\n        // Find -P (same x, negated y)\n        const inversePoint = points.find(p => \n          !p.isIdentity && \n          p.x === point.x && \n          p.y === (curve.p - point.y!) % curve.p\n        );\n        element.inverse = inversePoint ? \n          `P${points.indexOf(inversePoint)}` : \n          element.id;\n      }\n    });\n\n    // Create operation table\n    const operations = new Map<string, Map<string, string>>();\n    elements.forEach((elem1, i) => {\n      const operationMap = new Map<string, string>();\n      elements.forEach((elem2, j) => {\n        const result = EllipticCurveArithmetic.addPoints(\n          points[i], \n          points[j], \n          curve\n        );\n        const resultIndex = points.findIndex(p => \n          p.isIdentity === result.isIdentity &&\n          p.x === result.x && \n          p.y === result.y\n        );\n        operationMap.set(elem2.id, `P${resultIndex}`);\n      });\n      operations.set(elem1.id, operationMap);\n    });\n\n    // Find generators (elements that generate the whole group)\n    const generators: string[] = [];\n    for (let i = 1; i < elements.length; i++) { // Skip identity\n      const element = elements[i];\n      if (element.order === elements.length) {\n        generators.push(element.id);\n      }\n    }\n\n    // If no single generator found, use the first non-identity element\n    if (generators.length === 0 && elements.length > 1) {\n      generators.push(elements[1].id);\n    }\n\n    return {\n      name: ecGroup.name,\n      displayName: ecGroup.displayName,\n      order: ecGroup.order,\n      elements,\n      operations,\n      generators,\n      relations: [], // Will be computed based on the structure\n      isAbelian: true, // Elliptic curve groups are always abelian\n      center: elements.map(e => e.id), // All elements (abelian group)\n      conjugacyClasses: elements.map(e => [e.id]), // Each element is its own class\n      subgroups: [] // Will be computed separately if needed\n    };\n  }\n}\n\n/**\n * Animation state for point addition visualization\n */\nexport interface PointAdditionAnimation {\n  step: 'selecting' | 'drawing_line' | 'finding_intersection' | 'reflecting' | 'completed';\n  point1?: EllipticCurvePoint;\n  point2?: EllipticCurvePoint;\n  result?: EllipticCurvePoint;\n  linePoints?: { x: number; y: number }[];\n  intersectionPoint?: { x: number; y: number };\n  progress: number; // 0 to 1\n}\n\nexport class EllipticCurveAnimator {\n  /**\n   * Generate animation frames for point addition\n   */\n  static generateAdditionAnimation(\n    p1: EllipticCurvePoint,\n    p2: EllipticCurvePoint,\n    curve: EllipticCurve,\n    canvasWidth: number = 800,\n    canvasHeight: number = 600\n  ): PointAdditionAnimation[] {\n    const frames: PointAdditionAnimation[] = [];\n    const result = EllipticCurveArithmetic.addPoints(p1, p2, curve);\n\n    // Step 1: Point selection\n    frames.push({\n      step: 'selecting',\n      point1: p1,\n      point2: p2,\n      progress: 0\n    });\n\n    // Step 2: Draw line through points\n    if (!p1.isIdentity && !p2.isIdentity) {\n      const linePoints = this.generateLinePoints(p1, p2, canvasWidth, canvasHeight);\n      frames.push({\n        step: 'drawing_line',\n        point1: p1,\n        point2: p2,\n        linePoints,\n        progress: 0.25\n      });\n\n      // Step 3: Find intersection point\n      frames.push({\n        step: 'finding_intersection',\n        point1: p1,\n        point2: p2,\n        linePoints,\n        intersectionPoint: { x: result.x || 0, y: result.y || 0 },\n        progress: 0.5\n      });\n\n      // Step 4: Reflect across x-axis\n      frames.push({\n        step: 'reflecting',\n        point1: p1,\n        point2: p2,\n        linePoints,\n        intersectionPoint: { x: result.x || 0, y: result.y || 0 },\n        result,\n        progress: 0.75\n      });\n    }\n\n    // Step 5: Completed\n    frames.push({\n      step: 'completed',\n      point1: p1,\n      point2: p2,\n      result,\n      progress: 1\n    });\n\n    return frames;\n  }\n\n  /**\n   * Generate points along a line for visualization\n   */\n  private static generateLinePoints(\n    p1: EllipticCurvePoint,\n    p2: EllipticCurvePoint,\n    width: number,\n    height: number\n  ): { x: number; y: number }[] {\n    if (p1.isIdentity || p2.isIdentity || p1.x === null || p2.x === null) {\n      return [];\n    }\n\n    const points: { x: number; y: number }[] = [];\n    const steps = 50;\n\n    if (p1.x === p2.x) {\n      // Vertical line\n      for (let i = 0; i <= steps; i++) {\n        points.push({\n          x: p1.x,\n          y: (i / steps) * height\n        });\n      }\n    } else {\n      // Calculate slope and extend line\n      const slope = (p2.y! - p1.y!) / (p2.x! - p1.x!);\n      const intercept = p1.y! - slope * p1.x!;\n\n      for (let x = 0; x <= width; x += width / steps) {\n        const y = slope * x + intercept;\n        if (y >= 0 && y <= height) {\n          points.push({ x, y });\n        }\n      }\n    }\n\n    return points;\n  }\n}"],"names":["EllipticCurveAnimator","EllipticCurveArithmetic","EllipticCurveGroupGenerator","modInverse","a","m","Error","oldR","r","oldS","s","quotient","Math","floor","modPow","base","exp","mod","result","isOnCurve","point","curve","isIdentity","x","y","b","p","leftSide","rightSide","addPoints","p1","p2","prime","slope","numerator","denominator","x3","y3","scalarMultiply","scalar","addend","getPointOrder","current","order","error","console","warn","generateCurvePoints","points","push","rhs","createEllipticCurveGroup","length","name","displayName","getPredefinedCurves","toStandardGroup","ecGroup","elements","map","index","id","label","latex","inverse","conjugacyClass","forEach","element","i","inversePoint","find","indexOf","operations","Map","elem1","operationMap","elem2","j","resultIndex","findIndex","set","generators","relations","isAbelian","center","e","conjugacyClasses","subgroups","generateAdditionAnimation","canvasWidth","canvasHeight","frames","step","point1","point2","progress","linePoints","generateLinePoints","intersectionPoint","width","height","steps","intercept"],"mappings":"AAAA;;;CAGC;;;;;;;;;;;IAyWYA,qBAAqB;eAArBA;;IAjVAC,uBAAuB;eAAvBA;;IAmKAC,2BAA2B;eAA3BA;;;AAnKN,MAAMD;IACX;;GAEC,GACD,OAAOE,WAAWC,CAAS,EAAEC,CAAS,EAAU;QAC9C,IAAIA,KAAK,GAAG,MAAM,IAAIC,MAAM;QAC5B,IAAIF,MAAM,GAAG,MAAM,IAAIE,MAAM;QAE7BF,IAAI,AAAC,CAAA,AAACA,IAAIC,IAAKA,CAAAA,IAAKA;QAEpB,IAAI,CAACE,MAAMC,EAAE,GAAG;YAACJ;YAAGC;SAAE;QACtB,IAAI,CAACI,MAAMC,EAAE,GAAG;YAAC;YAAG;SAAE;QAEtB,MAAOF,MAAM,EAAG;YACd,MAAMG,WAAWC,KAAKC,KAAK,CAACN,OAAOC;YACnC,CAACD,MAAMC,EAAE,GAAG;gBAACA;gBAAGD,OAAOI,WAAWH;aAAE;YACpC,CAACC,MAAMC,EAAE,GAAG;gBAACA;gBAAGD,OAAOE,WAAWD;aAAE;QACtC;QAEA,IAAIH,SAAS,GAAG;YACd,MAAM,IAAID,MAAM,CAAC,mBAAmB,EAAEF,EAAE,KAAK,EAAEC,EAAE,uBAAuB,EAAEE,KAAK,CAAC,CAAC;QACnF;QAEA,OAAO,AAAC,CAAA,AAACE,OAAOJ,IAAKA,CAAAA,IAAKA;IAC5B;IAEA;;GAEC,GACD,OAAOS,OAAOC,IAAY,EAAEC,GAAW,EAAEC,GAAW,EAAU;QAC5D,IAAIC,SAAS;QACbH,OAAOA,OAAOE;QACd,MAAOD,MAAM,EAAG;YACd,IAAIA,MAAM,MAAM,GAAG;gBACjBE,SAAS,AAACA,SAASH,OAAQE;YAC7B;YACAD,MAAMJ,KAAKC,KAAK,CAACG,MAAM;YACvBD,OAAO,AAACA,OAAOA,OAAQE;QACzB;QACA,OAAOC;IACT;IAEA;;GAEC,GACD,OAAOC,UAAUC,KAAyB,EAAEC,KAAoB,EAAW;QACzE,IAAID,MAAME,UAAU,EAAE,OAAO;QAC7B,IAAIF,MAAMG,CAAC,KAAK,QAAQH,MAAMI,CAAC,KAAK,MAAM,OAAOJ,MAAME,UAAU;QAEjE,MAAM,EAAElB,CAAC,EAAEqB,CAAC,EAAEC,CAAC,EAAE,GAAGL;QACpB,MAAMM,WAAW,AAACP,MAAMI,CAAC,GAAGJ,MAAMI,CAAC,GAAIE;QACvC,MAAME,YAAY,AAACR,CAAAA,MAAMG,CAAC,GAAGH,MAAMG,CAAC,GAAGH,MAAMG,CAAC,GAAGnB,IAAIgB,MAAMG,CAAC,GAAGE,CAAAA,IAAKC;QAEpE,OAAOC,aAAc,AAACC,CAAAA,YAAYF,IAAIA,CAAAA,IAAKA;IAC7C;IAEA;;GAEC,GACD,OAAOG,UACLC,EAAsB,EACtBC,EAAsB,EACtBV,KAAoB,EACA;QACpB,8CAA8C;QAC9C,IAAIS,GAAGR,UAAU,EAAE,OAAO;YAAE,GAAGS,EAAE;QAAC;QAClC,IAAIA,GAAGT,UAAU,EAAE,OAAO;YAAE,GAAGQ,EAAE;QAAC;QAElC,MAAM,EAAEJ,GAAGM,KAAK,EAAE,GAAGX;QAErB,sDAAsD;QACtD,IAAIS,GAAGP,CAAC,KAAKQ,GAAGR,CAAC,IAAIO,GAAGN,CAAC,KAAK,AAACQ,CAAAA,QAAQD,GAAGP,CAAC,IAAKQ,OAAO;YACrD,OAAO;gBAAET,GAAG;gBAAMC,GAAG;gBAAMF,YAAY;YAAK;QAC9C;QAEA,IAAIW;QAEJ,IAAIH,GAAGP,CAAC,KAAKQ,GAAGR,CAAC,IAAIO,GAAGN,CAAC,KAAKO,GAAGP,CAAC,EAAE;YAClC,6CAA6C;YAC7C,MAAMU,YAAY,AAAC,CAAA,IAAIJ,GAAGP,CAAC,GAAIO,GAAGP,CAAC,GAAIF,MAAMjB,CAAC,AAADA,IAAK4B;YAClD,MAAMG,cAAc,AAAC,IAAIL,GAAGN,CAAC,GAAKQ;YAElC,IAAIG,gBAAgB,GAAG;gBACrB,8CAA8C;gBAC9C,OAAO;oBAAEZ,GAAG;oBAAMC,GAAG;oBAAMF,YAAY;gBAAK;YAC9C;YAEAW,QAAQ,AAACC,YAAY,IAAI,CAAC/B,UAAU,CAACgC,aAAaH,SAAUA;QAC9D,OAAO;YACL,gDAAgD;YAChD,MAAME,YAAY,AAACH,CAAAA,GAAGP,CAAC,GAAIM,GAAGN,CAAC,GAAIQ,KAAI,IAAKA;YAC5C,MAAMG,cAAc,AAACJ,CAAAA,GAAGR,CAAC,GAAIO,GAAGP,CAAC,GAAIS,KAAI,IAAKA;YAE9C,IAAIG,gBAAgB,GAAG;gBACrB,2CAA2C;gBAC3C,OAAO;oBAAEZ,GAAG;oBAAMC,GAAG;oBAAMF,YAAY;gBAAK;YAC9C;YAEAW,QAAQ,AAACC,YAAY,IAAI,CAAC/B,UAAU,CAACgC,aAAaH,SAAUA;QAC9D;QAEA,yBAAyB;QACzB,MAAMI,KAAK,AAACH,CAAAA,QAAQA,QAAQH,GAAGP,CAAC,GAAIQ,GAAGR,CAAC,GAAIS,QAAQ,CAAA,IAAKA;QACzD,MAAMK,KAAK,AAACJ,CAAAA,QAASH,CAAAA,GAAGP,CAAC,GAAIa,EAAC,IAAKN,GAAGN,CAAC,GAAIQ,QAAQ,CAAA,IAAKA;QAExD,OAAO;YACLT,GAAGa;YACHZ,GAAGa;YACHf,YAAY;QACd;IACF;IAEA;;GAEC,GACD,OAAOgB,eACLlB,KAAyB,EACzBmB,MAAc,EACdlB,KAAoB,EACA;QACpB,IAAIkB,WAAW,KAAKnB,MAAME,UAAU,EAAE;YACpC,OAAO;gBAAEC,GAAG;gBAAMC,GAAG;gBAAMF,YAAY;YAAK;QAC9C;QAEA,IAAIiB,WAAW,GAAG,OAAO;YAAE,GAAGnB,KAAK;QAAC;QAEpC,IAAIF,SAA6B;YAAEK,GAAG;YAAMC,GAAG;YAAMF,YAAY;QAAK;QACtE,IAAIkB,SAAS;YAAE,GAAGpB,KAAK;QAAC;QAExB,MAAOmB,SAAS,EAAG;YACjB,IAAIA,SAAS,MAAM,GAAG;gBACpBrB,SAAS,IAAI,CAACW,SAAS,CAACX,QAAQsB,QAAQnB;YAC1C;YACAmB,SAAS,IAAI,CAACX,SAAS,CAACW,QAAQA,QAAQnB;YACxCkB,SAAS3B,KAAKC,KAAK,CAAC0B,SAAS;QAC/B;QAEA,OAAOrB;IACT;IAEA;;GAEC,GACD,OAAOuB,cAAcrB,KAAyB,EAAEC,KAAoB,EAAU;QAC5E,IAAID,MAAME,UAAU,EAAE,OAAO;QAE7B,IAAI;YACF,IAAIoB,UAAU;gBAAE,GAAGtB,KAAK;YAAC;YACzB,IAAIuB,QAAQ;YAEZ,MAAO,CAACD,QAAQpB,UAAU,IAAIqB,QAAQ,IAAK;gBACzCD,UAAU,IAAI,CAACb,SAAS,CAACa,SAAStB,OAAOC;gBACzCsB;YACF;YAEA,OAAOD,QAAQpB,UAAU,GAAGqB,QAAQ,CAAC,GAAG,2BAA2B;QACrE,EAAE,OAAOC,OAAO;YACdC,QAAQC,IAAI,CAAC,CAAC,wCAAwC,EAAE1B,MAAMG,CAAC,CAAC,EAAE,EAAEH,MAAMI,CAAC,CAAC,EAAE,CAAC,EAAEoB;YACjF,OAAO,GAAG,6BAA6B;QACzC;IACF;AACF;AAEO,MAAM1C;IACX;;GAEC,GACD,OAAO6C,oBAAoB1B,KAAoB,EAAwB;QACrE,MAAM2B,SAA+B,EAAE;QAEvC,2CAA2C;QAC3CA,OAAOC,IAAI,CAAC;YAAE1B,GAAG;YAAMC,GAAG;YAAMF,YAAY;QAAK;QAEjD,wDAAwD;QACxD,IAAK,IAAIC,IAAI,GAAGA,IAAIF,MAAMK,CAAC,EAAEH,IAAK;YAChC,MAAM2B,MAAM,AAAC3B,CAAAA,IAAIA,IAAIA,IAAIF,MAAMjB,CAAC,GAAGmB,IAAIF,MAAMI,CAAC,AAADA,IAAKJ,MAAMK,CAAC;YAEzD,IAAK,IAAIF,IAAI,GAAGA,IAAIH,MAAMK,CAAC,EAAEF,IAAK;gBAChC,IAAI,AAACA,IAAIA,IAAKH,MAAMK,CAAC,KAAKwB,KAAK;oBAC7BF,OAAOC,IAAI,CAAC;wBAAE1B;wBAAGC;wBAAGF,YAAY;oBAAM;gBACxC;YACF;QACF;QAEA,OAAO0B;IACT;IAEA;;GAEC,GACD,OAAOG,yBAAyB9B,KAAoB,EAAsB;QACxE,MAAM2B,SAAS,IAAI,CAACD,mBAAmB,CAAC1B;QAExC,OAAO;YACLA;YACA2B;YACAL,OAAOK,OAAOI,MAAM;YACpBC,MAAM,CAAC,GAAG,EAAEhC,MAAMgC,IAAI,EAAE;YACxBC,aAAa,CAAC,aAAa,EAAEjC,MAAMjB,CAAC,CAAC,IAAI,EAAEiB,MAAMI,CAAC,CAAC,MAAM,EAAEJ,MAAMK,CAAC,CAAC,CAAC,CAAC;QACvE;IACF;IAEA;;GAEC,GACD,OAAO6B,sBAAuC;QAC5C,OAAO;YACL;gBACEnD,GAAG;gBAAGqB,GAAG;gBAAGC,GAAG;gBACf2B,MAAM;gBACNC,aAAa;YACf;YACA;gBACElD,GAAG;gBAAGqB,GAAG;gBAAGC,GAAG;gBACf2B,MAAM;gBACNC,aAAa;YACf;YACA;gBACElD,GAAG;gBAAGqB,GAAG;gBAAGC,GAAG;gBACf2B,MAAM;gBACNC,aAAa;YACf;YACA;gBACElD,GAAG;gBAAGqB,GAAG;gBAAGC,GAAG;gBACf2B,MAAM;gBACNC,aAAa;YACf;YACA;gBACElD,GAAG;gBAAGqB,GAAG;gBAAGC,GAAG;gBACf2B,MAAM;gBACNC,aAAa;YACf;YACA;gBACElD,GAAG;gBAAGqB,GAAG;gBAAGC,GAAG;gBACf2B,MAAM;gBACNC,aAAa;YACf;SACD;IACH;IAEA;;GAEC,GACD,OAAOE,gBAAgBC,OAA2B,EAAO;QACvD,MAAM,EAAET,MAAM,EAAE3B,KAAK,EAAE,GAAGoC;QAE1B,wBAAwB;QACxB,MAAMC,WAAWV,OAAOW,GAAG,CAAC,CAACvC,OAAOwC,QAAW,CAAA;gBAC7CC,IAAI,CAAC,CAAC,EAAED,OAAO;gBACfE,OAAO1C,MAAME,UAAU,GAAG,MAAM,CAAC,CAAC,EAAEF,MAAMG,CAAC,CAAC,CAAC,EAAEH,MAAMI,CAAC,CAAC,CAAC,CAAC;gBACzDuC,OAAO3C,MAAME,UAAU,GAAG,iBAAiB,CAAC,CAAC,EAAEF,MAAMG,CAAC,CAAC,CAAC,EAAEH,MAAMI,CAAC,CAAC,CAAC,CAAC;gBACpEmB,OAAO1C,wBAAwBwC,aAAa,CAACrB,OAAOC;gBACpD2C,SAAS;gBACTC,gBAAgB,EAAE,oEAAoE;YACxF,CAAA;QAEA,qBAAqB;QACrBP,SAASQ,OAAO,CAAC,CAACC,SAASC;YACzB,MAAMhD,QAAQ4B,MAAM,CAACoB,EAAE;YACvB,IAAIhD,MAAME,UAAU,EAAE;gBACpB6C,QAAQH,OAAO,GAAGG,QAAQN,EAAE;YAC9B,OAAO;gBACL,8BAA8B;gBAC9B,MAAMQ,eAAerB,OAAOsB,IAAI,CAAC5C,CAAAA,IAC/B,CAACA,EAAEJ,UAAU,IACbI,EAAEH,CAAC,KAAKH,MAAMG,CAAC,IACfG,EAAEF,CAAC,KAAK,AAACH,CAAAA,MAAMK,CAAC,GAAGN,MAAMI,CAAC,IAAKH,MAAMK,CAAC;gBAExCyC,QAAQH,OAAO,GAAGK,eAChB,CAAC,CAAC,EAAErB,OAAOuB,OAAO,CAACF,eAAe,GAClCF,QAAQN,EAAE;YACd;QACF;QAEA,yBAAyB;QACzB,MAAMW,aAAa,IAAIC;QACvBf,SAASQ,OAAO,CAAC,CAACQ,OAAON;YACvB,MAAMO,eAAe,IAAIF;YACzBf,SAASQ,OAAO,CAAC,CAACU,OAAOC;gBACvB,MAAM3D,SAASjB,wBAAwB4B,SAAS,CAC9CmB,MAAM,CAACoB,EAAE,EACTpB,MAAM,CAAC6B,EAAE,EACTxD;gBAEF,MAAMyD,cAAc9B,OAAO+B,SAAS,CAACrD,CAAAA,IACnCA,EAAEJ,UAAU,KAAKJ,OAAOI,UAAU,IAClCI,EAAEH,CAAC,KAAKL,OAAOK,CAAC,IAChBG,EAAEF,CAAC,KAAKN,OAAOM,CAAC;gBAElBmD,aAAaK,GAAG,CAACJ,MAAMf,EAAE,EAAE,CAAC,CAAC,EAAEiB,aAAa;YAC9C;YACAN,WAAWQ,GAAG,CAACN,MAAMb,EAAE,EAAEc;QAC3B;QAEA,2DAA2D;QAC3D,MAAMM,aAAuB,EAAE;QAC/B,IAAK,IAAIb,IAAI,GAAGA,IAAIV,SAASN,MAAM,EAAEgB,IAAK;YACxC,MAAMD,UAAUT,QAAQ,CAACU,EAAE;YAC3B,IAAID,QAAQxB,KAAK,KAAKe,SAASN,MAAM,EAAE;gBACrC6B,WAAWhC,IAAI,CAACkB,QAAQN,EAAE;YAC5B;QACF;QAEA,mEAAmE;QACnE,IAAIoB,WAAW7B,MAAM,KAAK,KAAKM,SAASN,MAAM,GAAG,GAAG;YAClD6B,WAAWhC,IAAI,CAACS,QAAQ,CAAC,EAAE,CAACG,EAAE;QAChC;QAEA,OAAO;YACLR,MAAMI,QAAQJ,IAAI;YAClBC,aAAaG,QAAQH,WAAW;YAChCX,OAAOc,QAAQd,KAAK;YACpBe;YACAc;YACAS;YACAC,WAAW,EAAE;YACbC,WAAW;YACXC,QAAQ1B,SAASC,GAAG,CAAC0B,CAAAA,IAAKA,EAAExB,EAAE;YAC9ByB,kBAAkB5B,SAASC,GAAG,CAAC0B,CAAAA,IAAK;oBAACA,EAAExB,EAAE;iBAAC;YAC1C0B,WAAW,EAAE,CAAC,wCAAwC;QACxD;IACF;AACF;AAeO,MAAMvF;IACX;;GAEC,GACD,OAAOwF,0BACL1D,EAAsB,EACtBC,EAAsB,EACtBV,KAAoB,EACpBoE,cAAsB,GAAG,EACzBC,eAAuB,GAAG,EACA;QAC1B,MAAMC,SAAmC,EAAE;QAC3C,MAAMzE,SAASjB,wBAAwB4B,SAAS,CAACC,IAAIC,IAAIV;QAEzD,0BAA0B;QAC1BsE,OAAO1C,IAAI,CAAC;YACV2C,MAAM;YACNC,QAAQ/D;YACRgE,QAAQ/D;YACRgE,UAAU;QACZ;QAEA,mCAAmC;QACnC,IAAI,CAACjE,GAAGR,UAAU,IAAI,CAACS,GAAGT,UAAU,EAAE;YACpC,MAAM0E,aAAa,IAAI,CAACC,kBAAkB,CAACnE,IAAIC,IAAI0D,aAAaC;YAChEC,OAAO1C,IAAI,CAAC;gBACV2C,MAAM;gBACNC,QAAQ/D;gBACRgE,QAAQ/D;gBACRiE;gBACAD,UAAU;YACZ;YAEA,kCAAkC;YAClCJ,OAAO1C,IAAI,CAAC;gBACV2C,MAAM;gBACNC,QAAQ/D;gBACRgE,QAAQ/D;gBACRiE;gBACAE,mBAAmB;oBAAE3E,GAAGL,OAAOK,CAAC,IAAI;oBAAGC,GAAGN,OAAOM,CAAC,IAAI;gBAAE;gBACxDuE,UAAU;YACZ;YAEA,gCAAgC;YAChCJ,OAAO1C,IAAI,CAAC;gBACV2C,MAAM;gBACNC,QAAQ/D;gBACRgE,QAAQ/D;gBACRiE;gBACAE,mBAAmB;oBAAE3E,GAAGL,OAAOK,CAAC,IAAI;oBAAGC,GAAGN,OAAOM,CAAC,IAAI;gBAAE;gBACxDN;gBACA6E,UAAU;YACZ;QACF;QAEA,oBAAoB;QACpBJ,OAAO1C,IAAI,CAAC;YACV2C,MAAM;YACNC,QAAQ/D;YACRgE,QAAQ/D;YACRb;YACA6E,UAAU;QACZ;QAEA,OAAOJ;IACT;IAEA;;GAEC,GACD,OAAeM,mBACbnE,EAAsB,EACtBC,EAAsB,EACtBoE,KAAa,EACbC,MAAc,EACc;QAC5B,IAAItE,GAAGR,UAAU,IAAIS,GAAGT,UAAU,IAAIQ,GAAGP,CAAC,KAAK,QAAQQ,GAAGR,CAAC,KAAK,MAAM;YACpE,OAAO,EAAE;QACX;QAEA,MAAMyB,SAAqC,EAAE;QAC7C,MAAMqD,QAAQ;QAEd,IAAIvE,GAAGP,CAAC,KAAKQ,GAAGR,CAAC,EAAE;YACjB,gBAAgB;YAChB,IAAK,IAAI6C,IAAI,GAAGA,KAAKiC,OAAOjC,IAAK;gBAC/BpB,OAAOC,IAAI,CAAC;oBACV1B,GAAGO,GAAGP,CAAC;oBACPC,GAAG,AAAC4C,IAAIiC,QAASD;gBACnB;YACF;QACF,OAAO;YACL,kCAAkC;YAClC,MAAMnE,QAAQ,AAACF,CAAAA,GAAGP,CAAC,GAAIM,GAAGN,CAAC,IAAMO,CAAAA,GAAGR,CAAC,GAAIO,GAAGP,CAAC;YAC7C,MAAM+E,YAAYxE,GAAGN,CAAC,GAAIS,QAAQH,GAAGP,CAAC;YAEtC,IAAK,IAAIA,IAAI,GAAGA,KAAK4E,OAAO5E,KAAK4E,QAAQE,MAAO;gBAC9C,MAAM7E,IAAIS,QAAQV,IAAI+E;gBACtB,IAAI9E,KAAK,KAAKA,KAAK4E,QAAQ;oBACzBpD,OAAOC,IAAI,CAAC;wBAAE1B;wBAAGC;oBAAE;gBACrB;YACF;QACF;QAEA,OAAOwB;IACT;AACF"}