{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/__tests__/lib/EllipticCurveGroup.test.ts"],"sourcesContent":["/**\n * Comprehensive Jest Unit Tests for Elliptic Curve Groups\n * Tests mathematical accuracy, group properties, and arithmetic operations\n */\n\nimport {\n  EllipticCurveArithmetic,\n  EllipticCurveGroupGenerator,\n  EllipticCurveAnimator,\n  type EllipticCurve,\n  type EllipticCurvePoint,\n  type EllipticCurveGroup,\n  type PointAdditionAnimation\n} from '@/lib/EllipticCurveGroups';\nimport { \n  mathematicalMatchers,\n  MATHEMATICAL_PRECISION,\n  EllipticCurveValidator,\n  ValidationResult,\n  aggregateValidationResults\n} from '../utils/mathematicalValidation';\n\n// Extend Jest matchers\nexpect.extend(mathematicalMatchers);\n\ndescribe('EllipticCurveArithmetic', () => {\n  \n  describe('Modular Arithmetic Operations', () => {\n    \n    test('calculates modular inverse correctly', () => {\n      expect(EllipticCurveArithmetic.modInverse(3, 7)).toBe(5); // 3 * 5 ≡ 1 (mod 7)\n      expect(EllipticCurveArithmetic.modInverse(2, 5)).toBe(3); // 2 * 3 ≡ 1 (mod 5)\n      expect(EllipticCurveArithmetic.modInverse(7, 11)).toBe(8); // 7 * 8 ≡ 1 (mod 11)\n    });\n    \n    test('throws error for invalid modular inverse inputs', () => {\n      expect(() => EllipticCurveArithmetic.modInverse(0, 5)).toThrow('Cannot find inverse of 0');\n      expect(() => EllipticCurveArithmetic.modInverse(3, 0)).toThrow('Modulus must be positive');\n      expect(() => EllipticCurveArithmetic.modInverse(6, 9)).toThrow('does not exist'); // gcd(6,9) = 3 ≠ 1\n    });\n    \n    test('calculates modular exponentiation correctly', () => {\n      expect(EllipticCurveArithmetic.modPow(2, 3, 5)).toBe(3); // 2³ ≡ 3 (mod 5)\n      expect(EllipticCurveArithmetic.modPow(3, 4, 7)).toBe(4); // 3⁴ ≡ 4 (mod 7)\n      expect(EllipticCurveArithmetic.modPow(5, 0, 13)).toBe(1); // x⁰ ≡ 1 (mod n)\n    });\n    \n    test('handles edge cases in modular operations', () => {\n      expect(EllipticCurveArithmetic.modPow(0, 5, 7)).toBe(0);\n      expect(EllipticCurveArithmetic.modPow(1, 100, 13)).toBe(1);\n      expect(EllipticCurveArithmetic.modInverse(-2, 7)).toBe(3); // -2 ≡ 5 (mod 7), 5⁻¹ ≡ 3\n    });\n  });\n\n  describe('Point Validation', () => {\n    const testCurve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    test('validates points on curve correctly', () => {\n      const validPoint: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      const invalidPoint: EllipticCurvePoint = { x: 1, y: 1, isIdentity: false };\n      const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n\n      expect(EllipticCurveArithmetic.isOnCurve(validPoint, testCurve)).toBe(true);\n      expect(EllipticCurveArithmetic.isOnCurve(invalidPoint, testCurve)).toBe(false);\n      expect(EllipticCurveArithmetic.isOnCurve(identityPoint, testCurve)).toBe(true);\n    });\n\n    test('validates identity point handling', () => {\n      const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      expect(EllipticCurveArithmetic.isOnCurve(identityPoint, testCurve)).toBe(true);\n      \n      // Test malformed identity points\n      const malformedIdentity1: EllipticCurvePoint = { x: 5, y: null, isIdentity: true };\n      const malformedIdentity2: EllipticCurvePoint = { x: null, y: 3, isIdentity: true };\n      \n      expect(EllipticCurveArithmetic.isOnCurve(malformedIdentity1, testCurve)).toBe(true);\n      expect(EllipticCurveArithmetic.isOnCurve(malformedIdentity2, testCurve)).toBe(true);\n    });\n\n    test('validates points using mathematical validation framework', () => {\n      const validPoint: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      expect(validPoint).toBeValidEllipticCurvePoint(testCurve);\n      \n      const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      expect(identityPoint).toBeValidEllipticCurvePoint(testCurve);\n    });\n  });\n\n  // Helper function to normalize point coordinates to [0, p-1]\n  const normalizePoint = (point: EllipticCurvePoint, p: number): EllipticCurvePoint => {\n    if (point.isIdentity) return point;\n    return {\n      x: point.x !== null ? ((point.x % p) + p) % p : null,\n      y: point.y !== null ? ((point.y % p) + p) % p : null,\n      isIdentity: false\n    };\n  };\n\n  describe('Point Addition', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    const identityPoint: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n    const point1: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n    const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n\n    test('handles identity element correctly', () => {\n      const result1 = EllipticCurveArithmetic.addPoints(identityPoint, point1, curve);\n      const result2 = EllipticCurveArithmetic.addPoints(point1, identityPoint, curve);\n      \n      expect(result1).toEqual(point1);\n      expect(result2).toEqual(point1);\n      expect(normalizePoint(result1, curve.p)).toBeValidEllipticCurvePoint(curve);\n      expect(normalizePoint(result2, curve.p)).toBeValidEllipticCurvePoint(curve);\n    });\n\n    test('adds distinct points correctly', () => {\n      const result = EllipticCurveArithmetic.addPoints(point1, point2, curve);\n      const normalized = normalizePoint(result, curve.p);\n      \n      expect(result.isIdentity).toBe(false);\n      expect(normalized).toBeValidEllipticCurvePoint(curve);\n      expect(EllipticCurveArithmetic.isOnCurve(result, curve)).toBe(true);\n    });\n\n    test('handles point doubling', () => {\n      const result = EllipticCurveArithmetic.addPoints(point1, point1, curve);\n      const normalized = normalizePoint(result, curve.p);\n      \n      expect(normalized).toBeValidEllipticCurvePoint(curve);\n      expect(EllipticCurveArithmetic.isOnCurve(result, curve)).toBe(true);\n    });\n\n    test('handles inverse points correctly', () => {\n      const point: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      const inversePoint: EllipticCurvePoint = { x: 0, y: 4, isIdentity: false }; // -1 ≡ 4 (mod 5)\n      \n      const result = EllipticCurveArithmetic.addPoints(point, inversePoint, curve);\n      \n      expect(result.isIdentity).toBe(true);\n      expect(result.x).toBeNull();\n      expect(result.y).toBeNull();\n    });\n\n    test('handles vertical tangent case', () => {\n      // Find a point where doubling gives identity (has order 2)\n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const orderTwoPoint = points.find(p => \n        !p.isIdentity && \n        EllipticCurveArithmetic.getPointOrder(p, curve) === 2\n      );\n      \n      if (orderTwoPoint) {\n        const result = EllipticCurveArithmetic.addPoints(orderTwoPoint, orderTwoPoint, curve);\n        expect(result.isIdentity).toBe(true);\n      }\n    });\n\n    test('validates group law properties', () => {\n      const points = [\n        identityPoint,\n        point1,\n        point2,\n        { x: 3, y: 0, isIdentity: false }\n      ].filter(p => EllipticCurveArithmetic.isOnCurve(p, curve));\n\n      // Test associativity: (P + Q) + R = P + (Q + R)\n      for (let i = 0; i < points.length && i < 3; i++) {\n        for (let j = 0; j < points.length && j < 3; j++) {\n          for (let k = 0; k < points.length && k < 3; k++) {\n            const p = points[i];\n            const q = points[j];\n            const r = points[k];\n\n            const left = EllipticCurveArithmetic.addPoints(\n              EllipticCurveArithmetic.addPoints(p, q, curve),\n              r,\n              curve\n            );\n            const right = EllipticCurveArithmetic.addPoints(\n              p,\n              EllipticCurveArithmetic.addPoints(q, r, curve),\n              curve\n            );\n\n            // Normalize both results for comparison\n            const leftNorm = normalizePoint(left, curve.p);\n            const rightNorm = normalizePoint(right, curve.p);\n\n            expect(leftNorm.isIdentity).toBe(rightNorm.isIdentity);\n            if (!leftNorm.isIdentity && !rightNorm.isIdentity) {\n              expect(leftNorm.x).toBe(rightNorm.x);\n              expect(leftNorm.y).toBe(rightNorm.y);\n            }\n          }\n        }\n      }\n    });\n\n    test('validates commutativity: P + Q = Q + P', () => {\n      const result1 = EllipticCurveArithmetic.addPoints(point1, point2, curve);\n      const result2 = EllipticCurveArithmetic.addPoints(point2, point1, curve);\n      \n      expect(result1.isIdentity).toBe(result2.isIdentity);\n      if (!result1.isIdentity) {\n        expect(result1.x).toBe(result2.x);\n        expect(result1.y).toBe(result2.y);\n      }\n    });\n  });\n\n  describe('Scalar Multiplication', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    const basePoint: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n\n    test('handles scalar multiplication edge cases', () => {\n      const result0 = EllipticCurveArithmetic.scalarMultiply(basePoint, 0, curve);\n      const result1 = EllipticCurveArithmetic.scalarMultiply(basePoint, 1, curve);\n      \n      expect(result0.isIdentity).toBe(true);\n      expect(result1).toEqual(basePoint);\n    });\n\n    test('performs scalar multiplication correctly', () => {\n      const result2 = EllipticCurveArithmetic.scalarMultiply(basePoint, 2, curve);\n      const result3 = EllipticCurveArithmetic.scalarMultiply(basePoint, 3, curve);\n      \n      // 2P should equal P + P\n      const doubling = EllipticCurveArithmetic.addPoints(basePoint, basePoint, curve);\n      const result2Norm = normalizePoint(result2, curve.p);\n      const doublingNorm = normalizePoint(doubling, curve.p);\n      expect(result2Norm).toEqual(doublingNorm);\n      \n      // Results should be on curve\n      expect(result2Norm).toBeValidEllipticCurvePoint(curve);\n      expect(normalizePoint(result3, curve.p)).toBeValidEllipticCurvePoint(curve);\n    });\n\n    test('validates distributive property: k(P + Q) = kP + kQ', () => {\n      const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n      const k = 3;\n      \n      if (EllipticCurveArithmetic.isOnCurve(point2, curve)) {\n        const sum = EllipticCurveArithmetic.addPoints(basePoint, point2, curve);\n        const left = EllipticCurveArithmetic.scalarMultiply(sum, k, curve);\n        \n        const kP = EllipticCurveArithmetic.scalarMultiply(basePoint, k, curve);\n        const kQ = EllipticCurveArithmetic.scalarMultiply(point2, k, curve);\n        const right = EllipticCurveArithmetic.addPoints(kP, kQ, curve);\n        \n        expect(left.isIdentity).toBe(right.isIdentity);\n        if (!left.isIdentity) {\n          expect(left.x).toBe(right.x);\n          expect(left.y).toBe(right.y);\n        }\n      }\n    });\n\n    test('handles identity point in scalar multiplication', () => {\n      const identity: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      const result = EllipticCurveArithmetic.scalarMultiply(identity, 5, curve);\n      \n      expect(result.isIdentity).toBe(true);\n    });\n  });\n\n  describe('Point Order Calculation', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    test('calculates point orders correctly', () => {\n      const identity: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n      expect(EllipticCurveArithmetic.getPointOrder(identity, curve)).toBe(1);\n      \n      // Generate all points and test their orders\n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      \n      points.forEach(point => {\n        const order = EllipticCurveArithmetic.getPointOrder(point, curve);\n        expect(order).toBeGreaterThan(0);\n        \n        if (order !== -1) { // Order found within limit\n          // Verify that order * point = identity\n          const result = EllipticCurveArithmetic.scalarMultiply(point, order, curve);\n          expect(result.isIdentity).toBe(true);\n        }\n      });\n    });\n\n    test('validates Lagrange theorem for point orders', () => {\n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const groupOrder = points.length;\n      \n      points.forEach(point => {\n        const pointOrder = EllipticCurveArithmetic.getPointOrder(point, curve);\n        if (pointOrder !== -1 && pointOrder > 0) {\n          expect(groupOrder % pointOrder).toBe(0);\n        }\n      });\n    });\n\n    test('handles edge cases in order calculation', () => {\n      // Test with a problematic curve where computation might fail\n      const badCurve: EllipticCurve = {\n        a: 0, b: 0, p: 2, // Singular curve\n        name: 'bad_curve',\n        displayName: 'y² = x³ (mod 2)'\n      };\n      \n      const point: EllipticCurvePoint = { x: 1, y: 1, isIdentity: false };\n      const order = EllipticCurveArithmetic.getPointOrder(point, badCurve);\n      \n      // Should handle gracefully, returning valid order or -1\n      expect(typeof order).toBe('number');\n      expect(order).toBeGreaterThanOrEqual(-1);\n    });\n  });\n});\n\ndescribe('EllipticCurveGroupGenerator', () => {\n  \n  describe('Point Generation', () => {\n    \n    test('generates valid curve points', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      \n      expect(Array.isArray(points)).toBe(true);\n      expect(points.length).toBeGreaterThan(0);\n      \n      // First point should be identity\n      expect(points[0].isIdentity).toBe(true);\n      expect(points[0].x).toBeNull();\n      expect(points[0].y).toBeNull();\n      \n      // All points should be on the curve\n      points.forEach(point => {\n        expect(EllipticCurveArithmetic.isOnCurve(point, curve)).toBe(true);\n        expect(point).toBeValidEllipticCurvePoint(curve);\n      });\n    });\n\n    test('generates reasonable number of points for known curves', () => {\n      // Test that curves generate a reasonable number of points within Hasse bound\n      const curves = [\n        {\n          a: 1, b: 1, p: 5,\n          name: 'E_5_1_1',\n          displayName: 'y² = x³ + x + 1 (mod 5)'\n        },\n        {\n          a: 1, b: 6, p: 7,\n          name: 'E_7_1_6',\n          displayName: 'y² = x³ + x + 6 (mod 7)'\n        }\n      ];\n      \n      curves.forEach(curve => {\n        const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n        \n        // Should have at least the identity point\n        expect(points.length).toBeGreaterThan(0);\n        \n        // Should satisfy Hasse bound: |#E(Fp) - (p + 1)| ≤ 2√p\n        const bound = 2 * Math.sqrt(curve.p);\n        const difference = Math.abs(points.length - (curve.p + 1));\n        expect(difference).toBeLessThanOrEqual(bound);\n        \n        // Log actual counts for verification\n        console.log(`Curve ${curve.name}: generated ${points.length} points (expected around ${curve.p + 1})`);\n      });\n    });\n\n    test('validates Hasse bound for generated groups', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n      \n      curves.forEach(curve => {\n        const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n        const groupOrder = points.length;\n        \n        // Hasse bound: |#E(Fp) - (p + 1)| ≤ 2√p\n        const bound = 2 * Math.sqrt(curve.p);\n        const difference = Math.abs(groupOrder - (curve.p + 1));\n        \n        expect(difference).toBeLessThanOrEqual(bound);\n      });\n    });\n\n    test('generates unique points', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const pointStrings = points.map(p => \n        p.isIdentity ? 'O' : `(${p.x},${p.y})`\n      );\n      const uniquePoints = new Set(pointStrings);\n      \n      expect(uniquePoints.size).toBe(points.length);\n    });\n  });\n\n  describe('Group Creation', () => {\n    \n    test('creates valid elliptic curve group structure', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'E_5_1_1',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const group = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      \n      expect(group.curve).toEqual(curve);\n      expect(group.name).toBe('EC_E_5_1_1');\n      expect(group.displayName).toBe('E: y² = x³ + 1x + 1 (mod 5)');\n      expect(group.order).toBe(group.points.length);\n      expect(group.points.length).toBeGreaterThan(0);\n      expect(group.points[0].isIdentity).toBe(true);\n    });\n\n    test('validates group properties', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves().slice(0, 3);\n      \n      curves.forEach(curve => {\n        const group = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n        \n        expect(group.order).toBeGreaterThan(0);\n        expect(group.points.length).toBe(group.order);\n        expect(group.name).toContain('EC_');\n        expect(group.displayName).toContain('y²');\n        expect(group.displayName).toContain(`(mod ${curve.p})`);\n      });\n    });\n  });\n\n  describe('Predefined Curves', () => {\n    \n    test('provides valid predefined curves', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n      \n      expect(Array.isArray(curves)).toBe(true);\n      expect(curves.length).toBeGreaterThan(0);\n      \n      curves.forEach(curve => {\n        expect(curve).toHaveProperty('a');\n        expect(curve).toHaveProperty('b');\n        expect(curve).toHaveProperty('p');\n        expect(curve).toHaveProperty('name');\n        expect(curve).toHaveProperty('displayName');\n        \n        expect(typeof curve.a).toBe('number');\n        expect(typeof curve.b).toBe('number');\n        expect(typeof curve.p).toBe('number');\n        expect(typeof curve.name).toBe('string');\n        expect(typeof curve.displayName).toBe('string');\n        \n        expect(curve.p).toBeGreaterThan(1);\n        expect(Number.isInteger(curve.p)).toBe(true);\n        \n        // Validate using mathematical validation framework\n        const validation = EllipticCurveValidator.validateCurve(curve);\n        expect(validation.isValid).toBe(true);\n      });\n    });\n\n    test('validates discriminant for predefined curves', () => {\n      const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n      \n      curves.forEach(curve => {\n        // Check discriminant: Δ = -16(4a³ + 27b²) ≠ 0 (mod p)\n        const discriminant = -16 * (4 * Math.pow(curve.a, 3) + 27 * Math.pow(curve.b, 2));\n        expect(discriminant % curve.p).not.toBe(0);\n      });\n    });\n  });\n\n  describe('Standard Group Conversion', () => {\n    \n    test('converts to standard group format correctly', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'E_5_1_1',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      expect(standardGroup.name).toBe(ecGroup.name);\n      expect(standardGroup.displayName).toBe(ecGroup.displayName);\n      expect(standardGroup.order).toBe(ecGroup.order);\n      expect(standardGroup.isAbelian).toBe(true);\n      expect(Array.isArray(standardGroup.elements)).toBe(true);\n      expect(standardGroup.operations instanceof Map).toBe(true);\n      expect(Array.isArray(standardGroup.generators)).toBe(true);\n      \n      // Validate element structure\n      standardGroup.elements.forEach((element: any) => {\n        expect(element).toHaveProperty('id');\n        expect(element).toHaveProperty('label');\n        expect(element).toHaveProperty('latex');\n        expect(element).toHaveProperty('order');\n        expect(element).toHaveProperty('inverse');\n        expect(element).toHaveProperty('conjugacyClass');\n        \n        expect(typeof element.id).toBe('string');\n        expect(typeof element.label).toBe('string');\n        expect(typeof element.latex).toBe('string');\n        expect(typeof element.order).toBe('number');\n        expect(typeof element.inverse).toBe('string');\n        expect(typeof element.conjugacyClass).toBe('number');\n      });\n    });\n\n    test('validates operation table in standard group', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      // Check operation table completeness\n      expect(standardGroup.operations.size).toBe(standardGroup.order);\n      \n      standardGroup.operations.forEach((operationMap: Map<string, string>, element1: string) => {\n        expect(operationMap.size).toBe(standardGroup.order);\n        \n        operationMap.forEach((result: string, element2: string) => {\n          // Result should be a valid element ID - debug the issue\n          const isValidElement = standardGroup.elements.some((e: any) => e.id === result);\n          if (!isValidElement) {\n            console.log(`Invalid result: ${result}, available elements: ${standardGroup.elements.map((e: any) => e.id).join(', ')}`);\n          }\n          expect(isValidElement).toBe(true);\n        });\n      });\n    });\n\n    test('validates inverse relationships in standard group', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      standardGroup.elements.forEach((element: any) => {\n        const inverse = standardGroup.elements.find((e: any) => e.id === element.inverse);\n        expect(inverse).toBeDefined();\n        \n        // Check that element * inverse = identity\n        const product = standardGroup.operations.get(element.id)?.get(element.inverse);\n        expect(product).toBe('P0'); // P0 should be identity\n      });\n    });\n  });\n});\n\ndescribe('EllipticCurveAnimator', () => {\n  \n  describe('Animation Generation', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'test_curve',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n\n    const point1: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n    const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n    const identity: EllipticCurvePoint = { x: null, y: null, isIdentity: true };\n\n    test('generates valid animation frames for point addition', () => {\n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve, 800, 600\n      );\n      \n      expect(Array.isArray(frames)).toBe(true);\n      expect(frames.length).toBeGreaterThan(0);\n      \n      // Check frame structure\n      frames.forEach(frame => {\n        expect(frame).toHaveProperty('step');\n        expect(frame).toHaveProperty('progress');\n        expect(typeof frame.step).toBe('string');\n        expect(typeof frame.progress).toBe('number');\n        expect(frame.progress).toBeGreaterThanOrEqual(0);\n        expect(frame.progress).toBeLessThanOrEqual(1);\n      });\n      \n      // First frame should be 'selecting'\n      expect(frames[0].step).toBe('selecting');\n      expect(frames[0].progress).toBe(0);\n      \n      // Last frame should be 'completed'\n      expect(frames[frames.length - 1].step).toBe('completed');\n      expect(frames[frames.length - 1].progress).toBe(1);\n    });\n\n    test('handles identity point animations', () => {\n      const frames1 = EllipticCurveAnimator.generateAdditionAnimation(\n        identity, point1, curve\n      );\n      const frames2 = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, identity, curve\n      );\n      \n      expect(frames1.length).toBeGreaterThan(0);\n      expect(frames2.length).toBeGreaterThan(0);\n      \n      // Should start with selecting and end with completed\n      expect(frames1[0].step).toBe('selecting');\n      expect(frames1[frames1.length - 1].step).toBe('completed');\n      expect(frames2[0].step).toBe('selecting');\n      expect(frames2[frames2.length - 1].step).toBe('completed');\n    });\n\n    test('validates animation progression', () => {\n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve\n      );\n      \n      // Progress should be monotonically increasing\n      for (let i = 1; i < frames.length; i++) {\n        expect(frames[i].progress).toBeGreaterThanOrEqual(frames[i - 1].progress);\n      }\n      \n      // All expected steps should be present for non-identity points\n      const steps = frames.map(f => f.step);\n      expect(steps).toContain('selecting');\n      expect(steps).toContain('completed');\n    });\n\n    test('handles edge cases in animation generation', () => {\n      // Same point (doubling)\n      const doublingFrames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point1, curve\n      );\n      expect(doublingFrames.length).toBeGreaterThan(0);\n      \n      // Both identity points\n      const identityFrames = EllipticCurveAnimator.generateAdditionAnimation(\n        identity, identity, curve\n      );\n      expect(identityFrames.length).toBeGreaterThan(0);\n    });\n\n    test('validates animation results match arithmetic', () => {\n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve\n      );\n      \n      const lastFrame = frames[frames.length - 1];\n      const arithmeticResult = EllipticCurveArithmetic.addPoints(point1, point2, curve);\n      \n      expect(lastFrame.result).toEqual(arithmeticResult);\n    });\n  });\n\n  describe('Performance and Edge Cases', () => {\n    \n    test('generates animations efficiently', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 11,\n        name: 'perf_test',\n        displayName: 'y² = x³ + x + 1 (mod 11)'\n      };\n      \n      const points = EllipticCurveGroupGenerator.generateCurvePoints(curve);\n      const startTime = performance.now();\n      \n      // Generate animations for first few point pairs\n      for (let i = 0; i < Math.min(3, points.length); i++) {\n        for (let j = 0; j < Math.min(3, points.length); j++) {\n          EllipticCurveAnimator.generateAdditionAnimation(\n            points[i], points[j], curve\n          );\n        }\n      }\n      \n      const endTime = performance.now();\n      expect(endTime - startTime).toBeLessThan(100); // Should be fast\n    });\n\n    test('handles large canvas dimensions', () => {\n      const curve: EllipticCurve = {\n        a: 1, b: 1, p: 5,\n        name: 'test_curve',\n        displayName: 'y² = x³ + x + 1 (mod 5)'\n      };\n      \n      const point1: EllipticCurvePoint = { x: 0, y: 1, isIdentity: false };\n      const point2: EllipticCurvePoint = { x: 2, y: 1, isIdentity: false };\n      \n      const frames = EllipticCurveAnimator.generateAdditionAnimation(\n        point1, point2, curve, 1920, 1080\n      );\n      \n      expect(frames.length).toBeGreaterThan(0);\n      \n      // Check that line points (if any) respect canvas bounds\n      frames.forEach(frame => {\n        if (frame.linePoints) {\n          frame.linePoints.forEach(point => {\n            expect(point.x).toBeGreaterThanOrEqual(0);\n            expect(point.x).toBeLessThanOrEqual(1920);\n            expect(point.y).toBeGreaterThanOrEqual(0);\n            expect(point.y).toBeLessThanOrEqual(1080);\n          });\n        }\n      });\n    });\n  });\n});\n\ndescribe('Integration Tests', () => {\n  \n  test('validates complete elliptic curve group workflow', () => {\n    // Create curve\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 5,\n      name: 'integration_test',\n      displayName: 'y² = x³ + x + 1 (mod 5)'\n    };\n    \n    // Generate group\n    const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n    \n    // Convert to standard format\n    const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n    \n    // Test all points and operations\n    ecGroup.points.forEach(point => {\n      expect(point).toBeValidEllipticCurvePoint(curve);\n      expect(EllipticCurveArithmetic.isOnCurve(point, curve)).toBe(true);\n      \n      const order = EllipticCurveArithmetic.getPointOrder(point, curve);\n      if (order > 0 && order !== -1) {\n        expect(ecGroup.order % order).toBe(0); // Lagrange theorem\n      }\n    });\n    \n    // Test standard group properties\n    expect(standardGroup.elements.length).toBe(ecGroup.order);\n    expect(standardGroup.operations.size).toBe(ecGroup.order);\n    expect(standardGroup.isAbelian).toBe(true);\n  });\n\n  test('validates mathematical consistency across all predefined curves', () => {\n    const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n    \n    curves.forEach(curve => {\n      // Validate curve parameters\n      const curveValidation = EllipticCurveValidator.validateCurve(curve);\n      expect(curveValidation.isValid).toBe(true);\n      \n      // Generate group and validate\n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      \n      // Validate Hasse bound\n      const hasseValidation = EllipticCurveValidator.validateHasseBound(\n        ecGroup.order, curve.p\n      );\n      expect(hasseValidation.isValid).toBe(true);\n      \n      // Test group operations maintain closure\n      const testPoints = ecGroup.points.slice(0, Math.min(4, ecGroup.points.length));\n      testPoints.forEach(p1 => {\n        testPoints.forEach(p2 => {\n          const sum = EllipticCurveArithmetic.addPoints(p1, p2, curve);\n          const normalizedSum = normalizePoint(sum, curve.p);\n          expect(normalizedSum).toBeValidEllipticCurvePoint(curve);\n          expect(EllipticCurveArithmetic.isOnCurve(sum, curve)).toBe(true);\n          \n          // Result should be in the group (after normalization)\n          const isInGroup = ecGroup.points.some(p => {\n            const normalizedP = normalizePoint(p, curve.p);\n            return normalizedP.isIdentity === normalizedSum.isIdentity &&\n                   normalizedP.x === normalizedSum.x && \n                   normalizedP.y === normalizedSum.y;\n          });\n          expect(isInGroup).toBe(true);\n        });\n      });\n    });\n  });\n\n  test('validates performance across different curve sizes', () => {\n    const curves = EllipticCurveGroupGenerator.getPredefinedCurves();\n    \n    curves.forEach(curve => {\n      const startTime = performance.now();\n      \n      // Generate group\n      const ecGroup = EllipticCurveGroupGenerator.createEllipticCurveGroup(curve);\n      \n      // Convert to standard format\n      const standardGroup = EllipticCurveGroupGenerator.toStandardGroup(ecGroup);\n      \n      // Test some operations\n      if (ecGroup.points.length > 1) {\n        EllipticCurveArithmetic.addPoints(\n          ecGroup.points[1], \n          ecGroup.points[1], \n          curve\n        );\n      }\n      \n      const endTime = performance.now();\n      \n      // Should complete reasonably quickly even for larger curves\n      expect(endTime - startTime).toBeLessThan(1000); // 1 second limit\n    });\n  });\n\n  test('validates deterministic behavior', () => {\n    const curve: EllipticCurve = {\n      a: 1, b: 1, p: 7,\n      name: 'deterministic_test',\n      displayName: 'y² = x³ + x + 1 (mod 7)'\n    };\n    \n    // Generate multiple times and ensure identical results\n    const results = Array.from({ length: 3 }, () => \n      EllipticCurveGroupGenerator.createEllipticCurveGroup(curve)\n    );\n    \n    const firstResult = results[0];\n    results.slice(1).forEach(result => {\n      expect(result.order).toBe(firstResult.order);\n      expect(result.points.length).toBe(firstResult.points.length);\n      \n      // Points should be identical (though order might differ)\n      expect(result.points).toEqual(expect.arrayContaining(firstResult.points));\n    });\n  });\n});"],"names":["expect","extend","mathematicalMatchers","describe","test","EllipticCurveArithmetic","modInverse","toBe","toThrow","modPow","testCurve","a","b","p","name","displayName","validPoint","x","y","isIdentity","invalidPoint","identityPoint","isOnCurve","malformedIdentity1","malformedIdentity2","toBeValidEllipticCurvePoint","normalizePoint","point","curve","point1","point2","result1","addPoints","result2","toEqual","result","normalized","inversePoint","toBeNull","points","EllipticCurveGroupGenerator","generateCurvePoints","orderTwoPoint","find","getPointOrder","filter","i","length","j","k","q","r","left","right","leftNorm","rightNorm","basePoint","result0","scalarMultiply","result3","doubling","result2Norm","doublingNorm","sum","kP","kQ","identity","forEach","order","toBeGreaterThan","groupOrder","pointOrder","badCurve","toBeGreaterThanOrEqual","Array","isArray","curves","bound","Math","sqrt","difference","abs","toBeLessThanOrEqual","console","log","getPredefinedCurves","pointStrings","map","uniquePoints","Set","size","group","createEllipticCurveGroup","slice","toContain","toHaveProperty","Number","isInteger","validation","EllipticCurveValidator","validateCurve","isValid","discriminant","pow","not","ecGroup","standardGroup","toStandardGroup","isAbelian","elements","operations","Map","generators","element","id","label","latex","inverse","conjugacyClass","operationMap","element1","element2","isValidElement","some","e","join","toBeDefined","product","get","frames","EllipticCurveAnimator","generateAdditionAnimation","frame","step","progress","frames1","frames2","steps","f","doublingFrames","identityFrames","lastFrame","arithmeticResult","startTime","performance","now","min","endTime","toBeLessThan","linePoints","curveValidation","hasseValidation","validateHasseBound","testPoints","p1","p2","normalizedSum","isInGroup","normalizedP","results","from","firstResult","arrayContaining"],"mappings":"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"}