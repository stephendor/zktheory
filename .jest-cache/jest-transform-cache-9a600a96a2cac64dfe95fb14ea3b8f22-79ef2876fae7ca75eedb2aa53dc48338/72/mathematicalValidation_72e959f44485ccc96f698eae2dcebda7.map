{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/__tests__/utils/mathematicalValidation.ts"],"sourcesContent":["/**\n * Enhanced Mathematical Validation Framework\n * Provides comprehensive validation utilities for mathematical computations\n * Used across all mathematical algorithm tests for consistency and accuracy\n */\n\nimport type { Group, GroupElement } from '@/lib/GroupTheory';\nimport type { EllipticCurve, EllipticCurvePoint } from '@/lib/EllipticCurveGroups';\n\n// Interfaces for mathematical objects validation\nexport interface PersistenceInterval {\n  birth: number;\n  death: number;\n  dimension: number;\n}\n\nexport interface MathematicalPrecision {\n  DEFAULT_TOLERANCE: number;\n  FLOAT_TOLERANCE: number;\n  STATISTICAL_TOLERANCE: number;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * Mathematical Constants and Precision Settings\n */\nexport const MATHEMATICAL_PRECISION: MathematicalPrecision = {\n  DEFAULT_TOLERANCE: 1e-10,\n  FLOAT_TOLERANCE: 1e-6,\n  STATISTICAL_TOLERANCE: 1e-3,\n};\n\n/**\n * Group Theory Validation Utilities\n */\nexport class GroupTheoryValidator {\n  /**\n   * Validates that an object is a valid group element\n   */\n  static validateGroupElement(element: any): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!element) {\n      errors.push('Element is null or undefined');\n    } else {\n      if (typeof element.id !== 'string') {\n        errors.push('Element must have a string id');\n      }\n      if (typeof element.label !== 'string') {\n        warnings.push('Element should have a string label');\n      }\n      if (typeof element.order !== 'number' || element.order <= 0) {\n        errors.push('Element must have a positive numeric order');\n      }\n      if (typeof element.inverse !== 'string') {\n        errors.push('Element must have a string inverse reference');\n      }\n      if (typeof element.conjugacyClass !== 'number' || element.conjugacyClass < 0) {\n        errors.push('Element must have a non-negative conjugacy class index');\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates group axioms for a given group\n   */\n  static validateGroupAxioms(group: Group): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!group) {\n      errors.push('Group is null or undefined');\n      return { isValid: false, errors, warnings };\n    }\n\n    // 1. Closure: For all a,b in G, a*b is in G\n    group.elements.forEach(a => {\n      group.elements.forEach(b => {\n        const product = group.operations.get(a.id)?.get(b.id);\n        if (!product) {\n          errors.push(`Missing operation result for ${a.id} * ${b.id}`);\n        } else if (!group.elements.find(e => e.id === product)) {\n          errors.push(`Operation ${a.id} * ${b.id} = ${product} not in group`);\n        }\n      });\n    });\n\n    // 2. Identity: Exists e such that e*a = a*e = a for all a\n    const identity = group.elements.find(e => e.id === 'e');\n    if (!identity) {\n      errors.push('No identity element found (id should be \"e\")');\n    } else {\n      group.elements.forEach(element => {\n        const leftProduct = group.operations.get(identity.id)?.get(element.id);\n        const rightProduct = group.operations.get(element.id)?.get(identity.id);\n        \n        if (leftProduct !== element.id) {\n          errors.push(`Identity law violation: e * ${element.id} ≠ ${element.id}`);\n        }\n        if (rightProduct !== element.id) {\n          errors.push(`Identity law violation: ${element.id} * e ≠ ${element.id}`);\n        }\n      });\n    }\n\n    // 3. Inverse: For all a, exists a^(-1) such that a*a^(-1) = e\n    group.elements.forEach(element => {\n      const inverseId = element.inverse;\n      const inverse = group.elements.find(e => e.id === inverseId);\n      \n      if (!inverse) {\n        errors.push(`Inverse element ${inverseId} for ${element.id} not found in group`);\n      } else {\n        const product = group.operations.get(element.id)?.get(inverseId);\n        if (product !== 'e') {\n          errors.push(`Inverse law violation: ${element.id} * ${inverseId} ≠ e`);\n        }\n      }\n    });\n\n    // 4. Associativity: (a*b)*c = a*(b*c) for all a,b,c (test subset for performance)\n    const testElements = group.elements.slice(0, Math.min(4, group.elements.length));\n    testElements.forEach(a => {\n      testElements.forEach(b => {\n        testElements.forEach(c => {\n          const ab = group.operations.get(a.id)?.get(b.id);\n          const bc = group.operations.get(b.id)?.get(c.id);\n          \n          if (ab && bc) {\n            const ab_c = group.operations.get(ab)?.get(c.id);\n            const a_bc = group.operations.get(a.id)?.get(bc);\n            \n            if (ab_c !== a_bc) {\n              errors.push(`Associativity violation: (${a.id}*${b.id})*${c.id} ≠ ${a.id}*(${b.id}*${c.id})`);\n            }\n          }\n        });\n      });\n    });\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates Lagrange's theorem: element order divides group order\n   */\n  static validateLagrangeTheorem(group: Group): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    group.elements.forEach(element => {\n      if (group.order % element.order !== 0) {\n        errors.push(`Lagrange theorem violation: element ${element.id} has order ${element.order} which does not divide group order ${group.order}`);\n      }\n    });\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates that generators actually generate the group\n   */\n  static validateGenerators(group: Group): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (group.generators.length === 0) {\n      warnings.push('Group has no generators specified');\n      return { isValid: true, errors, warnings };\n    }\n\n    const generated = new Set(['e']); // Start with identity\n    const queue = [...group.generators];\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      if (!generated.has(current)) {\n        generated.add(current);\n        \n        // Add all products with existing elements\n        Array.from(generated).forEach(existing => {\n          const product1 = group.operations.get(current)?.get(existing);\n          const product2 = group.operations.get(existing)?.get(current);\n          \n          if (product1 && !generated.has(product1)) queue.push(product1);\n          if (product2 && !generated.has(product2)) queue.push(product2);\n        });\n      }\n    }\n\n    if (generated.size !== group.order) {\n      errors.push(`Generators do not generate full group: generated ${generated.size} elements, expected ${group.order}`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n}\n\n/**\n * Elliptic Curve Validation Utilities\n */\nexport class EllipticCurveValidator {\n  /**\n   * Validates elliptic curve parameters\n   */\n  static validateCurve(curve: EllipticCurve): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!curve) {\n      errors.push('Curve is null or undefined');\n      return { isValid: false, errors, warnings };\n    }\n\n    // Check discriminant: Δ = -16(4a³ + 27b²) ≠ 0 (mod p)\n    const discriminant = -16 * (4 * Math.pow(curve.a, 3) + 27 * Math.pow(curve.b, 2));\n    if (discriminant % curve.p === 0) {\n      errors.push(`Curve is singular: discriminant ≡ 0 (mod ${curve.p})`);\n    }\n\n    // Check that p is a positive integer\n    if (typeof curve.p !== 'number' || curve.p <= 0 || !Number.isInteger(curve.p)) {\n      errors.push('Curve field characteristic p must be a positive integer');\n    }\n\n    // Check parameters are finite\n    if (!Number.isFinite(curve.a) || !Number.isFinite(curve.b)) {\n      errors.push('Curve parameters a and b must be finite numbers');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates that a point is on the curve\n   */\n  static validatePointOnCurve(point: EllipticCurvePoint, curve: EllipticCurve): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (point.isIdentity) {\n      // Identity point is always valid\n      if (point.x !== null || point.y !== null) {\n        warnings.push('Identity point should have null coordinates');\n      }\n      return { isValid: true, errors, warnings };\n    }\n\n    if (point.x === null || point.y === null) {\n      errors.push('Non-identity point cannot have null coordinates');\n      return { isValid: false, errors, warnings };\n    }\n\n    // Check curve equation: y² ≡ x³ + ax + b (mod p)\n    const leftSide = (point.y * point.y) % curve.p;\n    const rightSide = (point.x * point.x * point.x + curve.a * point.x + curve.b) % curve.p;\n\n    if (leftSide !== rightSide) {\n      errors.push(`Point (${point.x}, ${point.y}) is not on curve y² ≡ x³ + ${curve.a}x + ${curve.b} (mod ${curve.p})`);\n    }\n\n    // Check coordinates are in field\n    if (point.x < 0 || point.x >= curve.p || point.y < 0 || point.y >= curve.p) {\n      errors.push(`Point coordinates must be in range [0, ${curve.p - 1}]`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates Hasse's bound for elliptic curves over finite fields\n   */\n  static validateHasseBound(groupOrder: number, fieldSize: number): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Hasse's bound: |#E(Fp) - (p + 1)| ≤ 2√p\n    const bound = 2 * Math.sqrt(fieldSize);\n    const difference = Math.abs(groupOrder - (fieldSize + 1));\n\n    if (difference > bound) {\n      errors.push(`Hasse bound violation: |${groupOrder} - ${fieldSize + 1}| = ${difference} > ${bound}`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n}\n\n/**\n * Topological Data Analysis Validation Utilities\n */\nexport class TDAValidator {\n  /**\n   * Validates persistence interval\n   */\n  static validatePersistenceInterval(interval: PersistenceInterval): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!interval) {\n      errors.push('Interval is null or undefined');\n      return { isValid: false, errors, warnings };\n    }\n\n    if (typeof interval.birth !== 'number') {\n      errors.push('Birth time must be a number');\n    }\n    if (typeof interval.death !== 'number') {\n      errors.push('Death time must be a number');\n    }\n    if (typeof interval.dimension !== 'number') {\n      errors.push('Dimension must be a number');\n    }\n\n    if (!Number.isInteger(interval.dimension)) {\n      errors.push('Dimension must be an integer');\n    }\n    if (interval.dimension < 0) {\n      errors.push('Dimension must be non-negative');\n    }\n\n    if (interval.death < interval.birth) {\n      errors.push(`Death time ${interval.death} must be ≥ birth time ${interval.birth}`);\n    }\n\n    if (!Number.isFinite(interval.birth) || !Number.isFinite(interval.death)) {\n      errors.push('Birth and death times must be finite');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates that a set of intervals forms a valid persistence diagram\n   */\n  static validatePersistenceDiagram(intervals: PersistenceInterval[]): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!Array.isArray(intervals)) {\n      errors.push('Intervals must be an array');\n      return { isValid: false, errors, warnings };\n    }\n\n    // Validate each interval\n    intervals.forEach((interval, index) => {\n      const result = this.validatePersistenceInterval(interval);\n      if (!result.isValid) {\n        errors.push(`Interval ${index}: ${result.errors.join(', ')}`);\n      }\n    });\n\n    // Check for H0 intervals (dimension 0)\n    const h0Intervals = intervals.filter(i => i.dimension === 0);\n    if (h0Intervals.length === 0 && intervals.length > 0) {\n      warnings.push('No H0 (connected component) intervals found - this may indicate issues with the computation');\n    }\n\n    // Check dimension constraints for Euclidean data\n    const maxDimension = Math.max(...intervals.map(i => i.dimension));\n    if (maxDimension > 2) {\n      warnings.push(`High dimensional features (dim > 2) found - verify this is expected for your data`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates topological properties based on point cloud geometry\n   */\n  static validateTopologicalConsistency(\n    intervals: PersistenceInterval[], \n    pointCloud: number[][], \n    filtrationRadius: number\n  ): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Basic consistency checks\n    if (pointCloud.length === 0 && intervals.length > 0) {\n      errors.push('Empty point cloud should not generate persistence intervals');\n    }\n\n    if (pointCloud.length === 1) {\n      const h0Intervals = intervals.filter(i => i.dimension === 0);\n      if (h0Intervals.length !== 1) {\n        warnings.push('Single point should generate exactly one H0 interval');\n      }\n    }\n\n    // Check that death times respect filtration radius\n    intervals.forEach((interval, index) => {\n      if (interval.death > filtrationRadius * 1.1) { // Small tolerance\n        warnings.push(`Interval ${index} has death time ${interval.death} > filtration radius ${filtrationRadius}`);\n      }\n    });\n\n    // Dimension constraints based on point cloud dimension\n    if (pointCloud.length > 0) {\n      const pointDimension = pointCloud[0].length;\n      const maxHomologyDim = Math.max(...intervals.map(i => i.dimension));\n      \n      if (maxHomologyDim >= pointDimension) {\n        warnings.push(`Homology dimension ${maxHomologyDim} ≥ point cloud dimension ${pointDimension} - may indicate computational issues`);\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n}\n\n/**\n * Numerical Precision Validation Utilities\n */\nexport class PrecisionValidator {\n  /**\n   * Validates that a value is within expected numerical precision\n   */\n  static validateNumericalPrecision(\n    actual: number, \n    expected: number, \n    tolerance: number = MATHEMATICAL_PRECISION.DEFAULT_TOLERANCE\n  ): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    const difference = Math.abs(actual - expected);\n    \n    if (difference > tolerance) {\n      errors.push(`Precision error: |${actual} - ${expected}| = ${difference} > tolerance ${tolerance}`);\n    } else if (difference > tolerance * 0.1) {\n      warnings.push(`Near precision limit: difference ${difference} approaching tolerance ${tolerance}`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates floating point operations for stability\n   */\n  static validateFloatingPointStability(values: number[]): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    values.forEach((value, index) => {\n      if (!Number.isFinite(value)) {\n        errors.push(`Value at index ${index} is not finite: ${value}`);\n      }\n      if (Number.isNaN(value)) {\n        errors.push(`Value at index ${index} is NaN`);\n      }\n      if (Math.abs(value) > 1e15) {\n        warnings.push(`Very large value at index ${index}: ${value} may indicate numerical instability`);\n      }\n      if (Math.abs(value) < 1e-15 && value !== 0) {\n        warnings.push(`Very small value at index ${index}: ${value} may indicate underflow`);\n      }\n    });\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n}\n\n/**\n * Performance Validation Utilities\n */\nexport class PerformanceValidator {\n  /**\n   * Validates computational performance against expected bounds\n   */\n  static validatePerformanceBounds(\n    actualTime: number,\n    expectedBound: number,\n    operation: string\n  ): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (actualTime > expectedBound) {\n      errors.push(`Performance bound exceeded for ${operation}: ${actualTime}ms > ${expectedBound}ms`);\n    } else if (actualTime > expectedBound * 0.8) {\n      warnings.push(`Performance approaching bound for ${operation}: ${actualTime}ms near limit ${expectedBound}ms`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates memory usage patterns\n   */\n  static validateMemoryUsage(\n    initialMemory: number,\n    finalMemory: number,\n    maxAllowedIncrease: number,\n    operation: string\n  ): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    const memoryIncrease = finalMemory - initialMemory;\n\n    if (memoryIncrease > maxAllowedIncrease) {\n      errors.push(`Memory usage exceeded for ${operation}: ${memoryIncrease} bytes > ${maxAllowedIncrease} bytes`);\n    } else if (memoryIncrease > maxAllowedIncrease * 0.8) {\n      warnings.push(`Memory usage approaching limit for ${operation}: ${memoryIncrease} bytes near ${maxAllowedIncrease} bytes`);\n    }\n\n    if (memoryIncrease < 0) {\n      warnings.push(`Negative memory change detected for ${operation}: ${memoryIncrease} bytes - this may indicate measurement issues`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n}\n\n/**\n * Utility function to aggregate multiple validation results\n */\nexport function aggregateValidationResults(results: ValidationResult[]): ValidationResult {\n  const allErrors = results.flatMap(r => r.errors);\n  const allWarnings = results.flatMap(r => r.warnings);\n  \n  return {\n    isValid: allErrors.length === 0,\n    errors: allErrors,\n    warnings: allWarnings\n  };\n}\n\n/**\n * Utility function to log validation results with proper formatting\n */\nexport function logValidationResult(result: ValidationResult, context: string): void {\n  if (!result.isValid) {\n    console.error(`❌ Validation failed for ${context}:`);\n    result.errors.forEach(error => console.error(`   Error: ${error}`));\n  } else {\n    console.log(`✅ Validation passed for ${context}`);\n  }\n  \n  if (result.warnings.length > 0) {\n    console.warn(`⚠️  Warnings for ${context}:`);\n    result.warnings.forEach(warning => console.warn(`   Warning: ${warning}`));\n  }\n}\n\n/**\n * Jest matcher extensions for mathematical validation\n */\nexport const mathematicalMatchers = {\n  toBeValidGroup(received: Group) {\n    const result = GroupTheoryValidator.validateGroupAxioms(received);\n    \n    return {\n      message: () => result.isValid \n        ? `Expected group to be invalid, but it passed validation`\n        : `Expected group to be valid: ${result.errors.join(', ')}`,\n      pass: result.isValid\n    };\n  },\n\n  toBeValidEllipticCurvePoint(received: EllipticCurvePoint, curve: EllipticCurve) {\n    const result = EllipticCurveValidator.validatePointOnCurve(received, curve);\n    \n    return {\n      message: () => result.isValid\n        ? `Expected point to be invalid, but it passed validation`\n        : `Expected point to be valid: ${result.errors.join(', ')}`,\n      pass: result.isValid\n    };\n  },\n\n  toBeValidPersistenceInterval(received: PersistenceInterval) {\n    const result = TDAValidator.validatePersistenceInterval(received);\n    \n    return {\n      message: () => result.isValid\n        ? `Expected interval to be invalid, but it passed validation`\n        : `Expected interval to be valid: ${result.errors.join(', ')}`,\n      pass: result.isValid\n    };\n  },\n\n  toBeWithinTolerance(received: number, expected: number, tolerance?: number) {\n    const result = PrecisionValidator.validateNumericalPrecision(\n      received, \n      expected, \n      tolerance || MATHEMATICAL_PRECISION.DEFAULT_TOLERANCE\n    );\n    \n    return {\n      message: () => result.isValid\n        ? `Expected ${received} not to be within tolerance of ${expected}`\n        : `Expected ${received} to be within tolerance of ${expected}: ${result.errors.join(', ')}`,\n      pass: result.isValid\n    };\n  }\n};\n\n// Type augmentation for Jest matchers\ndeclare global {\n  namespace jest {\n    interface Matchers<R> {\n      toBeValidGroup(): R;\n      toBeValidEllipticCurvePoint(curve: EllipticCurve): R;\n      toBeValidPersistenceInterval(): R;\n      toBeWithinTolerance(expected: number, tolerance?: number): R;\n    }\n  }\n}"],"names":["EllipticCurveValidator","GroupTheoryValidator","MATHEMATICAL_PRECISION","PerformanceValidator","PrecisionValidator","TDAValidator","aggregateValidationResults","logValidationResult","mathematicalMatchers","DEFAULT_TOLERANCE","FLOAT_TOLERANCE","STATISTICAL_TOLERANCE","validateGroupElement","element","errors","warnings","push","id","label","order","inverse","conjugacyClass","isValid","length","validateGroupAxioms","group","elements","forEach","a","b","product","operations","get","find","e","identity","leftProduct","rightProduct","inverseId","testElements","slice","Math","min","c","ab","bc","ab_c","a_bc","validateLagrangeTheorem","validateGenerators","generators","generated","Set","queue","current","shift","has","add","Array","from","existing","product1","product2","size","validateCurve","curve","discriminant","pow","p","Number","isInteger","isFinite","validatePointOnCurve","point","isIdentity","x","y","leftSide","rightSide","validateHasseBound","groupOrder","fieldSize","bound","sqrt","difference","abs","validatePersistenceInterval","interval","birth","death","dimension","validatePersistenceDiagram","intervals","isArray","index","result","join","h0Intervals","filter","i","maxDimension","max","map","validateTopologicalConsistency","pointCloud","filtrationRadius","pointDimension","maxHomologyDim","validateNumericalPrecision","actual","expected","tolerance","validateFloatingPointStability","values","value","isNaN","validatePerformanceBounds","actualTime","expectedBound","operation","validateMemoryUsage","initialMemory","finalMemory","maxAllowedIncrease","memoryIncrease","results","allErrors","flatMap","r","allWarnings","context","console","error","log","warn","warning","toBeValidGroup","received","message","pass","toBeValidEllipticCurvePoint","toBeValidPersistenceInterval","toBeWithinTolerance"],"mappings":"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"}