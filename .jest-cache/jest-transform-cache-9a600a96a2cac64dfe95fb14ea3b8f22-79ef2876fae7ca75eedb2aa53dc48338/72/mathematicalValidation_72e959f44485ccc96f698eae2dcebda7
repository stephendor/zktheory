9d8e43e88a8b15093bd532e429d42a50
/**
 * Enhanced Mathematical Validation Framework
 * Provides comprehensive validation utilities for mathematical computations
 * Used across all mathematical algorithm tests for consistency and accuracy
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    EllipticCurveValidator: function() {
        return EllipticCurveValidator;
    },
    GroupTheoryValidator: function() {
        return GroupTheoryValidator;
    },
    MATHEMATICAL_PRECISION: function() {
        return MATHEMATICAL_PRECISION;
    },
    PerformanceValidator: function() {
        return PerformanceValidator;
    },
    PrecisionValidator: function() {
        return PrecisionValidator;
    },
    TDAValidator: function() {
        return TDAValidator;
    },
    aggregateValidationResults: function() {
        return aggregateValidationResults;
    },
    logValidationResult: function() {
        return logValidationResult;
    },
    mathematicalMatchers: function() {
        return mathematicalMatchers;
    }
});
const MATHEMATICAL_PRECISION = {
    DEFAULT_TOLERANCE: 1e-10,
    FLOAT_TOLERANCE: 1e-6,
    STATISTICAL_TOLERANCE: 1e-3
};
class GroupTheoryValidator {
    /**
   * Validates that an object is a valid group element
   */ static validateGroupElement(element) {
        const errors = [];
        const warnings = [];
        if (!element) {
            errors.push('Element is null or undefined');
        } else {
            if (typeof element.id !== 'string') {
                errors.push('Element must have a string id');
            }
            if (typeof element.label !== 'string') {
                warnings.push('Element should have a string label');
            }
            if (typeof element.order !== 'number' || element.order <= 0) {
                errors.push('Element must have a positive numeric order');
            }
            if (typeof element.inverse !== 'string') {
                errors.push('Element must have a string inverse reference');
            }
            if (typeof element.conjugacyClass !== 'number' || element.conjugacyClass < 0) {
                errors.push('Element must have a non-negative conjugacy class index');
            }
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates group axioms for a given group
   */ static validateGroupAxioms(group) {
        const errors = [];
        const warnings = [];
        if (!group) {
            errors.push('Group is null or undefined');
            return {
                isValid: false,
                errors,
                warnings
            };
        }
        // 1. Closure: For all a,b in G, a*b is in G
        group.elements.forEach((a)=>{
            group.elements.forEach((b)=>{
                const product = group.operations.get(a.id)?.get(b.id);
                if (!product) {
                    errors.push(`Missing operation result for ${a.id} * ${b.id}`);
                } else if (!group.elements.find((e)=>e.id === product)) {
                    errors.push(`Operation ${a.id} * ${b.id} = ${product} not in group`);
                }
            });
        });
        // 2. Identity: Exists e such that e*a = a*e = a for all a
        const identity = group.elements.find((e)=>e.id === 'e');
        if (!identity) {
            errors.push('No identity element found (id should be "e")');
        } else {
            group.elements.forEach((element)=>{
                const leftProduct = group.operations.get(identity.id)?.get(element.id);
                const rightProduct = group.operations.get(element.id)?.get(identity.id);
                if (leftProduct !== element.id) {
                    errors.push(`Identity law violation: e * ${element.id} ≠ ${element.id}`);
                }
                if (rightProduct !== element.id) {
                    errors.push(`Identity law violation: ${element.id} * e ≠ ${element.id}`);
                }
            });
        }
        // 3. Inverse: For all a, exists a^(-1) such that a*a^(-1) = e
        group.elements.forEach((element)=>{
            const inverseId = element.inverse;
            const inverse = group.elements.find((e)=>e.id === inverseId);
            if (!inverse) {
                errors.push(`Inverse element ${inverseId} for ${element.id} not found in group`);
            } else {
                const product = group.operations.get(element.id)?.get(inverseId);
                if (product !== 'e') {
                    errors.push(`Inverse law violation: ${element.id} * ${inverseId} ≠ e`);
                }
            }
        });
        // 4. Associativity: (a*b)*c = a*(b*c) for all a,b,c (test subset for performance)
        const testElements = group.elements.slice(0, Math.min(4, group.elements.length));
        testElements.forEach((a)=>{
            testElements.forEach((b)=>{
                testElements.forEach((c)=>{
                    const ab = group.operations.get(a.id)?.get(b.id);
                    const bc = group.operations.get(b.id)?.get(c.id);
                    if (ab && bc) {
                        const ab_c = group.operations.get(ab)?.get(c.id);
                        const a_bc = group.operations.get(a.id)?.get(bc);
                        if (ab_c !== a_bc) {
                            errors.push(`Associativity violation: (${a.id}*${b.id})*${c.id} ≠ ${a.id}*(${b.id}*${c.id})`);
                        }
                    }
                });
            });
        });
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates Lagrange's theorem: element order divides group order
   */ static validateLagrangeTheorem(group) {
        const errors = [];
        const warnings = [];
        group.elements.forEach((element)=>{
            if (group.order % element.order !== 0) {
                errors.push(`Lagrange theorem violation: element ${element.id} has order ${element.order} which does not divide group order ${group.order}`);
            }
        });
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates that generators actually generate the group
   */ static validateGenerators(group) {
        const errors = [];
        const warnings = [];
        if (group.generators.length === 0) {
            warnings.push('Group has no generators specified');
            return {
                isValid: true,
                errors,
                warnings
            };
        }
        const generated = new Set([
            'e'
        ]); // Start with identity
        const queue = [
            ...group.generators
        ];
        while(queue.length > 0){
            const current = queue.shift();
            if (!generated.has(current)) {
                generated.add(current);
                // Add all products with existing elements
                Array.from(generated).forEach((existing)=>{
                    const product1 = group.operations.get(current)?.get(existing);
                    const product2 = group.operations.get(existing)?.get(current);
                    if (product1 && !generated.has(product1)) queue.push(product1);
                    if (product2 && !generated.has(product2)) queue.push(product2);
                });
            }
        }
        if (generated.size !== group.order) {
            errors.push(`Generators do not generate full group: generated ${generated.size} elements, expected ${group.order}`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
}
class EllipticCurveValidator {
    /**
   * Validates elliptic curve parameters
   */ static validateCurve(curve) {
        const errors = [];
        const warnings = [];
        if (!curve) {
            errors.push('Curve is null or undefined');
            return {
                isValid: false,
                errors,
                warnings
            };
        }
        // Check discriminant: Δ = -16(4a³ + 27b²) ≠ 0 (mod p)
        const discriminant = -16 * (4 * Math.pow(curve.a, 3) + 27 * Math.pow(curve.b, 2));
        if (discriminant % curve.p === 0) {
            errors.push(`Curve is singular: discriminant ≡ 0 (mod ${curve.p})`);
        }
        // Check that p is a positive integer
        if (typeof curve.p !== 'number' || curve.p <= 0 || !Number.isInteger(curve.p)) {
            errors.push('Curve field characteristic p must be a positive integer');
        }
        // Check parameters are finite
        if (!Number.isFinite(curve.a) || !Number.isFinite(curve.b)) {
            errors.push('Curve parameters a and b must be finite numbers');
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates that a point is on the curve
   */ static validatePointOnCurve(point, curve) {
        const errors = [];
        const warnings = [];
        if (point.isIdentity) {
            // Identity point is always valid
            if (point.x !== null || point.y !== null) {
                warnings.push('Identity point should have null coordinates');
            }
            return {
                isValid: true,
                errors,
                warnings
            };
        }
        if (point.x === null || point.y === null) {
            errors.push('Non-identity point cannot have null coordinates');
            return {
                isValid: false,
                errors,
                warnings
            };
        }
        // Check curve equation: y² ≡ x³ + ax + b (mod p)
        const leftSide = point.y * point.y % curve.p;
        const rightSide = (point.x * point.x * point.x + curve.a * point.x + curve.b) % curve.p;
        if (leftSide !== rightSide) {
            errors.push(`Point (${point.x}, ${point.y}) is not on curve y² ≡ x³ + ${curve.a}x + ${curve.b} (mod ${curve.p})`);
        }
        // Check coordinates are in field
        if (point.x < 0 || point.x >= curve.p || point.y < 0 || point.y >= curve.p) {
            errors.push(`Point coordinates must be in range [0, ${curve.p - 1}]`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates Hasse's bound for elliptic curves over finite fields
   */ static validateHasseBound(groupOrder, fieldSize) {
        const errors = [];
        const warnings = [];
        // Hasse's bound: |#E(Fp) - (p + 1)| ≤ 2√p
        const bound = 2 * Math.sqrt(fieldSize);
        const difference = Math.abs(groupOrder - (fieldSize + 1));
        if (difference > bound) {
            errors.push(`Hasse bound violation: |${groupOrder} - ${fieldSize + 1}| = ${difference} > ${bound}`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
}
class TDAValidator {
    /**
   * Validates persistence interval
   */ static validatePersistenceInterval(interval) {
        const errors = [];
        const warnings = [];
        if (!interval) {
            errors.push('Interval is null or undefined');
            return {
                isValid: false,
                errors,
                warnings
            };
        }
        if (typeof interval.birth !== 'number') {
            errors.push('Birth time must be a number');
        }
        if (typeof interval.death !== 'number') {
            errors.push('Death time must be a number');
        }
        if (typeof interval.dimension !== 'number') {
            errors.push('Dimension must be a number');
        }
        if (!Number.isInteger(interval.dimension)) {
            errors.push('Dimension must be an integer');
        }
        if (interval.dimension < 0) {
            errors.push('Dimension must be non-negative');
        }
        if (interval.death < interval.birth) {
            errors.push(`Death time ${interval.death} must be ≥ birth time ${interval.birth}`);
        }
        if (!Number.isFinite(interval.birth) || !Number.isFinite(interval.death)) {
            errors.push('Birth and death times must be finite');
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates that a set of intervals forms a valid persistence diagram
   */ static validatePersistenceDiagram(intervals) {
        const errors = [];
        const warnings = [];
        if (!Array.isArray(intervals)) {
            errors.push('Intervals must be an array');
            return {
                isValid: false,
                errors,
                warnings
            };
        }
        // Validate each interval
        intervals.forEach((interval, index)=>{
            const result = this.validatePersistenceInterval(interval);
            if (!result.isValid) {
                errors.push(`Interval ${index}: ${result.errors.join(', ')}`);
            }
        });
        // Check for H0 intervals (dimension 0)
        const h0Intervals = intervals.filter((i)=>i.dimension === 0);
        if (h0Intervals.length === 0 && intervals.length > 0) {
            warnings.push('No H0 (connected component) intervals found - this may indicate issues with the computation');
        }
        // Check dimension constraints for Euclidean data
        const maxDimension = Math.max(...intervals.map((i)=>i.dimension));
        if (maxDimension > 2) {
            warnings.push(`High dimensional features (dim > 2) found - verify this is expected for your data`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates topological properties based on point cloud geometry
   */ static validateTopologicalConsistency(intervals, pointCloud, filtrationRadius) {
        const errors = [];
        const warnings = [];
        // Basic consistency checks
        if (pointCloud.length === 0 && intervals.length > 0) {
            errors.push('Empty point cloud should not generate persistence intervals');
        }
        if (pointCloud.length === 1) {
            const h0Intervals = intervals.filter((i)=>i.dimension === 0);
            if (h0Intervals.length !== 1) {
                warnings.push('Single point should generate exactly one H0 interval');
            }
        }
        // Check that death times respect filtration radius
        intervals.forEach((interval, index)=>{
            if (interval.death > filtrationRadius * 1.1) {
                warnings.push(`Interval ${index} has death time ${interval.death} > filtration radius ${filtrationRadius}`);
            }
        });
        // Dimension constraints based on point cloud dimension
        if (pointCloud.length > 0) {
            const pointDimension = pointCloud[0].length;
            const maxHomologyDim = Math.max(...intervals.map((i)=>i.dimension));
            if (maxHomologyDim >= pointDimension) {
                warnings.push(`Homology dimension ${maxHomologyDim} ≥ point cloud dimension ${pointDimension} - may indicate computational issues`);
            }
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
}
class PrecisionValidator {
    /**
   * Validates that a value is within expected numerical precision
   */ static validateNumericalPrecision(actual, expected, tolerance = MATHEMATICAL_PRECISION.DEFAULT_TOLERANCE) {
        const errors = [];
        const warnings = [];
        const difference = Math.abs(actual - expected);
        if (difference > tolerance) {
            errors.push(`Precision error: |${actual} - ${expected}| = ${difference} > tolerance ${tolerance}`);
        } else if (difference > tolerance * 0.1) {
            warnings.push(`Near precision limit: difference ${difference} approaching tolerance ${tolerance}`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates floating point operations for stability
   */ static validateFloatingPointStability(values) {
        const errors = [];
        const warnings = [];
        values.forEach((value, index)=>{
            if (!Number.isFinite(value)) {
                errors.push(`Value at index ${index} is not finite: ${value}`);
            }
            if (Number.isNaN(value)) {
                errors.push(`Value at index ${index} is NaN`);
            }
            if (Math.abs(value) > 1e15) {
                warnings.push(`Very large value at index ${index}: ${value} may indicate numerical instability`);
            }
            if (Math.abs(value) < 1e-15 && value !== 0) {
                warnings.push(`Very small value at index ${index}: ${value} may indicate underflow`);
            }
        });
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
}
class PerformanceValidator {
    /**
   * Validates computational performance against expected bounds
   */ static validatePerformanceBounds(actualTime, expectedBound, operation) {
        const errors = [];
        const warnings = [];
        if (actualTime > expectedBound) {
            errors.push(`Performance bound exceeded for ${operation}: ${actualTime}ms > ${expectedBound}ms`);
        } else if (actualTime > expectedBound * 0.8) {
            warnings.push(`Performance approaching bound for ${operation}: ${actualTime}ms near limit ${expectedBound}ms`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
   * Validates memory usage patterns
   */ static validateMemoryUsage(initialMemory, finalMemory, maxAllowedIncrease, operation) {
        const errors = [];
        const warnings = [];
        const memoryIncrease = finalMemory - initialMemory;
        if (memoryIncrease > maxAllowedIncrease) {
            errors.push(`Memory usage exceeded for ${operation}: ${memoryIncrease} bytes > ${maxAllowedIncrease} bytes`);
        } else if (memoryIncrease > maxAllowedIncrease * 0.8) {
            warnings.push(`Memory usage approaching limit for ${operation}: ${memoryIncrease} bytes near ${maxAllowedIncrease} bytes`);
        }
        if (memoryIncrease < 0) {
            warnings.push(`Negative memory change detected for ${operation}: ${memoryIncrease} bytes - this may indicate measurement issues`);
        }
        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }
}
function aggregateValidationResults(results) {
    const allErrors = results.flatMap((r)=>r.errors);
    const allWarnings = results.flatMap((r)=>r.warnings);
    return {
        isValid: allErrors.length === 0,
        errors: allErrors,
        warnings: allWarnings
    };
}
function logValidationResult(result, context) {
    if (!result.isValid) {
        console.error(`❌ Validation failed for ${context}:`);
        result.errors.forEach((error)=>console.error(`   Error: ${error}`));
    } else {
        console.log(`✅ Validation passed for ${context}`);
    }
    if (result.warnings.length > 0) {
        console.warn(`⚠️  Warnings for ${context}:`);
        result.warnings.forEach((warning)=>console.warn(`   Warning: ${warning}`));
    }
}
const mathematicalMatchers = {
    toBeValidGroup (received) {
        const result = GroupTheoryValidator.validateGroupAxioms(received);
        return {
            message: ()=>result.isValid ? `Expected group to be invalid, but it passed validation` : `Expected group to be valid: ${result.errors.join(', ')}`,
            pass: result.isValid
        };
    },
    toBeValidEllipticCurvePoint (received, curve) {
        const result = EllipticCurveValidator.validatePointOnCurve(received, curve);
        return {
            message: ()=>result.isValid ? `Expected point to be invalid, but it passed validation` : `Expected point to be valid: ${result.errors.join(', ')}`,
            pass: result.isValid
        };
    },
    toBeValidPersistenceInterval (received) {
        const result = TDAValidator.validatePersistenceInterval(received);
        return {
            message: ()=>result.isValid ? `Expected interval to be invalid, but it passed validation` : `Expected interval to be valid: ${result.errors.join(', ')}`,
            pass: result.isValid
        };
    },
    toBeWithinTolerance (received, expected, tolerance) {
        const result = PrecisionValidator.validateNumericalPrecision(received, expected, tolerance || MATHEMATICAL_PRECISION.DEFAULT_TOLERANCE);
        return {
            message: ()=>result.isValid ? `Expected ${received} not to be within tolerance of ${expected}` : `Expected ${received} to be within tolerance of ${expected}: ${result.errors.join(', ')}`,
            pass: result.isValid
        };
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3N0ZXBoZW4tZG9ybWFuL2Rldi96a3RoZW9yeS9zcmMvX190ZXN0c19fL3V0aWxzL21hdGhlbWF0aWNhbFZhbGlkYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbmhhbmNlZCBNYXRoZW1hdGljYWwgVmFsaWRhdGlvbiBGcmFtZXdvcmtcbiAqIFByb3ZpZGVzIGNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbiB1dGlsaXRpZXMgZm9yIG1hdGhlbWF0aWNhbCBjb21wdXRhdGlvbnNcbiAqIFVzZWQgYWNyb3NzIGFsbCBtYXRoZW1hdGljYWwgYWxnb3JpdGhtIHRlc3RzIGZvciBjb25zaXN0ZW5jeSBhbmQgYWNjdXJhY3lcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IEdyb3VwLCBHcm91cEVsZW1lbnQgfSBmcm9tICdAL2xpYi9Hcm91cFRoZW9yeSc7XG5pbXBvcnQgdHlwZSB7IEVsbGlwdGljQ3VydmUsIEVsbGlwdGljQ3VydmVQb2ludCB9IGZyb20gJ0AvbGliL0VsbGlwdGljQ3VydmVHcm91cHMnO1xuXG4vLyBJbnRlcmZhY2VzIGZvciBtYXRoZW1hdGljYWwgb2JqZWN0cyB2YWxpZGF0aW9uXG5leHBvcnQgaW50ZXJmYWNlIFBlcnNpc3RlbmNlSW50ZXJ2YWwge1xuICBiaXJ0aDogbnVtYmVyO1xuICBkZWF0aDogbnVtYmVyO1xuICBkaW1lbnNpb246IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXRoZW1hdGljYWxQcmVjaXNpb24ge1xuICBERUZBVUxUX1RPTEVSQU5DRTogbnVtYmVyO1xuICBGTE9BVF9UT0xFUkFOQ0U6IG51bWJlcjtcbiAgU1RBVElTVElDQUxfVE9MRVJBTkNFOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJlc3VsdCB7XG4gIGlzVmFsaWQ6IGJvb2xlYW47XG4gIGVycm9yczogc3RyaW5nW107XG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBNYXRoZW1hdGljYWwgQ29uc3RhbnRzIGFuZCBQcmVjaXNpb24gU2V0dGluZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IE1BVEhFTUFUSUNBTF9QUkVDSVNJT046IE1hdGhlbWF0aWNhbFByZWNpc2lvbiA9IHtcbiAgREVGQVVMVF9UT0xFUkFOQ0U6IDFlLTEwLFxuICBGTE9BVF9UT0xFUkFOQ0U6IDFlLTYsXG4gIFNUQVRJU1RJQ0FMX1RPTEVSQU5DRTogMWUtMyxcbn07XG5cbi8qKlxuICogR3JvdXAgVGhlb3J5IFZhbGlkYXRpb24gVXRpbGl0aWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cFRoZW9yeVZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCBhbiBvYmplY3QgaXMgYSB2YWxpZCBncm91cCBlbGVtZW50XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVHcm91cEVsZW1lbnQoZWxlbWVudDogYW55KTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlcnJvcnMucHVzaCgnRWxlbWVudCBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKCdFbGVtZW50IG11c3QgaGF2ZSBhIHN0cmluZyBpZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKCdFbGVtZW50IHNob3VsZCBoYXZlIGEgc3RyaW5nIGxhYmVsJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub3JkZXIgIT09ICdudW1iZXInIHx8IGVsZW1lbnQub3JkZXIgPD0gMCkge1xuICAgICAgICBlcnJvcnMucHVzaCgnRWxlbWVudCBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBudW1lcmljIG9yZGVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuaW52ZXJzZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goJ0VsZW1lbnQgbXVzdCBoYXZlIGEgc3RyaW5nIGludmVyc2UgcmVmZXJlbmNlJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuY29uanVnYWN5Q2xhc3MgIT09ICdudW1iZXInIHx8IGVsZW1lbnQuY29uanVnYWN5Q2xhc3MgPCAwKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKCdFbGVtZW50IG11c3QgaGF2ZSBhIG5vbi1uZWdhdGl2ZSBjb25qdWdhY3kgY2xhc3MgaW5kZXgnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGVycm9ycyxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgZ3JvdXAgYXhpb21zIGZvciBhIGdpdmVuIGdyb3VwXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVHcm91cEF4aW9tcyhncm91cDogR3JvdXApOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICBlcnJvcnMucHVzaCgnR3JvdXAgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcnMsIHdhcm5pbmdzIH07XG4gICAgfVxuXG4gICAgLy8gMS4gQ2xvc3VyZTogRm9yIGFsbCBhLGIgaW4gRywgYSpiIGlzIGluIEdcbiAgICBncm91cC5lbGVtZW50cy5mb3JFYWNoKGEgPT4ge1xuICAgICAgZ3JvdXAuZWxlbWVudHMuZm9yRWFjaChiID0+IHtcbiAgICAgICAgY29uc3QgcHJvZHVjdCA9IGdyb3VwLm9wZXJhdGlvbnMuZ2V0KGEuaWQpPy5nZXQoYi5pZCk7XG4gICAgICAgIGlmICghcHJvZHVjdCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBNaXNzaW5nIG9wZXJhdGlvbiByZXN1bHQgZm9yICR7YS5pZH0gKiAke2IuaWR9YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyb3VwLmVsZW1lbnRzLmZpbmQoZSA9PiBlLmlkID09PSBwcm9kdWN0KSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBPcGVyYXRpb24gJHthLmlkfSAqICR7Yi5pZH0gPSAke3Byb2R1Y3R9IG5vdCBpbiBncm91cGApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIDIuIElkZW50aXR5OiBFeGlzdHMgZSBzdWNoIHRoYXQgZSphID0gYSplID0gYSBmb3IgYWxsIGFcbiAgICBjb25zdCBpZGVudGl0eSA9IGdyb3VwLmVsZW1lbnRzLmZpbmQoZSA9PiBlLmlkID09PSAnZScpO1xuICAgIGlmICghaWRlbnRpdHkpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdObyBpZGVudGl0eSBlbGVtZW50IGZvdW5kIChpZCBzaG91bGQgYmUgXCJlXCIpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IGxlZnRQcm9kdWN0ID0gZ3JvdXAub3BlcmF0aW9ucy5nZXQoaWRlbnRpdHkuaWQpPy5nZXQoZWxlbWVudC5pZCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0UHJvZHVjdCA9IGdyb3VwLm9wZXJhdGlvbnMuZ2V0KGVsZW1lbnQuaWQpPy5nZXQoaWRlbnRpdHkuaWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxlZnRQcm9kdWN0ICE9PSBlbGVtZW50LmlkKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYElkZW50aXR5IGxhdyB2aW9sYXRpb246IGUgKiAke2VsZW1lbnQuaWR9IOKJoCAke2VsZW1lbnQuaWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0UHJvZHVjdCAhPT0gZWxlbWVudC5pZCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBJZGVudGl0eSBsYXcgdmlvbGF0aW9uOiAke2VsZW1lbnQuaWR9ICogZSDiiaAgJHtlbGVtZW50LmlkfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAzLiBJbnZlcnNlOiBGb3IgYWxsIGEsIGV4aXN0cyBhXigtMSkgc3VjaCB0aGF0IGEqYV4oLTEpID0gZVxuICAgIGdyb3VwLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBpbnZlcnNlSWQgPSBlbGVtZW50LmludmVyc2U7XG4gICAgICBjb25zdCBpbnZlcnNlID0gZ3JvdXAuZWxlbWVudHMuZmluZChlID0+IGUuaWQgPT09IGludmVyc2VJZCk7XG4gICAgICBcbiAgICAgIGlmICghaW52ZXJzZSkge1xuICAgICAgICBlcnJvcnMucHVzaChgSW52ZXJzZSBlbGVtZW50ICR7aW52ZXJzZUlkfSBmb3IgJHtlbGVtZW50LmlkfSBub3QgZm91bmQgaW4gZ3JvdXBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSBncm91cC5vcGVyYXRpb25zLmdldChlbGVtZW50LmlkKT8uZ2V0KGludmVyc2VJZCk7XG4gICAgICAgIGlmIChwcm9kdWN0ICE9PSAnZScpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgSW52ZXJzZSBsYXcgdmlvbGF0aW9uOiAke2VsZW1lbnQuaWR9ICogJHtpbnZlcnNlSWR9IOKJoCBlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIDQuIEFzc29jaWF0aXZpdHk6IChhKmIpKmMgPSBhKihiKmMpIGZvciBhbGwgYSxiLGMgKHRlc3Qgc3Vic2V0IGZvciBwZXJmb3JtYW5jZSlcbiAgICBjb25zdCB0ZXN0RWxlbWVudHMgPSBncm91cC5lbGVtZW50cy5zbGljZSgwLCBNYXRoLm1pbig0LCBncm91cC5lbGVtZW50cy5sZW5ndGgpKTtcbiAgICB0ZXN0RWxlbWVudHMuZm9yRWFjaChhID0+IHtcbiAgICAgIHRlc3RFbGVtZW50cy5mb3JFYWNoKGIgPT4ge1xuICAgICAgICB0ZXN0RWxlbWVudHMuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICBjb25zdCBhYiA9IGdyb3VwLm9wZXJhdGlvbnMuZ2V0KGEuaWQpPy5nZXQoYi5pZCk7XG4gICAgICAgICAgY29uc3QgYmMgPSBncm91cC5vcGVyYXRpb25zLmdldChiLmlkKT8uZ2V0KGMuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChhYiAmJiBiYykge1xuICAgICAgICAgICAgY29uc3QgYWJfYyA9IGdyb3VwLm9wZXJhdGlvbnMuZ2V0KGFiKT8uZ2V0KGMuaWQpO1xuICAgICAgICAgICAgY29uc3QgYV9iYyA9IGdyb3VwLm9wZXJhdGlvbnMuZ2V0KGEuaWQpPy5nZXQoYmMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYWJfYyAhPT0gYV9iYykge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChgQXNzb2NpYXRpdml0eSB2aW9sYXRpb246ICgke2EuaWR9KiR7Yi5pZH0pKiR7Yy5pZH0g4omgICR7YS5pZH0qKCR7Yi5pZH0qJHtjLmlkfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGVycm9ycyxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgTGFncmFuZ2UncyB0aGVvcmVtOiBlbGVtZW50IG9yZGVyIGRpdmlkZXMgZ3JvdXAgb3JkZXJcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZUxhZ3JhbmdlVGhlb3JlbShncm91cDogR3JvdXApOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICBncm91cC5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGdyb3VwLm9yZGVyICUgZWxlbWVudC5vcmRlciAhPT0gMCkge1xuICAgICAgICBlcnJvcnMucHVzaChgTGFncmFuZ2UgdGhlb3JlbSB2aW9sYXRpb246IGVsZW1lbnQgJHtlbGVtZW50LmlkfSBoYXMgb3JkZXIgJHtlbGVtZW50Lm9yZGVyfSB3aGljaCBkb2VzIG5vdCBkaXZpZGUgZ3JvdXAgb3JkZXIgJHtncm91cC5vcmRlcn1gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IGdlbmVyYXRvcnMgYWN0dWFsbHkgZ2VuZXJhdGUgdGhlIGdyb3VwXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVHZW5lcmF0b3JzKGdyb3VwOiBHcm91cCk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcblxuICAgIGlmIChncm91cC5nZW5lcmF0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgd2FybmluZ3MucHVzaCgnR3JvdXAgaGFzIG5vIGdlbmVyYXRvcnMgc3BlY2lmaWVkJyk7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCBlcnJvcnMsIHdhcm5pbmdzIH07XG4gICAgfVxuXG4gICAgY29uc3QgZ2VuZXJhdGVkID0gbmV3IFNldChbJ2UnXSk7IC8vIFN0YXJ0IHdpdGggaWRlbnRpdHlcbiAgICBjb25zdCBxdWV1ZSA9IFsuLi5ncm91cC5nZW5lcmF0b3JzXTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gcXVldWUuc2hpZnQoKSE7XG4gICAgICBpZiAoIWdlbmVyYXRlZC5oYXMoY3VycmVudCkpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmFkZChjdXJyZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBhbGwgcHJvZHVjdHMgd2l0aCBleGlzdGluZyBlbGVtZW50c1xuICAgICAgICBBcnJheS5mcm9tKGdlbmVyYXRlZCkuZm9yRWFjaChleGlzdGluZyA9PiB7XG4gICAgICAgICAgY29uc3QgcHJvZHVjdDEgPSBncm91cC5vcGVyYXRpb25zLmdldChjdXJyZW50KT8uZ2V0KGV4aXN0aW5nKTtcbiAgICAgICAgICBjb25zdCBwcm9kdWN0MiA9IGdyb3VwLm9wZXJhdGlvbnMuZ2V0KGV4aXN0aW5nKT8uZ2V0KGN1cnJlbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChwcm9kdWN0MSAmJiAhZ2VuZXJhdGVkLmhhcyhwcm9kdWN0MSkpIHF1ZXVlLnB1c2gocHJvZHVjdDEpO1xuICAgICAgICAgIGlmIChwcm9kdWN0MiAmJiAhZ2VuZXJhdGVkLmhhcyhwcm9kdWN0MikpIHF1ZXVlLnB1c2gocHJvZHVjdDIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2VuZXJhdGVkLnNpemUgIT09IGdyb3VwLm9yZGVyKSB7XG4gICAgICBlcnJvcnMucHVzaChgR2VuZXJhdG9ycyBkbyBub3QgZ2VuZXJhdGUgZnVsbCBncm91cDogZ2VuZXJhdGVkICR7Z2VuZXJhdGVkLnNpemV9IGVsZW1lbnRzLCBleHBlY3RlZCAke2dyb3VwLm9yZGVyfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRWxsaXB0aWMgQ3VydmUgVmFsaWRhdGlvbiBVdGlsaXRpZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEVsbGlwdGljQ3VydmVWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVmFsaWRhdGVzIGVsbGlwdGljIGN1cnZlIHBhcmFtZXRlcnNcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZUN1cnZlKGN1cnZlOiBFbGxpcHRpY0N1cnZlKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKCFjdXJ2ZSkge1xuICAgICAgZXJyb3JzLnB1c2goJ0N1cnZlIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgZXJyb3JzLCB3YXJuaW5ncyB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGRpc2NyaW1pbmFudDogzpQgPSAtMTYoNGHCsyArIDI3YsKyKSDiiaAgMCAobW9kIHApXG4gICAgY29uc3QgZGlzY3JpbWluYW50ID0gLTE2ICogKDQgKiBNYXRoLnBvdyhjdXJ2ZS5hLCAzKSArIDI3ICogTWF0aC5wb3coY3VydmUuYiwgMikpO1xuICAgIGlmIChkaXNjcmltaW5hbnQgJSBjdXJ2ZS5wID09PSAwKSB7XG4gICAgICBlcnJvcnMucHVzaChgQ3VydmUgaXMgc2luZ3VsYXI6IGRpc2NyaW1pbmFudCDiiaEgMCAobW9kICR7Y3VydmUucH0pYCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdGhhdCBwIGlzIGEgcG9zaXRpdmUgaW50ZWdlclxuICAgIGlmICh0eXBlb2YgY3VydmUucCAhPT0gJ251bWJlcicgfHwgY3VydmUucCA8PSAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGN1cnZlLnApKSB7XG4gICAgICBlcnJvcnMucHVzaCgnQ3VydmUgZmllbGQgY2hhcmFjdGVyaXN0aWMgcCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHBhcmFtZXRlcnMgYXJlIGZpbml0ZVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGN1cnZlLmEpIHx8ICFOdW1iZXIuaXNGaW5pdGUoY3VydmUuYikpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdDdXJ2ZSBwYXJhbWV0ZXJzIGEgYW5kIGIgbXVzdCBiZSBmaW5pdGUgbnVtYmVycycpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IGEgcG9pbnQgaXMgb24gdGhlIGN1cnZlXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVQb2ludE9uQ3VydmUocG9pbnQ6IEVsbGlwdGljQ3VydmVQb2ludCwgY3VydmU6IEVsbGlwdGljQ3VydmUpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICBpZiAocG9pbnQuaXNJZGVudGl0eSkge1xuICAgICAgLy8gSWRlbnRpdHkgcG9pbnQgaXMgYWx3YXlzIHZhbGlkXG4gICAgICBpZiAocG9pbnQueCAhPT0gbnVsbCB8fCBwb2ludC55ICE9PSBudWxsKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goJ0lkZW50aXR5IHBvaW50IHNob3VsZCBoYXZlIG51bGwgY29vcmRpbmF0ZXMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUsIGVycm9ycywgd2FybmluZ3MgfTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnQueCA9PT0gbnVsbCB8fCBwb2ludC55ID09PSBudWxsKSB7XG4gICAgICBlcnJvcnMucHVzaCgnTm9uLWlkZW50aXR5IHBvaW50IGNhbm5vdCBoYXZlIG51bGwgY29vcmRpbmF0ZXMnKTtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcnMsIHdhcm5pbmdzIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY3VydmUgZXF1YXRpb246IHnCsiDiiaEgeMKzICsgYXggKyBiIChtb2QgcClcbiAgICBjb25zdCBsZWZ0U2lkZSA9IChwb2ludC55ICogcG9pbnQueSkgJSBjdXJ2ZS5wO1xuICAgIGNvbnN0IHJpZ2h0U2lkZSA9IChwb2ludC54ICogcG9pbnQueCAqIHBvaW50LnggKyBjdXJ2ZS5hICogcG9pbnQueCArIGN1cnZlLmIpICUgY3VydmUucDtcblxuICAgIGlmIChsZWZ0U2lkZSAhPT0gcmlnaHRTaWRlKSB7XG4gICAgICBlcnJvcnMucHVzaChgUG9pbnQgKCR7cG9pbnQueH0sICR7cG9pbnQueX0pIGlzIG5vdCBvbiBjdXJ2ZSB5wrIg4omhIHjCsyArICR7Y3VydmUuYX14ICsgJHtjdXJ2ZS5ifSAobW9kICR7Y3VydmUucH0pYCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY29vcmRpbmF0ZXMgYXJlIGluIGZpZWxkXG4gICAgaWYgKHBvaW50LnggPCAwIHx8IHBvaW50LnggPj0gY3VydmUucCB8fCBwb2ludC55IDwgMCB8fCBwb2ludC55ID49IGN1cnZlLnApIHtcbiAgICAgIGVycm9ycy5wdXNoKGBQb2ludCBjb29yZGluYXRlcyBtdXN0IGJlIGluIHJhbmdlIFswLCAke2N1cnZlLnAgLSAxfV1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGVycm9ycyxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgSGFzc2UncyBib3VuZCBmb3IgZWxsaXB0aWMgY3VydmVzIG92ZXIgZmluaXRlIGZpZWxkc1xuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlSGFzc2VCb3VuZChncm91cE9yZGVyOiBudW1iZXIsIGZpZWxkU2l6ZTogbnVtYmVyKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gSGFzc2UncyBib3VuZDogfCNFKEZwKSAtIChwICsgMSl8IOKJpCAy4oiacFxuICAgIGNvbnN0IGJvdW5kID0gMiAqIE1hdGguc3FydChmaWVsZFNpemUpO1xuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBNYXRoLmFicyhncm91cE9yZGVyIC0gKGZpZWxkU2l6ZSArIDEpKTtcblxuICAgIGlmIChkaWZmZXJlbmNlID4gYm91bmQpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBIYXNzZSBib3VuZCB2aW9sYXRpb246IHwke2dyb3VwT3JkZXJ9IC0gJHtmaWVsZFNpemUgKyAxfXwgPSAke2RpZmZlcmVuY2V9ID4gJHtib3VuZH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGVycm9ycyxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFRvcG9sb2dpY2FsIERhdGEgQW5hbHlzaXMgVmFsaWRhdGlvbiBVdGlsaXRpZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFREQVZhbGlkYXRvciB7XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgcGVyc2lzdGVuY2UgaW50ZXJ2YWxcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVBlcnNpc3RlbmNlSW50ZXJ2YWwoaW50ZXJ2YWw6IFBlcnNpc3RlbmNlSW50ZXJ2YWwpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICBlcnJvcnMucHVzaCgnSW50ZXJ2YWwgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcnMsIHdhcm5pbmdzIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnRlcnZhbC5iaXJ0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdCaXJ0aCB0aW1lIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnRlcnZhbC5kZWF0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdEZWF0aCB0aW1lIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnRlcnZhbC5kaW1lbnNpb24gIT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcnMucHVzaCgnRGltZW5zaW9uIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW50ZXJ2YWwuZGltZW5zaW9uKSkge1xuICAgICAgZXJyb3JzLnB1c2goJ0RpbWVuc2lvbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG4gICAgaWYgKGludGVydmFsLmRpbWVuc2lvbiA8IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKCdEaW1lbnNpb24gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJ2YWwuZGVhdGggPCBpbnRlcnZhbC5iaXJ0aCkge1xuICAgICAgZXJyb3JzLnB1c2goYERlYXRoIHRpbWUgJHtpbnRlcnZhbC5kZWF0aH0gbXVzdCBiZSDiiaUgYmlydGggdGltZSAke2ludGVydmFsLmJpcnRofWApO1xuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGludGVydmFsLmJpcnRoKSB8fCAhTnVtYmVyLmlzRmluaXRlKGludGVydmFsLmRlYXRoKSkge1xuICAgICAgZXJyb3JzLnB1c2goJ0JpcnRoIGFuZCBkZWF0aCB0aW1lcyBtdXN0IGJlIGZpbml0ZScpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IGEgc2V0IG9mIGludGVydmFscyBmb3JtcyBhIHZhbGlkIHBlcnNpc3RlbmNlIGRpYWdyYW1cbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVBlcnNpc3RlbmNlRGlhZ3JhbShpbnRlcnZhbHM6IFBlcnNpc3RlbmNlSW50ZXJ2YWxbXSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnRlcnZhbHMpKSB7XG4gICAgICBlcnJvcnMucHVzaCgnSW50ZXJ2YWxzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBlcnJvcnMsIHdhcm5pbmdzIH07XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgZWFjaCBpbnRlcnZhbFxuICAgIGludGVydmFscy5mb3JFYWNoKChpbnRlcnZhbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsaWRhdGVQZXJzaXN0ZW5jZUludGVydmFsKGludGVydmFsKTtcbiAgICAgIGlmICghcmVzdWx0LmlzVmFsaWQpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYEludGVydmFsICR7aW5kZXh9OiAke3Jlc3VsdC5lcnJvcnMuam9pbignLCAnKX1gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGZvciBIMCBpbnRlcnZhbHMgKGRpbWVuc2lvbiAwKVxuICAgIGNvbnN0IGgwSW50ZXJ2YWxzID0gaW50ZXJ2YWxzLmZpbHRlcihpID0+IGkuZGltZW5zaW9uID09PSAwKTtcbiAgICBpZiAoaDBJbnRlcnZhbHMubGVuZ3RoID09PSAwICYmIGludGVydmFscy5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKCdObyBIMCAoY29ubmVjdGVkIGNvbXBvbmVudCkgaW50ZXJ2YWxzIGZvdW5kIC0gdGhpcyBtYXkgaW5kaWNhdGUgaXNzdWVzIHdpdGggdGhlIGNvbXB1dGF0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZGltZW5zaW9uIGNvbnN0cmFpbnRzIGZvciBFdWNsaWRlYW4gZGF0YVxuICAgIGNvbnN0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KC4uLmludGVydmFscy5tYXAoaSA9PiBpLmRpbWVuc2lvbikpO1xuICAgIGlmIChtYXhEaW1lbnNpb24gPiAyKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBIaWdoIGRpbWVuc2lvbmFsIGZlYXR1cmVzIChkaW0gPiAyKSBmb3VuZCAtIHZlcmlmeSB0aGlzIGlzIGV4cGVjdGVkIGZvciB5b3VyIGRhdGFgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGVycm9ycyxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdG9wb2xvZ2ljYWwgcHJvcGVydGllcyBiYXNlZCBvbiBwb2ludCBjbG91ZCBnZW9tZXRyeVxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlVG9wb2xvZ2ljYWxDb25zaXN0ZW5jeShcbiAgICBpbnRlcnZhbHM6IFBlcnNpc3RlbmNlSW50ZXJ2YWxbXSwgXG4gICAgcG9pbnRDbG91ZDogbnVtYmVyW11bXSwgXG4gICAgZmlsdHJhdGlvblJhZGl1czogbnVtYmVyXG4gICk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIEJhc2ljIGNvbnNpc3RlbmN5IGNoZWNrc1xuICAgIGlmIChwb2ludENsb3VkLmxlbmd0aCA9PT0gMCAmJiBpbnRlcnZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgZXJyb3JzLnB1c2goJ0VtcHR5IHBvaW50IGNsb3VkIHNob3VsZCBub3QgZ2VuZXJhdGUgcGVyc2lzdGVuY2UgaW50ZXJ2YWxzJyk7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50Q2xvdWQubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBoMEludGVydmFscyA9IGludGVydmFscy5maWx0ZXIoaSA9PiBpLmRpbWVuc2lvbiA9PT0gMCk7XG4gICAgICBpZiAoaDBJbnRlcnZhbHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goJ1NpbmdsZSBwb2ludCBzaG91bGQgZ2VuZXJhdGUgZXhhY3RseSBvbmUgSDAgaW50ZXJ2YWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGF0IGRlYXRoIHRpbWVzIHJlc3BlY3QgZmlsdHJhdGlvbiByYWRpdXNcbiAgICBpbnRlcnZhbHMuZm9yRWFjaCgoaW50ZXJ2YWwsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW50ZXJ2YWwuZGVhdGggPiBmaWx0cmF0aW9uUmFkaXVzICogMS4xKSB7IC8vIFNtYWxsIHRvbGVyYW5jZVxuICAgICAgICB3YXJuaW5ncy5wdXNoKGBJbnRlcnZhbCAke2luZGV4fSBoYXMgZGVhdGggdGltZSAke2ludGVydmFsLmRlYXRofSA+IGZpbHRyYXRpb24gcmFkaXVzICR7ZmlsdHJhdGlvblJhZGl1c31gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERpbWVuc2lvbiBjb25zdHJhaW50cyBiYXNlZCBvbiBwb2ludCBjbG91ZCBkaW1lbnNpb25cbiAgICBpZiAocG9pbnRDbG91ZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwb2ludERpbWVuc2lvbiA9IHBvaW50Q2xvdWRbMF0ubGVuZ3RoO1xuICAgICAgY29uc3QgbWF4SG9tb2xvZ3lEaW0gPSBNYXRoLm1heCguLi5pbnRlcnZhbHMubWFwKGkgPT4gaS5kaW1lbnNpb24pKTtcbiAgICAgIFxuICAgICAgaWYgKG1heEhvbW9sb2d5RGltID49IHBvaW50RGltZW5zaW9uKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goYEhvbW9sb2d5IGRpbWVuc2lvbiAke21heEhvbW9sb2d5RGltfSDiiaUgcG9pbnQgY2xvdWQgZGltZW5zaW9uICR7cG9pbnREaW1lbnNpb259IC0gbWF5IGluZGljYXRlIGNvbXB1dGF0aW9uYWwgaXNzdWVzYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgICB3YXJuaW5nc1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBOdW1lcmljYWwgUHJlY2lzaW9uIFZhbGlkYXRpb24gVXRpbGl0aWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmVjaXNpb25WYWxpZGF0b3Ige1xuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyB3aXRoaW4gZXhwZWN0ZWQgbnVtZXJpY2FsIHByZWNpc2lvblxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlTnVtZXJpY2FsUHJlY2lzaW9uKFxuICAgIGFjdHVhbDogbnVtYmVyLCBcbiAgICBleHBlY3RlZDogbnVtYmVyLCBcbiAgICB0b2xlcmFuY2U6IG51bWJlciA9IE1BVEhFTUFUSUNBTF9QUkVDSVNJT04uREVGQVVMVF9UT0xFUkFOQ0VcbiAgKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGFjdHVhbCAtIGV4cGVjdGVkKTtcbiAgICBcbiAgICBpZiAoZGlmZmVyZW5jZSA+IHRvbGVyYW5jZSkge1xuICAgICAgZXJyb3JzLnB1c2goYFByZWNpc2lvbiBlcnJvcjogfCR7YWN0dWFsfSAtICR7ZXhwZWN0ZWR9fCA9ICR7ZGlmZmVyZW5jZX0gPiB0b2xlcmFuY2UgJHt0b2xlcmFuY2V9YCk7XG4gICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlID4gdG9sZXJhbmNlICogMC4xKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBOZWFyIHByZWNpc2lvbiBsaW1pdDogZGlmZmVyZW5jZSAke2RpZmZlcmVuY2V9IGFwcHJvYWNoaW5nIHRvbGVyYW5jZSAke3RvbGVyYW5jZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIGVycm9ycyxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9ucyBmb3Igc3RhYmlsaXR5XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVGbG9hdGluZ1BvaW50U3RhYmlsaXR5KHZhbHVlczogbnVtYmVyW10pOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYFZhbHVlIGF0IGluZGV4ICR7aW5kZXh9IGlzIG5vdCBmaW5pdGU6ICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICBlcnJvcnMucHVzaChgVmFsdWUgYXQgaW5kZXggJHtpbmRleH0gaXMgTmFOYCk7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnModmFsdWUpID4gMWUxNSkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKGBWZXJ5IGxhcmdlIHZhbHVlIGF0IGluZGV4ICR7aW5kZXh9OiAke3ZhbHVlfSBtYXkgaW5kaWNhdGUgbnVtZXJpY2FsIGluc3RhYmlsaXR5YCk7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnModmFsdWUpIDwgMWUtMTUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChgVmVyeSBzbWFsbCB2YWx1ZSBhdCBpbmRleCAke2luZGV4fTogJHt2YWx1ZX0gbWF5IGluZGljYXRlIHVuZGVyZmxvd2ApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgICB3YXJuaW5nc1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtYW5jZSBWYWxpZGF0aW9uIFV0aWxpdGllc1xuICovXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VWYWxpZGF0b3Ige1xuICAvKipcbiAgICogVmFsaWRhdGVzIGNvbXB1dGF0aW9uYWwgcGVyZm9ybWFuY2UgYWdhaW5zdCBleHBlY3RlZCBib3VuZHNcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVBlcmZvcm1hbmNlQm91bmRzKFxuICAgIGFjdHVhbFRpbWU6IG51bWJlcixcbiAgICBleHBlY3RlZEJvdW5kOiBudW1iZXIsXG4gICAgb3BlcmF0aW9uOiBzdHJpbmdcbiAgKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKGFjdHVhbFRpbWUgPiBleHBlY3RlZEJvdW5kKSB7XG4gICAgICBlcnJvcnMucHVzaChgUGVyZm9ybWFuY2UgYm91bmQgZXhjZWVkZWQgZm9yICR7b3BlcmF0aW9ufTogJHthY3R1YWxUaW1lfW1zID4gJHtleHBlY3RlZEJvdW5kfW1zYCk7XG4gICAgfSBlbHNlIGlmIChhY3R1YWxUaW1lID4gZXhwZWN0ZWRCb3VuZCAqIDAuOCkge1xuICAgICAgd2FybmluZ3MucHVzaChgUGVyZm9ybWFuY2UgYXBwcm9hY2hpbmcgYm91bmQgZm9yICR7b3BlcmF0aW9ufTogJHthY3R1YWxUaW1lfW1zIG5lYXIgbGltaXQgJHtleHBlY3RlZEJvdW5kfW1zYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgICB3YXJuaW5nc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIG1lbW9yeSB1c2FnZSBwYXR0ZXJuc1xuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlTWVtb3J5VXNhZ2UoXG4gICAgaW5pdGlhbE1lbW9yeTogbnVtYmVyLFxuICAgIGZpbmFsTWVtb3J5OiBudW1iZXIsXG4gICAgbWF4QWxsb3dlZEluY3JlYXNlOiBudW1iZXIsXG4gICAgb3BlcmF0aW9uOiBzdHJpbmdcbiAgKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG5cbiAgICBpZiAobWVtb3J5SW5jcmVhc2UgPiBtYXhBbGxvd2VkSW5jcmVhc2UpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBNZW1vcnkgdXNhZ2UgZXhjZWVkZWQgZm9yICR7b3BlcmF0aW9ufTogJHttZW1vcnlJbmNyZWFzZX0gYnl0ZXMgPiAke21heEFsbG93ZWRJbmNyZWFzZX0gYnl0ZXNgKTtcbiAgICB9IGVsc2UgaWYgKG1lbW9yeUluY3JlYXNlID4gbWF4QWxsb3dlZEluY3JlYXNlICogMC44KSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBNZW1vcnkgdXNhZ2UgYXBwcm9hY2hpbmcgbGltaXQgZm9yICR7b3BlcmF0aW9ufTogJHttZW1vcnlJbmNyZWFzZX0gYnl0ZXMgbmVhciAke21heEFsbG93ZWRJbmNyZWFzZX0gYnl0ZXNgKTtcbiAgICB9XG5cbiAgICBpZiAobWVtb3J5SW5jcmVhc2UgPCAwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBOZWdhdGl2ZSBtZW1vcnkgY2hhbmdlIGRldGVjdGVkIGZvciAke29wZXJhdGlvbn06ICR7bWVtb3J5SW5jcmVhc2V9IGJ5dGVzIC0gdGhpcyBtYXkgaW5kaWNhdGUgbWVhc3VyZW1lbnQgaXNzdWVzYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgICB3YXJuaW5nc1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGFnZ3JlZ2F0ZSBtdWx0aXBsZSB2YWxpZGF0aW9uIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZVZhbGlkYXRpb25SZXN1bHRzKHJlc3VsdHM6IFZhbGlkYXRpb25SZXN1bHRbXSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBhbGxFcnJvcnMgPSByZXN1bHRzLmZsYXRNYXAociA9PiByLmVycm9ycyk7XG4gIGNvbnN0IGFsbFdhcm5pbmdzID0gcmVzdWx0cy5mbGF0TWFwKHIgPT4gci53YXJuaW5ncyk7XG4gIFxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IGFsbEVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgZXJyb3JzOiBhbGxFcnJvcnMsXG4gICAgd2FybmluZ3M6IGFsbFdhcm5pbmdzXG4gIH07XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBsb2cgdmFsaWRhdGlvbiByZXN1bHRzIHdpdGggcHJvcGVyIGZvcm1hdHRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ1ZhbGlkYXRpb25SZXN1bHQocmVzdWx0OiBWYWxpZGF0aW9uUmVzdWx0LCBjb250ZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFyZXN1bHQuaXNWYWxpZCkge1xuICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBWYWxpZGF0aW9uIGZhaWxlZCBmb3IgJHtjb250ZXh0fTpgKTtcbiAgICByZXN1bHQuZXJyb3JzLmZvckVhY2goZXJyb3IgPT4gY29uc29sZS5lcnJvcihgICAgRXJyb3I6ICR7ZXJyb3J9YCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGDinIUgVmFsaWRhdGlvbiBwYXNzZWQgZm9yICR7Y29udGV4dH1gKTtcbiAgfVxuICBcbiAgaWYgKHJlc3VsdC53YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc29sZS53YXJuKGDimqDvuI8gIFdhcm5pbmdzIGZvciAke2NvbnRleHR9OmApO1xuICAgIHJlc3VsdC53YXJuaW5ncy5mb3JFYWNoKHdhcm5pbmcgPT4gY29uc29sZS53YXJuKGAgICBXYXJuaW5nOiAke3dhcm5pbmd9YCkpO1xuICB9XG59XG5cbi8qKlxuICogSmVzdCBtYXRjaGVyIGV4dGVuc2lvbnMgZm9yIG1hdGhlbWF0aWNhbCB2YWxpZGF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRoZW1hdGljYWxNYXRjaGVycyA9IHtcbiAgdG9CZVZhbGlkR3JvdXAocmVjZWl2ZWQ6IEdyb3VwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gR3JvdXBUaGVvcnlWYWxpZGF0b3IudmFsaWRhdGVHcm91cEF4aW9tcyhyZWNlaXZlZCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6ICgpID0+IHJlc3VsdC5pc1ZhbGlkIFxuICAgICAgICA/IGBFeHBlY3RlZCBncm91cCB0byBiZSBpbnZhbGlkLCBidXQgaXQgcGFzc2VkIHZhbGlkYXRpb25gXG4gICAgICAgIDogYEV4cGVjdGVkIGdyb3VwIHRvIGJlIHZhbGlkOiAke3Jlc3VsdC5lcnJvcnMuam9pbignLCAnKX1gLFxuICAgICAgcGFzczogcmVzdWx0LmlzVmFsaWRcbiAgICB9O1xuICB9LFxuXG4gIHRvQmVWYWxpZEVsbGlwdGljQ3VydmVQb2ludChyZWNlaXZlZDogRWxsaXB0aWNDdXJ2ZVBvaW50LCBjdXJ2ZTogRWxsaXB0aWNDdXJ2ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IEVsbGlwdGljQ3VydmVWYWxpZGF0b3IudmFsaWRhdGVQb2ludE9uQ3VydmUocmVjZWl2ZWQsIGN1cnZlKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogKCkgPT4gcmVzdWx0LmlzVmFsaWRcbiAgICAgICAgPyBgRXhwZWN0ZWQgcG9pbnQgdG8gYmUgaW52YWxpZCwgYnV0IGl0IHBhc3NlZCB2YWxpZGF0aW9uYFxuICAgICAgICA6IGBFeHBlY3RlZCBwb2ludCB0byBiZSB2YWxpZDogJHtyZXN1bHQuZXJyb3JzLmpvaW4oJywgJyl9YCxcbiAgICAgIHBhc3M6IHJlc3VsdC5pc1ZhbGlkXG4gICAgfTtcbiAgfSxcblxuICB0b0JlVmFsaWRQZXJzaXN0ZW5jZUludGVydmFsKHJlY2VpdmVkOiBQZXJzaXN0ZW5jZUludGVydmFsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gVERBVmFsaWRhdG9yLnZhbGlkYXRlUGVyc2lzdGVuY2VJbnRlcnZhbChyZWNlaXZlZCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6ICgpID0+IHJlc3VsdC5pc1ZhbGlkXG4gICAgICAgID8gYEV4cGVjdGVkIGludGVydmFsIHRvIGJlIGludmFsaWQsIGJ1dCBpdCBwYXNzZWQgdmFsaWRhdGlvbmBcbiAgICAgICAgOiBgRXhwZWN0ZWQgaW50ZXJ2YWwgdG8gYmUgdmFsaWQ6ICR7cmVzdWx0LmVycm9ycy5qb2luKCcsICcpfWAsXG4gICAgICBwYXNzOiByZXN1bHQuaXNWYWxpZFxuICAgIH07XG4gIH0sXG5cbiAgdG9CZVdpdGhpblRvbGVyYW5jZShyZWNlaXZlZDogbnVtYmVyLCBleHBlY3RlZDogbnVtYmVyLCB0b2xlcmFuY2U/OiBudW1iZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBQcmVjaXNpb25WYWxpZGF0b3IudmFsaWRhdGVOdW1lcmljYWxQcmVjaXNpb24oXG4gICAgICByZWNlaXZlZCwgXG4gICAgICBleHBlY3RlZCwgXG4gICAgICB0b2xlcmFuY2UgfHwgTUFUSEVNQVRJQ0FMX1BSRUNJU0lPTi5ERUZBVUxUX1RPTEVSQU5DRVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6ICgpID0+IHJlc3VsdC5pc1ZhbGlkXG4gICAgICAgID8gYEV4cGVjdGVkICR7cmVjZWl2ZWR9IG5vdCB0byBiZSB3aXRoaW4gdG9sZXJhbmNlIG9mICR7ZXhwZWN0ZWR9YFxuICAgICAgICA6IGBFeHBlY3RlZCAke3JlY2VpdmVkfSB0byBiZSB3aXRoaW4gdG9sZXJhbmNlIG9mICR7ZXhwZWN0ZWR9OiAke3Jlc3VsdC5lcnJvcnMuam9pbignLCAnKX1gLFxuICAgICAgcGFzczogcmVzdWx0LmlzVmFsaWRcbiAgICB9O1xuICB9XG59O1xuXG4vLyBUeXBlIGF1Z21lbnRhdGlvbiBmb3IgSmVzdCBtYXRjaGVyc1xuZGVjbGFyZSBnbG9iYWwge1xuICBuYW1lc3BhY2UgamVzdCB7XG4gICAgaW50ZXJmYWNlIE1hdGNoZXJzPFI+IHtcbiAgICAgIHRvQmVWYWxpZEdyb3VwKCk6IFI7XG4gICAgICB0b0JlVmFsaWRFbGxpcHRpY0N1cnZlUG9pbnQoY3VydmU6IEVsbGlwdGljQ3VydmUpOiBSO1xuICAgICAgdG9CZVZhbGlkUGVyc2lzdGVuY2VJbnRlcnZhbCgpOiBSO1xuICAgICAgdG9CZVdpdGhpblRvbGVyYW5jZShleHBlY3RlZDogbnVtYmVyLCB0b2xlcmFuY2U/OiBudW1iZXIpOiBSO1xuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6WyJFbGxpcHRpY0N1cnZlVmFsaWRhdG9yIiwiR3JvdXBUaGVvcnlWYWxpZGF0b3IiLCJNQVRIRU1BVElDQUxfUFJFQ0lTSU9OIiwiUGVyZm9ybWFuY2VWYWxpZGF0b3IiLCJQcmVjaXNpb25WYWxpZGF0b3IiLCJUREFWYWxpZGF0b3IiLCJhZ2dyZWdhdGVWYWxpZGF0aW9uUmVzdWx0cyIsImxvZ1ZhbGlkYXRpb25SZXN1bHQiLCJtYXRoZW1hdGljYWxNYXRjaGVycyIsIkRFRkFVTFRfVE9MRVJBTkNFIiwiRkxPQVRfVE9MRVJBTkNFIiwiU1RBVElTVElDQUxfVE9MRVJBTkNFIiwidmFsaWRhdGVHcm91cEVsZW1lbnQiLCJlbGVtZW50IiwiZXJyb3JzIiwid2FybmluZ3MiLCJwdXNoIiwiaWQiLCJsYWJlbCIsIm9yZGVyIiwiaW52ZXJzZSIsImNvbmp1Z2FjeUNsYXNzIiwiaXNWYWxpZCIsImxlbmd0aCIsInZhbGlkYXRlR3JvdXBBeGlvbXMiLCJncm91cCIsImVsZW1lbnRzIiwiZm9yRWFjaCIsImEiLCJiIiwicHJvZHVjdCIsIm9wZXJhdGlvbnMiLCJnZXQiLCJmaW5kIiwiZSIsImlkZW50aXR5IiwibGVmdFByb2R1Y3QiLCJyaWdodFByb2R1Y3QiLCJpbnZlcnNlSWQiLCJ0ZXN0RWxlbWVudHMiLCJzbGljZSIsIk1hdGgiLCJtaW4iLCJjIiwiYWIiLCJiYyIsImFiX2MiLCJhX2JjIiwidmFsaWRhdGVMYWdyYW5nZVRoZW9yZW0iLCJ2YWxpZGF0ZUdlbmVyYXRvcnMiLCJnZW5lcmF0b3JzIiwiZ2VuZXJhdGVkIiwiU2V0IiwicXVldWUiLCJjdXJyZW50Iiwic2hpZnQiLCJoYXMiLCJhZGQiLCJBcnJheSIsImZyb20iLCJleGlzdGluZyIsInByb2R1Y3QxIiwicHJvZHVjdDIiLCJzaXplIiwidmFsaWRhdGVDdXJ2ZSIsImN1cnZlIiwiZGlzY3JpbWluYW50IiwicG93IiwicCIsIk51bWJlciIsImlzSW50ZWdlciIsImlzRmluaXRlIiwidmFsaWRhdGVQb2ludE9uQ3VydmUiLCJwb2ludCIsImlzSWRlbnRpdHkiLCJ4IiwieSIsImxlZnRTaWRlIiwicmlnaHRTaWRlIiwidmFsaWRhdGVIYXNzZUJvdW5kIiwiZ3JvdXBPcmRlciIsImZpZWxkU2l6ZSIsImJvdW5kIiwic3FydCIsImRpZmZlcmVuY2UiLCJhYnMiLCJ2YWxpZGF0ZVBlcnNpc3RlbmNlSW50ZXJ2YWwiLCJpbnRlcnZhbCIsImJpcnRoIiwiZGVhdGgiLCJkaW1lbnNpb24iLCJ2YWxpZGF0ZVBlcnNpc3RlbmNlRGlhZ3JhbSIsImludGVydmFscyIsImlzQXJyYXkiLCJpbmRleCIsInJlc3VsdCIsImpvaW4iLCJoMEludGVydmFscyIsImZpbHRlciIsImkiLCJtYXhEaW1lbnNpb24iLCJtYXgiLCJtYXAiLCJ2YWxpZGF0ZVRvcG9sb2dpY2FsQ29uc2lzdGVuY3kiLCJwb2ludENsb3VkIiwiZmlsdHJhdGlvblJhZGl1cyIsInBvaW50RGltZW5zaW9uIiwibWF4SG9tb2xvZ3lEaW0iLCJ2YWxpZGF0ZU51bWVyaWNhbFByZWNpc2lvbiIsImFjdHVhbCIsImV4cGVjdGVkIiwidG9sZXJhbmNlIiwidmFsaWRhdGVGbG9hdGluZ1BvaW50U3RhYmlsaXR5IiwidmFsdWVzIiwidmFsdWUiLCJpc05hTiIsInZhbGlkYXRlUGVyZm9ybWFuY2VCb3VuZHMiLCJhY3R1YWxUaW1lIiwiZXhwZWN0ZWRCb3VuZCIsIm9wZXJhdGlvbiIsInZhbGlkYXRlTWVtb3J5VXNhZ2UiLCJpbml0aWFsTWVtb3J5IiwiZmluYWxNZW1vcnkiLCJtYXhBbGxvd2VkSW5jcmVhc2UiLCJtZW1vcnlJbmNyZWFzZSIsInJlc3VsdHMiLCJhbGxFcnJvcnMiLCJmbGF0TWFwIiwiciIsImFsbFdhcm5pbmdzIiwiY29udGV4dCIsImNvbnNvbGUiLCJlcnJvciIsImxvZyIsIndhcm4iLCJ3YXJuaW5nIiwidG9CZVZhbGlkR3JvdXAiLCJyZWNlaXZlZCIsIm1lc3NhZ2UiLCJwYXNzIiwidG9CZVZhbGlkRWxsaXB0aWNDdXJ2ZVBvaW50IiwidG9CZVZhbGlkUGVyc2lzdGVuY2VJbnRlcnZhbCIsInRvQmVXaXRoaW5Ub2xlcmFuY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7Ozs7Ozs7Ozs7O0lBNk5ZQSxzQkFBc0I7ZUFBdEJBOztJQXpMQUMsb0JBQW9CO2VBQXBCQTs7SUFUQUMsc0JBQXNCO2VBQXRCQTs7SUEyZUFDLG9CQUFvQjtlQUFwQkE7O0lBNURBQyxrQkFBa0I7ZUFBbEJBOztJQXZJQUMsWUFBWTtlQUFaQTs7SUErUEdDLDBCQUEwQjtlQUExQkE7O0lBY0FDLG1CQUFtQjtlQUFuQkE7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