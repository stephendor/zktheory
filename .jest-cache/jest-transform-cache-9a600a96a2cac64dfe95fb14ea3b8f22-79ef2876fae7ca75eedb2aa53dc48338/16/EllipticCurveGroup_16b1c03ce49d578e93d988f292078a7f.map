{"version":3,"sources":["/home/stephen-dorman/dev/zktheory/src/lib/EllipticCurveGroup.ts"],"sourcesContent":["/**\n * Elliptic Curve Group Theory Implementation\n * Supports elliptic curves of the form y² = x³ + ax + b over finite fields Fp\n */\n\nimport { Group, GroupElement } from './GroupTheory';\n\nexport interface EllipticCurvePoint {\n  x: number;\n  y: number;\n  isInfinity: boolean;\n}\n\nexport interface EllipticCurveParameters {\n  a: number;  // Coefficient for x term\n  b: number;  // Constant term  \n  p: number;  // Prime modulus for finite field Fp\n}\n\n/**\n * Finite Field arithmetic operations for Fp\n */\nexport class FiniteField {\n  constructor(public readonly p: number) {\n    if (!this.isPrime(p)) {\n      throw new Error(`${p} is not a prime number`);\n    }\n  }\n\n  private isPrime(n: number): boolean {\n    if (n < 2) return false;\n    if (n === 2) return true;\n    if (n % 2 === 0) return false;\n    \n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n      if (n % i === 0) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Modular addition: (a + b) mod p\n   */\n  add(a: number, b: number): number {\n    return ((a + b) % this.p + this.p) % this.p;\n  }\n\n  /**\n   * Modular subtraction: (a - b) mod p\n   */\n  subtract(a: number, b: number): number {\n    return ((a - b) % this.p + this.p) % this.p;\n  }\n\n  /**\n   * Modular multiplication: (a * b) mod p\n   */\n  multiply(a: number, b: number): number {\n    return ((a * b) % this.p + this.p) % this.p;\n  }\n\n  /**\n   * Modular exponentiation: a^b mod p using fast exponentiation\n   */\n  power(a: number, b: number): number {\n    if (b === 0) return 1;\n    \n    let result = 1;\n    a = ((a % this.p) + this.p) % this.p;\n    \n    while (b > 0) {\n      if (b % 2 === 1) {\n        result = this.multiply(result, a);\n      }\n      b = Math.floor(b / 2);\n      a = this.multiply(a, a);\n    }\n    \n    return result;\n  }\n\n  /**\n   * Modular multiplicative inverse using Extended Euclidean Algorithm\n   */\n  inverse(a: number): number {\n    if (a === 0) {\n      throw new Error('Cannot find inverse of 0');\n    }\n\n    let [oldR, r] = [a, this.p];\n    let [oldS, s] = [1, 0];\n\n    while (r !== 0) {\n      const quotient = Math.floor(oldR / r);\n      [oldR, r] = [r, oldR - quotient * r];\n      [oldS, s] = [s, oldS - quotient * s];\n    }\n\n    if (oldR > 1) {\n      throw new Error(`${a} is not invertible modulo ${this.p}`);\n    }\n\n    return ((oldS % this.p) + this.p) % this.p;\n  }\n\n  /**\n   * Check if a number is a quadratic residue (has square root) mod p\n   */\n  isQuadraticResidue(a: number): boolean {\n    if (a === 0) return true;\n    return this.power(a, (this.p - 1) / 2) === 1;\n  }\n\n  /**\n   * Compute square root mod p using Tonelli-Shanks algorithm (simplified for small primes)\n   */\n  sqrt(a: number): number[] {\n    if (!this.isQuadraticResidue(a)) {\n      return [];\n    }\n\n    if (a === 0) return [0];\n\n    // For p ≡ 3 (mod 4), we can use the simple formula\n    if (this.p % 4 === 3) {\n      const result = this.power(a, (this.p + 1) / 4);\n      return [result, this.subtract(0, result)];\n    }\n\n    // For other cases, use trial method for small primes\n    for (let x = 0; x < this.p; x++) {\n      if (this.multiply(x, x) === a) {\n        return x === 0 ? [0] : [x, this.subtract(0, x)];\n      }\n    }\n\n    return [];\n  }\n\n  /**\n   * Normalize a number to the range [0, p)\n   */\n  normalize(a: number): number {\n    return ((a % this.p) + this.p) % this.p;\n  }\n}\n\n/**\n * Elliptic Curve Point operations\n */\nexport class EllipticCurve {\n  private field: FiniteField;\n\n  constructor(public readonly params: EllipticCurveParameters) {\n    this.field = new FiniteField(params.p);\n    \n    // Check curve is non-singular: 4a³ + 27b² ≠ 0 mod p\n    const discriminant = this.field.add(\n      this.field.multiply(4, this.field.power(params.a, 3)),\n      this.field.multiply(27, this.field.power(params.b, 2))\n    );\n    \n    if (discriminant === 0) {\n      throw new Error('Curve is singular (discriminant = 0)');\n    }\n  }\n\n  /**\n   * Create the point at infinity (identity element)\n   */\n  infinity(): EllipticCurvePoint {\n    return { x: 0, y: 0, isInfinity: true };\n  }\n\n  /**\n   * Create a finite point\n   */\n  point(x: number, y: number): EllipticCurvePoint {\n    x = this.field.normalize(x);\n    y = this.field.normalize(y);\n    \n    if (!this.isOnCurve({ x, y, isInfinity: false })) {\n      throw new Error(`Point (${x}, ${y}) is not on the curve`);\n    }\n    \n    return { x, y, isInfinity: false };\n  }\n\n  /**\n   * Check if a point lies on the curve: y² = x³ + ax + b\n   */\n  isOnCurve(point: EllipticCurvePoint): boolean {\n    if (point.isInfinity) return true;\n\n    const { x, y } = point;\n    const { a, b } = this.params;\n\n    // Compute y²\n    const leftSide = this.field.multiply(y, y);\n\n    // Compute x³ + ax + b\n    const rightSide = this.field.add(\n      this.field.add(\n        this.field.power(x, 3),\n        this.field.multiply(a, x)\n      ),\n      b\n    );\n\n    return leftSide === rightSide;\n  }\n\n  /**\n   * Point addition: P + Q\n   */\n  add(P: EllipticCurvePoint, Q: EllipticCurvePoint): EllipticCurvePoint {\n    // P + O = P\n    if (Q.isInfinity) return P;\n    // O + P = P  \n    if (P.isInfinity) return Q;\n\n    const { x: x1, y: y1 } = P;\n    const { x: x2, y: y2 } = Q;\n\n    // P + (-P) = O\n    if (x1 === x2 && this.field.add(y1, y2) === 0) {\n      return this.infinity();\n    }\n\n    let slope: number;\n\n    if (x1 === x2 && y1 === y2) {\n      // Point doubling: P + P\n      // slope = (3x₁² + a) / (2y₁)\n      const numerator = this.field.add(\n        this.field.multiply(3, this.field.multiply(x1, x1)),\n        this.params.a\n      );\n      const denominator = this.field.multiply(2, y1);\n      slope = this.field.multiply(numerator, this.field.inverse(denominator));\n    } else {\n      // Point addition: P + Q where P ≠ Q\n      // slope = (y₂ - y₁) / (x₂ - x₁)\n      const numerator = this.field.subtract(y2, y1);\n      const denominator = this.field.subtract(x2, x1);\n      slope = this.field.multiply(numerator, this.field.inverse(denominator));\n    }\n\n    // x₃ = slope² - x₁ - x₂\n    const x3 = this.field.subtract(\n      this.field.subtract(\n        this.field.multiply(slope, slope),\n        x1\n      ),\n      x2\n    );\n\n    // y₃ = slope(x₁ - x₃) - y₁\n    const y3 = this.field.subtract(\n      this.field.multiply(slope, this.field.subtract(x1, x3)),\n      y1\n    );\n\n    return { x: x3, y: y3, isInfinity: false };\n  }\n\n  /**\n   * Point negation: -P\n   */\n  negate(point: EllipticCurvePoint): EllipticCurvePoint {\n    if (point.isInfinity) return point;\n    \n    return {\n      x: point.x,\n      y: this.field.subtract(0, point.y),\n      isInfinity: false\n    };\n  }\n\n  /**\n   * Scalar multiplication: k * P using double-and-add algorithm\n   */\n  multiply(k: number, P: EllipticCurvePoint): EllipticCurvePoint {\n    if (k === 0) return this.infinity();\n    if (k === 1) return P;\n    if (k < 0) return this.multiply(-k, this.negate(P));\n\n    let result = this.infinity();\n    let addend = P;\n\n    while (k > 0) {\n      if (k % 2 === 1) {\n        result = this.add(result, addend);\n      }\n      addend = this.add(addend, addend); // Double\n      k = Math.floor(k / 2);\n    }\n\n    return result;\n  }\n\n  /**\n   * Find all points on the curve\n   */\n  getAllPoints(): EllipticCurvePoint[] {\n    const points: EllipticCurvePoint[] = [this.infinity()];\n\n    for (let x = 0; x < this.params.p; x++) {\n      // Compute y² = x³ + ax + b\n      const ySquared = this.field.add(\n        this.field.add(\n          this.field.power(x, 3),\n          this.field.multiply(this.params.a, x)\n        ),\n        this.params.b\n      );\n\n      // Find square roots of y²\n      const yValues = this.field.sqrt(ySquared);\n      for (const y of yValues) {\n        points.push({ x, y, isInfinity: false });\n      }\n    }\n\n    return points;\n  }\n\n  /**\n   * Compute the order of a point (smallest positive k such that k*P = O)\n   */\n  pointOrder(P: EllipticCurvePoint): number {\n    if (P.isInfinity) return 1;\n\n    let current = P;\n    let order = 1;\n\n    while (!current.isInfinity) {\n      current = this.add(current, P);\n      order++;\n      \n      // Safety check to prevent infinite loops - use Hasse bound: |#E(Fp) - (p+1)| <= 2√p\n      // So point order can be at most the group order, which is at most p+1+2√p\n      const maxOrder = this.params.p + 1 + 2 * Math.ceil(Math.sqrt(this.params.p));\n      if (order > maxOrder) {\n        throw new Error(`Point order calculation exceeded Hasse bound (${maxOrder})`);\n      }\n    }\n\n    return order;\n  }\n\n  /**\n   * Get curve equation as LaTeX string\n   */\n  getEquationLatex(): string {\n    const { a, b, p } = this.params;\n    let equation = 'y^2 = x^3';\n    \n    if (a !== 0) {\n      equation += a > 0 ? ` + ${a}x` : ` - ${Math.abs(a)}x`;\n    }\n    \n    if (b !== 0) {\n      equation += b > 0 ? ` + ${b}` : ` - ${Math.abs(b)}`;\n    }\n    \n    equation += ` \\\\pmod{${p}}`;\n    \n    return equation;\n  }\n\n  /**\n   * Format point as string\n   */\n  pointToString(point: EllipticCurvePoint): string {\n    if (point.isInfinity) return '∞';\n    return `(${point.x}, ${point.y})`;\n  }\n\n  /**\n   * Format point as LaTeX\n   */\n  pointToLatex(point: EllipticCurvePoint): string {\n    if (point.isInfinity) return '\\\\mathcal{O}';\n    return `(${point.x}, ${point.y})`;\n  }\n}\n\n/**\n * Elliptic Curve Group - integrates with the existing Group interface\n */\nexport class EllipticCurveGroup {\n  private curve: EllipticCurve;\n  private points: EllipticCurvePoint[];\n  private group: Group;\n\n  constructor(params: EllipticCurveParameters) {\n    this.curve = new EllipticCurve(params);\n    this.points = this.curve.getAllPoints();\n    this.group = this.createGroupStructure();\n  }\n\n  private createGroupStructure(): Group {\n    const elements: GroupElement[] = [];\n    const operations = new Map<string, Map<string, string>>();\n\n    // Create group elements\n    for (let i = 0; i < this.points.length; i++) {\n      const point = this.points[i];\n      const id = `P${i}`;\n      const label = this.curve.pointToString(point);\n      const latex = this.curve.pointToLatex(point);\n      \n      elements.push({\n        id,\n        label,\n        latex,\n        order: this.curve.pointOrder(point),\n        inverse: '', // Will be filled later\n        conjugacyClass: 0 // All elements in same class for abelian group\n      });\n\n      operations.set(id, new Map());\n    }\n\n    // Fill in operations table and inverses\n    for (let i = 0; i < this.points.length; i++) {\n      const P = this.points[i];\n      const idP = `P${i}`;\n      \n      // Find inverse\n      const negP = this.curve.negate(P);\n      const inverseIndex = this.points.findIndex(point => \n        point.isInfinity === negP.isInfinity && \n        point.x === negP.x && \n        point.y === negP.y\n      );\n      elements[i].inverse = `P${inverseIndex}`;\n\n      // Fill operation table\n      for (let j = 0; j < this.points.length; j++) {\n        const Q = this.points[j];\n        const idQ = `P${j}`;\n        const sum = this.curve.add(P, Q);\n        \n        const resultIndex = this.points.findIndex(point =>\n          point.isInfinity === sum.isInfinity &&\n          point.x === sum.x &&\n          point.y === sum.y\n        );\n        \n        operations.get(idP)!.set(idQ, `P${resultIndex}`);\n      }\n    }\n\n    // Find generators (points that generate the group)\n    const generators: string[] = [];\n    for (let i = 0; i < elements.length; i++) {\n      const elementOrder = elements[i].order;\n      if (elementOrder === this.points.length) {\n        generators.push(elements[i].id);\n      }\n    }\n\n    // If no single generator, find a minimal generating set\n    if (generators.length === 0) {\n      // For now, use the first non-identity element as generator\n      // In practice, we'd want to find a proper generating set\n      for (let i = 1; i < elements.length; i++) {\n        generators.push(elements[i].id);\n        break;\n      }\n    }\n\n    const { a, b, p } = this.curve.params;\n    const name = `E(${a},${b})/${p}`;\n    const displayName = `E: y² = x³ + ${a}x + ${b} (mod ${p})`;\n\n    return {\n      name,\n      displayName,\n      order: this.points.length,\n      elements,\n      operations,\n      generators,\n      relations: [], // Could add curve-specific relations\n      isAbelian: true, // Elliptic curves always form abelian groups\n      center: elements.map(e => e.id), // Entire group is the center (abelian)\n      conjugacyClasses: elements.map(e => [e.id]), // Each element is its own class\n      subgroups: [] // Could compute subgroups if needed\n    };\n  }\n\n  /**\n   * Get the Group interface representation\n   */\n  getGroup(): Group {\n    return this.group;\n  }\n\n  /**\n   * Get the underlying elliptic curve\n   */\n  getCurve(): EllipticCurve {\n    return this.curve;\n  }\n\n  /**\n   * Get all points on the curve\n   */\n  getPoints(): EllipticCurvePoint[] {\n    return [...this.points];\n  }\n\n  /**\n   * Convert point ID to actual point\n   */\n  getPointById(id: string): EllipticCurvePoint | undefined {\n    const index = parseInt(id.substring(1)); // Remove 'P' prefix\n    return this.points[index];\n  }\n\n  /**\n   * Convert point to point ID\n   */\n  getIdByPoint(point: EllipticCurvePoint): string | undefined {\n    const index = this.points.findIndex(p =>\n      p.isInfinity === point.isInfinity &&\n      p.x === point.x &&\n      p.y === point.y\n    );\n    return index >= 0 ? `P${index}` : undefined;\n  }\n\n  /**\n   * Create some common elliptic curves for educational purposes\n   */\n  static createExampleCurves(): { [name: string]: EllipticCurveParameters } {\n    return {\n      // Simple curves over small fields for demonstration\n      'E1': { a: 0, b: 1, p: 5 },    // y² = x³ + 1 (mod 5) - 6 points\n      'E2': { a: 1, b: 1, p: 7 },    // y² = x³ + x + 1 (mod 7) - 5 points  \n      'E3': { a: 1, b: 1, p: 5 },    // y² = x³ + x + 1 (mod 5) - 5 points\n      'E4': { a: 2, b: 2, p: 7 },    // y² = x³ + 2x + 2 (mod 7) - 8 points\n      'E5': { a: 1, b: 0, p: 7 },    // y² = x³ + x (mod 7) - 8 points\n      'E6': { a: 3, b: 8, p: 13 },   // y² = x³ + 3x + 8 (mod 13) - 9 points\n      'E7': { a: 0, b: 7, p: 11 },   // y² = x³ + 7 (mod 11) - 12 points\n      'E8': { a: 1, b: 3, p: 11 },   // y² = x³ + x + 3 (mod 11) - 16 points\n    };\n  }\n}"],"names":["EllipticCurve","EllipticCurveGroup","FiniteField","constructor","p","isPrime","Error","n","i","Math","sqrt","add","a","b","subtract","multiply","power","result","floor","inverse","oldR","r","oldS","s","quotient","isQuadraticResidue","x","normalize","params","field","discriminant","infinity","y","isInfinity","point","isOnCurve","leftSide","rightSide","P","Q","x1","y1","x2","y2","slope","numerator","denominator","x3","y3","negate","k","addend","getAllPoints","points","ySquared","yValues","push","pointOrder","current","order","maxOrder","ceil","getEquationLatex","equation","abs","pointToString","pointToLatex","curve","group","createGroupStructure","elements","operations","Map","length","id","label","latex","conjugacyClass","set","idP","negP","inverseIndex","findIndex","j","idQ","sum","resultIndex","get","generators","elementOrder","name","displayName","relations","isAbelian","center","map","e","conjugacyClasses","subgroups","getGroup","getCurve","getPoints","getPointById","index","parseInt","substring","getIdByPoint","undefined","createExampleCurves"],"mappings":"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"}